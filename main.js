/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  PresetFuzzyModal: () => PresetFuzzyModal,
  default: () => OpenRouterTranslatorPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// settings.ts
var import_obsidian = require("obsidian");

// types.ts
var AVAILABLE_LANGUAGES = [
  { code: "auto", name: "Auto Detect" },
  { code: "en", name: "English" },
  { code: "es", name: "Spanish" },
  { code: "fr", name: "French" },
  { code: "de", name: "German" },
  { code: "it", name: "Italian" },
  { code: "pt", name: "Portuguese" },
  { code: "ru", name: "Russian" },
  { code: "ja", name: "Japanese" },
  { code: "ko", name: "Korean" },
  { code: "zh", name: "Chinese" },
  { code: "ar", name: "Arabic" },
  { code: "hi", name: "Hindi" },
  { code: "nl", name: "Dutch" },
  { code: "pl", name: "Polish" },
  { code: "sv", name: "Swedish" },
  { code: "tr", name: "Turkish" },
  { code: "uk", name: "Ukrainian" },
  { code: "no", name: "Norwegian" },
  { code: "da", name: "Danish" },
  { code: "fi", name: "Finnish" },
  { code: "cs", name: "Czech" },
  { code: "hu", name: "Hungarian" },
  { code: "ro", name: "Romanian" },
  { code: "bg", name: "Bulgarian" },
  { code: "hr", name: "Croatian" },
  { code: "sk", name: "Slovak" },
  { code: "sl", name: "Slovenian" },
  { code: "et", name: "Estonian" },
  { code: "lv", name: "Latvian" },
  { code: "lt", name: "Lithuanian" },
  { code: "mt", name: "Maltese" },
  { code: "ga", name: "Irish" },
  { code: "cy", name: "Welsh" },
  { code: "eu", name: "Basque" },
  { code: "ca", name: "Catalan" },
  { code: "gl", name: "Galician" },
  { code: "is", name: "Icelandic" }
];
var DEFAULT_SETTINGS = {
  // --- PROVIDER-AWARE DEFAULTS ---
  apiProvider: "openrouter",
  providerSettings: {
    openrouter: {
      apiKey: "",
      model: "google/gemini-flash-1.5"
    },
    ollama: {
      apiEndpoint: "http://localhost:11434",
      model: "llama3"
    },
    custom: {
      apiEndpoint: "",
      apiKey: "",
      model: "",
      headers: '{\n  "Content-Type": "application/json",\n  "Authorization": "Bearer {apiKey}"\n}',
      requestBody: '{\n  "model": "{model}",\n  "messages": [\n    {\n      "role": "system",\n      "content": "{systemPrompt}"\n    },\n    {\n      "role": "user",\n      "content": "{userPrompt}"\n    }\n  ]\n}',
      responsePath: "choices[0].message.content"
    }
  },
  // Translation Behavior
  enableTranslation: true,
  useBatchTranslation: true,
  debugMode: false,
  // Language Settings
  sourceLanguage: "auto",
  targetLanguage: "en",
  // Visual Settings
  outputFontSizeScale: 0.95,
  outputLineHeight: 1.45,
  overlayOpacity: 99,
  // Processing Settings
  maxBatchChars: 7500,
  mergeOnStyleChange: false,
  // Storage Settings
  autoSaveOverlay: false,
  autoRefreshOverlay: false,
  storageLocation: "",
  useIndividualMarkdownStorage: true,
  indexFilePath: "Index.md",
  // UI Settings
  manualRefinementMode: false,
  showOverlayByDefault: true,
  clickToShowMode: false,
  // Custom Prompts
  batchPrompt: `You are a precise document translator. Translate each of the following numbered lines from {sourceLang} to {targetLang}, and only this language.

Example:
Input:
1. Hello world
2. Thank you very much
Output:
1. Hola mundo
2. Muchas gracias

Now translate:
{inputText}

Return exactly {lineCount} lines in this format:
1. Translated line one
2. Translated line two
...
No extra text. Never skip numbering. Only return the numbered list.`,
  singlePrompt: `Translate from {sourceLang} to {targetLang}. Only output the translation. Preserve formatting and tone.`,
  // --- NEW: Custom Copy Formats ---
  calloutFormat: "> [!quote] Translation\n> {blockquote_text}\n>\n> {pagelink}",
  citationFormat: "{blockquote_text}\n> \u2014 *{filename}, page {pagenumber}*",
  footnoteFormat: "^{text} [[{filename}#page={pagenumber}|source]]"
};

// settings.ts
var FolderSuggest = class extends import_obsidian.TextComponent {
  constructor(app, containerEl) {
    super(containerEl);
    this.app = app;
    this.setPlaceholder("e.g. My Translations/");
    this.inputEl.addEventListener("input", this.onInput.bind(this));
    this.inputEl.addEventListener("blur", this.onBlur.bind(this));
  }
  onInput() {
    const query = this.getValue().toLowerCase();
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const folders = abstractFiles.filter((f) => f instanceof import_obsidian.TFolder).map((f) => f.path);
    const suggestions = folders.filter((p) => p.toLowerCase().includes(query));
    this.setSuggestions(suggestions);
  }
  setSuggestions(suggestions) {
    var _a, _b;
    const dropdown = (_a = this.inputEl.parentElement) == null ? void 0 : _a.querySelector(".suggestion-dropdown");
    if (dropdown)
      dropdown.remove();
    if (suggestions.length > 0 && this.getValue()) {
      const drop = createEl("div", { cls: "suggestion-dropdown" });
      drop.style.position = "absolute";
      drop.style.top = this.inputEl.offsetTop + this.inputEl.offsetHeight + "px";
      drop.style.left = this.inputEl.offsetLeft + "px";
      drop.style.width = this.inputEl.offsetWidth + "px";
      drop.style.zIndex = "1000";
      drop.style.background = "var(--background-secondary)";
      drop.style.border = "1px solid var(--background-modifier-border)";
      drop.style.borderRadius = "4px";
      drop.style.maxHeight = "200px";
      drop.style.overflowY = "auto";
      drop.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.2)";
      suggestions.forEach((sug) => {
        const item = createEl("div", { text: sug, cls: "suggestion-item" });
        item.style.padding = "6px 10px";
        item.style.cursor = "pointer";
        item.addEventListener("mouseenter", () => item.style.background = "var(--background-modifier-hover)");
        item.addEventListener("mouseleave", () => item.style.background = "");
        item.onclick = () => {
          this.setValue(sug);
          this.inputEl.dispatchEvent(new Event("blur"));
          drop.remove();
        };
        drop.appendChild(item);
      });
      (_b = this.inputEl.parentElement) == null ? void 0 : _b.appendChild(drop);
    }
  }
  onBlur() {
    setTimeout(() => {
      var _a;
      const dropdown = (_a = this.inputEl.parentElement) == null ? void 0 : _a.querySelector(".suggestion-dropdown");
      if (dropdown)
        dropdown.remove();
    }, 200);
  }
};
var OpenRouterSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "PDF Text Translator" });
    new import_obsidian.Setting(containerEl).setName("API Provider").setDesc("Choose your preferred translation service.").addDropdown((dd) => {
      dd.addOption("openrouter", "OpenRouter").addOption("ollama", "Ollama (Local)").addOption("custom", "Custom Endpoint").setValue(this.plugin.settings.apiProvider).onChange(async (value) => {
        this.plugin.settings.apiProvider = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    containerEl.createEl("hr");
    const provider = this.plugin.settings.apiProvider;
    const providerSettings = this.plugin.settings.providerSettings[provider];
    if (provider === "openrouter") {
      new import_obsidian.Setting(containerEl).setName("OpenRouter Settings").setHeading();
      new import_obsidian.Setting(containerEl).setName("OpenRouter API Key").setDesc("Get your key from https://openrouter.ai/keys").addText((text) => {
        text.setPlaceholder("sk-or-v1-...").setValue(providerSettings.apiKey || "").onChange(async (value) => {
          providerSettings.apiKey = value.trim();
          await this.plugin.saveSettings();
        });
        text.inputEl.type = "password";
      });
      new import_obsidian.Setting(containerEl).setName("Model").setDesc("Choose a model (e.g., google/gemini-flash-1.5 is recommended)").addDropdown(async (dd) => {
        dd.setDisabled(true);
        dd.addOption("", "Loading models...");
        try {
          const resp = await (0, import_obsidian.requestUrl)("https://openrouter.ai/api/v1/models");
          const data = await resp.json;
          const models = (Array.isArray(data.data) ? data.data : []).sort((a, b) => a.name.localeCompare(b.name));
          dd.selectEl.empty();
          models.forEach((m) => dd.addOption(m.id, `${m.name} (${m.id})`));
          dd.setValue(providerSettings.model || "google/gemini-flash-1.5");
          dd.setDisabled(false);
        } catch (err) {
          console.error("Failed to load models from OpenRouter:", err);
          dd.selectEl.empty();
          dd.addOption(providerSettings.model || "google/gemini-flash-1.5", `Default (${providerSettings.model || "google/gemini-flash-1.5"})`);
          dd.setValue(providerSettings.model || "google/gemini-flash-1.5");
          new import_obsidian.Notice("\u26A0\uFE0F Could not load models. Using current setting.");
          dd.setDisabled(false);
        }
        dd.onChange(async (v) => {
          providerSettings.model = v;
          await this.plugin.saveSettings();
        });
      });
    } else if (provider === "ollama") {
      new import_obsidian.Setting(containerEl).setName("Ollama (Local) Settings").setHeading();
      new import_obsidian.Setting(containerEl).setName("Ollama API Endpoint").setDesc("The local URL for your Ollama server.").addText((text) => text.setPlaceholder("http://localhost:11434").setValue(providerSettings.apiEndpoint || "").onChange(async (value) => {
        providerSettings.apiEndpoint = value;
        await this.plugin.saveSettings();
        this.display();
      }));
      new import_obsidian.Setting(containerEl).setName("Model").setDesc("Choose a local model to use.").addDropdown(async (dd) => {
        dd.setDisabled(true);
        dd.addOption("", "Fetching local models...");
        const endpoint = providerSettings.apiEndpoint || "http://localhost:11434";
        try {
          const resp = await (0, import_obsidian.requestUrl)({ url: `${endpoint}/api/tags` });
          const data = await resp.json;
          dd.selectEl.empty();
          if (data.models && data.models.length > 0) {
            data.models.forEach((m) => dd.addOption(m.name, m.name));
            dd.setValue(providerSettings.model || data.models[0].name);
          } else {
            dd.addOption("", "No models found");
          }
        } catch (e) {
          console.error("Error fetching Ollama models:", e);
          new import_obsidian.Notice(`\u26A0\uFE0F Could not connect to Ollama at ${endpoint}.`);
          dd.selectEl.empty();
          dd.addOption(providerSettings.model || "llama3", `(Enter model name manually)`);
          dd.setValue(providerSettings.model || "llama3");
        }
        dd.setDisabled(false);
        dd.onChange(async (v) => {
          providerSettings.model = v;
          await this.plugin.saveSettings();
        });
      });
    } else if (provider === "custom") {
      new import_obsidian.Setting(containerEl).setName("Custom Endpoint Settings").setHeading();
      new import_obsidian.Setting(containerEl).setName("API Endpoint URL").addText((t) => t.setValue(providerSettings.apiEndpoint || "").onChange(async (v) => {
        providerSettings.apiEndpoint = v;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("API Key (Optional)").setDesc("Your API key. Use {apiKey} in Headers if needed.").addText((t) => {
        t.setValue(providerSettings.apiKey || "").onChange(async (v) => {
          providerSettings.apiKey = v.trim();
          await this.plugin.saveSettings();
        });
        t.inputEl.type = "password";
      });
      new import_obsidian.Setting(containerEl).setName("Model Name").setDesc("The model identifier to include in the request body.").addText((t) => t.setValue(providerSettings.model || "").onChange(async (v) => {
        providerSettings.model = v;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Request Headers (JSON)").setDesc("JSON object for request headers. Use {apiKey} for your key.").addTextArea((ta) => {
        ta.setValue(providerSettings.headers || DEFAULT_SETTINGS.providerSettings.custom.headers).onChange(async (v) => {
          providerSettings.headers = v;
          await this.plugin.saveSettings();
        });
        ta.inputEl.rows = 4;
      });
      new import_obsidian.Setting(containerEl).setName("Request Body (JSON Template)").setDesc("JSON template with placeholders: {model}, {systemPrompt}, {userPrompt}.").addTextArea((ta) => {
        ta.setValue(providerSettings.requestBody || DEFAULT_SETTINGS.providerSettings.custom.requestBody).onChange(async (v) => {
          providerSettings.requestBody = v;
          await this.plugin.saveSettings();
        });
        ta.inputEl.rows = 10;
      });
      new import_obsidian.Setting(containerEl).setName("Response Path").setDesc("Dot notation path to the translated text in the response JSON.").addText((t) => t.setPlaceholder("e.g., choices[0].message.content").setValue(providerSettings.responsePath || DEFAULT_SETTINGS.providerSettings.custom.responsePath).onChange(async (v) => {
        providerSettings.responsePath = v;
        await this.plugin.saveSettings();
      }));
    }
    containerEl.createEl("hr");
    new import_obsidian.Setting(containerEl).setName("General Settings").setHeading();
    new import_obsidian.Setting(containerEl).setName("Translation Storage Location").setDesc("Choose where to save translation files. Leave empty to save next to each PDF.").addText((text) => {
      const folderSuggest = new FolderSuggest(this.app, text.inputEl.parentElement);
      folderSuggest.setValue(this.plugin.settings.storageLocation);
      text.inputEl.replaceWith(folderSuggest.inputEl);
      folderSuggest.inputEl.addEventListener("blur", async () => {
        let value = folderSuggest.getValue().trim();
        if (value === "/" || value === "." || value === "..")
          value = "";
        const normalized = value ? (0, import_obsidian.normalizePath)(value + (value.endsWith("/") ? "" : "/")) : "";
        this.plugin.settings.storageLocation = normalized;
        await this.plugin.saveSettings();
        new import_obsidian.Notice(`\u{1F4C1} Translation location set to: ${normalized || "Next to PDF"}`);
      });
    });
    new import_obsidian.Setting(containerEl).setName("Enable Translation").addToggle((t) => t.setValue(this.plugin.settings.enableTranslation).onChange(async (v) => {
      this.plugin.settings.enableTranslation = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Use Batch Translation").setDesc("Send all text in one request (recommended).").addToggle((t) => t.setValue(this.plugin.settings.useBatchTranslation).onChange(async (v) => {
      this.plugin.settings.useBatchTranslation = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto-save Overlay").addToggle((t) => t.setValue(this.plugin.settings.autoSaveOverlay).onChange(async (v) => {
      this.plugin.settings.autoSaveOverlay = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto-refresh Translations").setDesc("Automatically re-translate when a PDF is opened.").addToggle((t) => t.setValue(this.plugin.settings.autoRefreshOverlay).onChange(async (v) => {
      this.plugin.settings.autoRefreshOverlay = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Source Language").addDropdown((d) => {
      AVAILABLE_LANGUAGES.forEach((l) => d.addOption(l.code, l.name));
      d.setValue(this.plugin.settings.sourceLanguage).onChange(async (v) => {
        this.plugin.settings.sourceLanguage = v;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Target Language").addDropdown((d) => {
      AVAILABLE_LANGUAGES.filter((l) => l.code !== "auto").forEach((l) => d.addOption(l.code, l.name));
      d.setValue(this.plugin.settings.targetLanguage).onChange(async (v) => {
        this.plugin.settings.targetLanguage = v;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("hr");
    new import_obsidian.Setting(containerEl).setName("Advanced Settings").setHeading();
    new import_obsidian.Setting(containerEl).setName("Batch Translation Prompt").setDesc("System prompt for batch translations. Placeholders: {sourceLang}, {targetLang}, {lineCount}, {inputText}").then((setting) => {
      setting.controlEl.style.flexDirection = "column";
      setting.controlEl.style.alignItems = "flex-end";
      const textarea = new import_obsidian.TextAreaComponent(setting.controlEl).setValue(this.plugin.settings.batchPrompt).onChange(async (v) => {
        this.plugin.settings.batchPrompt = v;
        await this.plugin.saveSettings();
      });
      textarea.inputEl.style.width = "100%";
      textarea.inputEl.rows = 8;
      new import_obsidian.ButtonComponent(setting.controlEl).setButtonText("Restore Default").onClick(async () => {
        this.plugin.settings.batchPrompt = DEFAULT_SETTINGS.batchPrompt;
        await this.plugin.saveSettings();
        textarea.setValue(DEFAULT_SETTINGS.batchPrompt);
      }).buttonEl.style.marginTop = "8px";
    });
    new import_obsidian.Setting(containerEl).setName("Single Sentence Prompt").setDesc("System prompt for single translations. Placeholders: {sourceLang}, {targetLang}").then((setting) => {
      setting.controlEl.style.flexDirection = "column";
      setting.controlEl.style.alignItems = "flex-end";
      const textarea = new import_obsidian.TextAreaComponent(setting.controlEl).setValue(this.plugin.settings.singlePrompt).onChange(async (v) => {
        this.plugin.settings.singlePrompt = v;
        await this.plugin.saveSettings();
      });
      textarea.inputEl.style.width = "100%";
      textarea.inputEl.rows = 4;
      new import_obsidian.ButtonComponent(setting.controlEl).setButtonText("Restore Default").onClick(async () => {
        this.plugin.settings.singlePrompt = DEFAULT_SETTINGS.singlePrompt;
        await this.plugin.saveSettings();
        textarea.setValue(DEFAULT_SETTINGS.singlePrompt);
      }).buttonEl.style.marginTop = "8px";
    });
    containerEl.createEl("hr");
    new import_obsidian.Setting(containerEl).setName("Custom Copy Formats").setHeading();
    const placeholderDesc = createFragment((doc) => {
      doc.createSpan({ text: "Placeholders: " });
      doc.createEl("code", { text: "{text}" });
      doc.createSpan({ text: ", " });
      doc.createEl("code", { text: "{blockquote_text}" });
      doc.createSpan({ text: ", " });
      doc.createEl("code", { text: "{filename}" });
      doc.createSpan({ text: ", " });
      doc.createEl("code", { text: "{pagelink}" });
      doc.createSpan({ text: ", " });
      doc.createEl("code", { text: "{pagenumber}" });
    });
    const createFormatSetting = (name, settingKey) => {
      new import_obsidian.Setting(containerEl).setName(name).setDesc(placeholderDesc).then((setting) => {
        setting.controlEl.style.flexDirection = "column";
        setting.controlEl.style.alignItems = "flex-end";
        const textarea = new import_obsidian.TextAreaComponent(setting.controlEl).setValue(this.plugin.settings[settingKey]).onChange(async (v) => {
          this.plugin.settings[settingKey] = v;
          await this.plugin.saveSettings();
        });
        textarea.inputEl.style.width = "100%";
        textarea.inputEl.rows = 5;
        new import_obsidian.ButtonComponent(setting.controlEl).setButtonText("Restore Default").onClick(async () => {
          this.plugin.settings[settingKey] = DEFAULT_SETTINGS[settingKey];
          await this.plugin.saveSettings();
          textarea.setValue(DEFAULT_SETTINGS[settingKey]);
        }).buttonEl.style.marginTop = "8px";
      });
    };
    createFormatSetting("Callout Format", "calloutFormat");
    createFormatSetting("Citation Format", "citationFormat");
    createFormatSetting("Footnote Format", "footnoteFormat");
    new import_obsidian.Setting(containerEl).setName("Output Font Size Scale").addSlider((s) => s.setLimits(0.4, 1.2, 0.05).setValue(this.plugin.settings.outputFontSizeScale).setDynamicTooltip().onChange(async (v) => {
      this.plugin.settings.outputFontSizeScale = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Output Line Height").addSlider((s) => s.setLimits(0.5, 2, 0.05).setValue(this.plugin.settings.outputLineHeight).setDynamicTooltip().onChange(async (v) => {
      this.plugin.settings.outputLineHeight = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Max Batch Input Length").setDesc("Maximum characters sent at once to prevent API errors.").addSlider((s) => s.setLimits(50, 15e3, 50).setValue(this.plugin.settings.maxBatchChars).setDynamicTooltip().onChange(async (v) => {
      this.plugin.settings.maxBatchChars = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Manual Paragraph Refinement").setDesc("Enable Shift+click and Ctrl+M to merge translation blocks.").addToggle((t) => t.setValue(this.plugin.settings.manualRefinementMode).onChange(async (v) => {
      this.plugin.settings.manualRefinementMode = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Debug Mode").setDesc("Log detailed information to the developer console.").addToggle((t) => t.setValue(this.plugin.settings.debugMode).onChange(async (v) => {
      this.plugin.settings.debugMode = v;
      await this.plugin.saveSettings();
    }));
  }
};

// storage.ts
var import_obsidian2 = require("obsidian");
var STORAGE_FORMAT_VERSION = 3;
var TranslationStorage = class {
  // Concurrency guard for writing
  constructor(plugin) {
    this.loadingPromises = /* @__PURE__ */ new Map();
    // Per-file concurrency guard
    this.writingPromises = /* @__PURE__ */ new Map();
    this.plugin = plugin;
    this.app = plugin.app;
  }
  /**
   * Gets the user-defined storage location for translation files.
   * Defaults to same folder as PDF if empty.
   */
  get storageLocation() {
    return this.plugin.settings.storageLocation || "";
  }
  /**
   * Ensures the storage folder exists.
   */
  async ensureStorageFolder() {
    const path = this.storageLocation;
    if (!path || path === "/" || path === "." || path === "..")
      return;
    try {
      const folder = this.app.vault.getAbstractFileByPath(path);
      if (folder instanceof import_obsidian2.TFolder)
        return;
      if (folder) {
        throw new Error(`Path conflict: a file exists at '${path}'`);
      }
      await this.app.vault.createFolder(path);
    } catch (error) {
      if (!String(error).includes("Folder already exists")) {
        console.error(`PDF Translator: Failed to create folder '${path}'`, error);
        new import_obsidian2.Notice(`Error: Could not create folder "${path}"`);
      }
    }
  }
  /**
   * Finds the translation file for a PDF using the cached map.
   */
  async findTranslationFileForPdf(pdfFile) {
    const translationPath = this.plugin.pdfToMdMap.get(pdfFile.path);
    if (translationPath) {
      const file = this.app.vault.getAbstractFileByPath(translationPath);
      if (file instanceof import_obsidian2.TFile)
        return file;
    }
    return null;
  }
  /**
   * Constructs the translation file path based on settings.
   */
  getTranslationFilePath(pdfFile) {
    var _a;
    const baseName = pdfFile.basename;
    const dir = this.storageLocation || ((_a = pdfFile.parent) == null ? void 0 : _a.path) || "";
    const cleanDir = dir && dir !== "/" ? dir.replace(/\/+$/, "") : "";
    return (0, import_obsidian2.normalizePath)(`${cleanDir ? cleanDir + "/" : ""}${baseName}.translations.md`);
  }
  /**
   * Generates the markdown content for a translation file in the v3 format.
   */
  generateMarkdownForOverlay(savedOverlay, pdfFile) {
    const frontmatter = `---
pdf-source: '[[${pdfFile.path}]]'
timestamp: ${new Date(savedOverlay.timestamp).toISOString()}
format-version: ${STORAGE_FORMAT_VERSION}
---
`;
    let md = frontmatter + `
# Translations for ${pdfFile.basename}
> Last updated: ${new Date(savedOverlay.timestamp).toLocaleString()}

`;
    const pageNumbers = Object.keys(savedOverlay.pageOverlays).map(Number).sort((a, b) => a - b);
    for (const pageNumber of pageNumbers) {
      const items = savedOverlay.pageOverlays[pageNumber];
      if (!(items == null ? void 0 : items.length))
        continue;
      md += `
## Page ${pageNumber}

`;
      md += `[[${pdfFile.path}#page=${pageNumber}|\u2192 View page]]

`;
      items.forEach((item) => {
        const originalText = (item.textContent || "").trim();
        const metadata = {
          r: {
            l: parseFloat(item.relativeRect.left.toFixed(4)),
            t: parseFloat(item.relativeRect.top.toFixed(4)),
            w: parseFloat(item.relativeRect.width.toFixed(4)),
            h: parseFloat(item.relativeRect.height.toFixed(4))
          },
          page: item.page,
          ot: originalText
          // Original Text
        };
        if (item.fontSize !== void 0) {
          metadata.fs = parseFloat(item.fontSize.toFixed(2));
        }
        if (item.fontFamily) {
          metadata.ff = item.fontFamily;
        }
        if (item.originalFontSizes && item.originalFontSizes.length > 0) {
          metadata.ofs = item.originalFontSizes.map((fs) => parseFloat(fs.toFixed(2)));
        }
        const metadataStr = JSON.stringify(metadata);
        const comment = `%% ${metadataStr} %%`;
        const translated = (item.translatedText || "").trim().replace(/\n/g, "<br>");
        md += `${comment}

`;
        md += `${translated}

`;
      });
    }
    return md;
  }
  /**
   * Validates metadata structure against schema
   */
  validateMetadata(metadata) {
    if (typeof metadata !== "object" || !metadata.r || typeof metadata.page !== "number") {
      return false;
    }
    const rect = metadata.r;
    if (typeof rect.l !== "number" || typeof rect.t !== "number" || typeof rect.w !== "number" || typeof rect.h !== "number" || rect.w <= 0 || rect.h <= 0) {
      return false;
    }
    return true;
  }
  /**
   * Parses a markdown file into a SavedOverlay object.
   * Supports v1, v2 (table-based), and v3 (comment-based) formats.
   */
  parseMarkdownOverlay(content, pdfFile) {
    const frontmatterMatch = content.match(/---\n([\s\S]+?)\n---/);
    let formatVersion = 1;
    let timestamp = Date.now();
    if (frontmatterMatch) {
      try {
        const fmData = (0, import_obsidian2.parseYaml)(frontmatterMatch[1]);
        formatVersion = fmData["format-version"] || fmData.version || 1;
        if (fmData.timestamp) {
          const t = new Date(fmData.timestamp);
          if (!isNaN(t.getTime()))
            timestamp = t.getTime();
        }
      } catch (err) {
        console.warn("PDF Translator: Failed to parse frontmatter YAML", err);
      }
    }
    const body = content.substring((frontmatterMatch == null ? void 0 : frontmatterMatch[0].length) || 0);
    const lines = body.split("\n");
    const pageOverlays = {};
    let currentPage = null;
    if (formatVersion >= 3) {
      const V3_META_REGEX = /^%%\s*(\{.*\})\s*%%/;
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        const pageMatch = line.match(/^##\s+Page\s+(\d+)/i);
        if (pageMatch) {
          currentPage = pageMatch[1];
          if (!pageOverlays[currentPage])
            pageOverlays[currentPage] = [];
          continue;
        }
        if (!currentPage)
          continue;
        const metaMatch = line.match(V3_META_REGEX);
        if (metaMatch) {
          try {
            const metadata = JSON.parse(metaMatch[1]);
            if (!this.validateMetadata(metadata)) {
              if (this.plugin.settings.debugMode) {
                console.warn("PDF Translator: Invalid V3 metadata structure", metadata);
              }
              continue;
            }
            let translatedText = "";
            for (let j = i + 1; j < lines.length; j++) {
              if (lines[j].trim()) {
                translatedText = lines[j].trim().replace(/<br>/g, "\n");
                i = j;
                break;
              }
            }
            const overlayData = {
              selector: "",
              // Selector is deprecated
              textContent: metadata.ot || "",
              // Original Text from metadata
              relativeRect: {
                left: metadata.r.l,
                top: metadata.r.t,
                width: metadata.r.w,
                height: metadata.r.h
              },
              page: metadata.page,
              translatedText,
              fontSize: metadata.fs,
              fontFamily: metadata.ff,
              originalFontSizes: metadata.ofs
            };
            pageOverlays[currentPage].push(overlayData);
          } catch (e) {
            if (this.plugin.settings.debugMode) {
              console.debug("PDF Translator: Invalid V3 metadata JSON", e);
            }
          }
        }
      }
    } else {
      const NEW_META_REGEX = /<!--\s*PDF_TRANSLATOR_METADATA:([a-zA-Z0-9+/=]+)\s*-->/;
      const OLD_META_REGEX = /<!--\s*(\{.*?\})\s*-->/;
      for (const line of lines) {
        const trimmed = line.trim();
        const pageMatch = trimmed.match(/^##\s+Page\s+(\d+)/i);
        if (pageMatch) {
          currentPage = pageMatch[1];
          pageOverlays[currentPage] = [];
          continue;
        }
        if (!currentPage || !trimmed.startsWith("|") || trimmed.includes("|-|"))
          continue;
        const cells = this.parseMarkdownTableCells(trimmed);
        if (cells.length !== 2)
          continue;
        const [originalCell, translatedCell] = cells;
        let metadata = null;
        const newMetaMatch = originalCell.match(NEW_META_REGEX);
        if (newMetaMatch) {
          try {
            metadata = JSON.parse(decodeURIComponent(escape(atob(newMetaMatch[1]))));
          } catch (e) {
          }
        } else {
          const oldMetaMatch = originalCell.match(OLD_META_REGEX);
          if (oldMetaMatch) {
            try {
              metadata = JSON.parse(oldMetaMatch[1]);
            } catch (e) {
            }
          }
        }
        if (!metadata || !this.validateMetadata(metadata))
          continue;
        const textContent = originalCell.replace(NEW_META_REGEX, "").replace(OLD_META_REGEX, "").replace(/\\\|/g, "|").trim();
        const translatedText = translatedCell.replace(/\\\|/g, "|").replace(/\\n/g, "\n");
        const overlayData = {
          selector: metadata.sel || "",
          textContent,
          relativeRect: { left: metadata.r.l, top: metadata.r.t, width: metadata.r.w, height: metadata.r.h },
          page: metadata.page,
          translatedText,
          fontSize: metadata.fontSize,
          fontFamily: metadata.fontFamily,
          originalFontSizes: metadata.originalFontSizes
        };
        pageOverlays[currentPage].push(overlayData);
      }
    }
    if (Object.keys(pageOverlays).length === 0) {
      return null;
    }
    return {
      fileName: pdfFile.basename.replace(/\.pdf$/i, ""),
      filePath: pdfFile.path,
      timestamp,
      pageOverlays
    };
  }
  /**
   * Helper to parse Markdown table cells, handling escaped pipes. (For V1/V2)
   */
  parseMarkdownTableCells(line) {
    const cells = [];
    let current = "";
    let i = 1;
    while (i < line.length - 1) {
      const char = line[i];
      if (char === "\\" && line[i + 1] === "|") {
        current += "|";
        i += 2;
        continue;
      }
      if (char === "|") {
        cells.push(current.trim());
        current = "";
        i++;
        continue;
      }
      current += char;
      i++;
    }
    cells.push(current.trim());
    return cells;
  }
  // ... (The rest of the class methods: saveCurrentOverlay, loadSavedOverlayForCurrentPage, etc., do not need to be changed as they rely on the abstraction provided by the generation and parsing methods.)
  /**
   * Saves the current overlay for the active page.
   * Merges with existing data from file.
   */
  async saveCurrentOverlay() {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "pdf") {
      new import_obsidian2.Notice("Please open a PDF first.");
      return;
    }
    const currentPageNumber = this.plugin.getCurrentPageNumber();
    if (currentPageNumber === null)
      return;
    const textLayer = this.plugin.overlay.getCurrentPageTextLayer();
    const overlayContainer = (_a = textLayer == null ? void 0 : textLayer.closest(".page")) == null ? void 0 : _a.querySelector(".pdf-text-overlay-container");
    if (!textLayer || !overlayContainer) {
      new import_obsidian2.Notice("No overlay to save.");
      return;
    }
    const positionData = this.extractPositionData(textLayer, overlayContainer);
    if (positionData.length === 0) {
      new import_obsidian2.Notice("Could not extract overlay data.");
      return;
    }
    let savedOverlay = {
      fileName: activeFile.basename.replace(/\.pdf$/i, ""),
      filePath: activeFile.path,
      timestamp: Date.now(),
      pageOverlays: {}
    };
    const translationFile = await this.findTranslationFileForPdf(activeFile);
    if (translationFile) {
      try {
        const content = await this.app.vault.read(translationFile);
        const parsed = this.parseMarkdownOverlay(content, activeFile);
        if (parsed)
          savedOverlay = parsed;
      } catch (e) {
        console.warn("PDF Translator: Failed to read existing translation file", e);
      }
    }
    savedOverlay.timestamp = Date.now();
    savedOverlay.pageOverlays[currentPageNumber] = positionData;
    const markdownContent = this.generateMarkdownForOverlay(savedOverlay, activeFile);
    if (translationFile) {
      await this.app.vault.modify(translationFile, markdownContent);
    } else {
      const translationPath = this.getTranslationFilePath(activeFile);
      await this.ensureStorageFolder();
      await this.app.vault.create(translationPath, markdownContent);
      this.plugin.pdfToMdMap.set(activeFile.path, translationPath);
      if (this.plugin.settings.debugMode) {
        console.log(`PDF Translator: Created translation file at ${translationPath}`);
      }
    }
    new import_obsidian2.Notice(`Overlay saved for ${activeFile.basename} page ${currentPageNumber}`);
  }
  /**
   * Loads the saved overlay for the current page.
   * If forceReload is true, removes any existing overlay before loading.
   */
  async loadSavedOverlayForCurrentPage(file, forceReload = false) {
    const currentPageNumber = this.plugin.getCurrentPageNumber();
    if (currentPageNumber === null)
      return;
    const pageElement = this.plugin.overlay.getCurrentPageElement();
    if (!pageElement)
      return;
    if (forceReload) {
      const existingOverlay2 = pageElement.querySelector(".pdf-text-overlay-container");
      if (existingOverlay2) {
        existingOverlay2.remove();
      }
    }
    const existingOverlay = pageElement.querySelector(".pdf-text-overlay-container");
    if (existingOverlay && !forceReload) {
      return;
    }
    const fileKey = file.path;
    if (this.loadingPromises.has(fileKey)) {
      await this.loadingPromises.get(fileKey);
      return;
    }
    const loader = async () => {
      const translationFile = await this.findTranslationFileForPdf(file);
      if (!translationFile)
        return;
      try {
        const content = await this.app.vault.read(translationFile);
        const savedOverlay = this.parseMarkdownOverlay(content, file);
        if (!savedOverlay)
          return;
        const pageKey = currentPageNumber.toString();
        const pageData = savedOverlay.pageOverlays[pageKey];
        if (!Array.isArray(pageData) || pageData.length === 0)
          return;
        const textLayer = await this.plugin.overlay.waitForPdfTextLayer(currentPageNumber);
        if (!textLayer)
          return;
        this.plugin.overlay.renderSavedOverlay(pageData, currentPageNumber);
        if (this.plugin.settings.debugMode) {
          console.log(`PDF Translator: Loaded overlay for page ${currentPageNumber} (${pageData.length} items)`);
        }
      } catch (error) {
        console.error("PDF Translator: Failed to load saved overlay", error);
      }
    };
    const promise = loader();
    this.loadingPromises.set(fileKey, promise);
    await promise;
    this.loadingPromises.delete(fileKey);
  }
  /**
   * Deletes the overlay for the current page.
   * If it's the last page, deletes the whole file.
   */
  async deleteCurrentOverlay() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "pdf") {
      new import_obsidian2.Notice("Please open a PDF file first.");
      return;
    }
    const currentPageNumber = this.plugin.getCurrentPageNumber();
    if (currentPageNumber === null)
      return;
    const translationFile = await this.findTranslationFileForPdf(activeFile);
    if (!translationFile) {
      new import_obsidian2.Notice("No translation file found for this PDF.");
      return;
    }
    try {
      const content = await this.app.vault.read(translationFile);
      const savedOverlay = this.parseMarkdownOverlay(content, activeFile);
      if (!savedOverlay) {
        new import_obsidian2.Notice("Could not parse translation data.");
        return;
      }
      const pageKey = currentPageNumber.toString();
      if (!savedOverlay.pageOverlays[pageKey]) {
        new import_obsidian2.Notice(`No overlay saved for page ${currentPageNumber}.`);
        return;
      }
      delete savedOverlay.pageOverlays[pageKey];
      if (Object.keys(savedOverlay.pageOverlays).length === 0) {
        await this.app.vault.trash(translationFile, true);
        this.plugin.pdfToMdMap.delete(activeFile.path);
        new import_obsidian2.Notice(`Translation file deleted for ${activeFile.basename}`);
      } else {
        const markdownContent = this.generateMarkdownForOverlay(savedOverlay, activeFile);
        await this.app.vault.modify(translationFile, markdownContent);
        new import_obsidian2.Notice(`Overlay deleted for page ${currentPageNumber}`);
      }
      this.plugin.clearAllOverlays();
    } catch (error) {
      console.error("PDF Translator: Failed to delete overlay", error);
      new import_obsidian2.Notice("Error deleting overlay.");
    }
  }
  /**
   * Extracts positioning and content data from rendered overlay elements.
   * Uses the closest .page[data-page-number] to determine the page number.
   */
  extractPositionData(textLayer, overlayContainer) {
    const positionData = [];
    const overlays = overlayContainer.querySelectorAll(".pdf-text-overlay-reflow");
    const textLayerRect = textLayer.getBoundingClientRect();
    const pageElement = overlayContainer.closest(".page[data-page-number]");
    const pageNumber = pageElement ? parseInt(pageElement.getAttribute("data-page-number") || "0", 10) : 0;
    if (textLayerRect.width === 0 || textLayerRect.height === 0) {
      console.error("PDF Translator: Text layer has zero dimensions");
      return [];
    }
    const pdfViewer = document.querySelector(".pdfViewer, #viewer");
    const saveScale = parseFloat((pdfViewer == null ? void 0 : pdfViewer.style.getPropertyValue("--scale-factor")) || "1");
    if (isNaN(saveScale) || saveScale <= 0) {
      console.warn("PDF Translator: Invalid saveScale, using 1.0");
    }
    overlays.forEach((overlay) => {
      const originalText = overlay.getAttribute("data-original-text") || "";
      const translatedDiv = overlay.querySelector("div");
      const translatedText = translatedDiv ? translatedDiv.innerHTML : overlay.textContent || "";
      const rect = overlay.getBoundingClientRect();
      const relativeRect = {
        left: (rect.left - textLayerRect.left) / textLayerRect.width,
        top: (rect.top - textLayerRect.top) / textLayerRect.height,
        width: rect.width / textLayerRect.width,
        height: rect.height / textLayerRect.height
      };
      const fontSizesStr = overlay.getAttribute("data-original-font-sizes") || "";
      let absoluteFontSizes = [];
      if (fontSizesStr) {
        try {
          absoluteFontSizes = JSON.parse(fontSizesStr);
        } catch (e) {
          console.warn("PDF Translator: Failed to parse font sizes from attribute", e);
        }
      }
      const relativeFontSizes = absoluteFontSizes.length > 0 && saveScale > 0 ? absoluteFontSizes.map((fs) => fs / saveScale) : [];
      const avgRelative = relativeFontSizes.length > 0 ? relativeFontSizes.reduce((a, b) => a + b, 0) / relativeFontSizes.length : void 0;
      const fontFamily = overlay.getAttribute("data-font-family") || overlay.style.fontFamily || void 0;
      const overlayData = {
        selector: "",
        textContent: originalText,
        relativeRect,
        page: pageNumber,
        translatedText,
        // Set relative font data
        fontSize: avgRelative,
        fontFamily,
        originalFontSizes: relativeFontSizes
      };
      positionData.push(overlayData);
    });
    return positionData;
  }
  // ============================================================
  // Helpers for re-translation modal (read/write convenience)
  // ============================================================
  /**
   * Reads the saved overlay structure for a given PDF file.
   * Returns null if no file or no overlay data.
   */
  async readSavedOverlayForFile(pdfFile) {
    const mdFile = await this.findTranslationFileForPdf(pdfFile);
    if (!mdFile)
      return null;
    try {
      const content = await this.app.vault.read(mdFile);
      const parsed = this.parseMarkdownOverlay(content, pdfFile);
      if (!parsed)
        return null;
      return { mdFile, overlay: parsed };
    } catch (e) {
      console.warn("PDF Translator: Failed to read saved overlay for file", pdfFile.path, e);
      return null;
    }
  }
  /**
   * Writes a SavedOverlay structure back to its .translations.md.
   * Ensures timestamp is updated and map stays in sync if file is created.
   */
  async writeSavedOverlayForFile(pdfFile, savedOverlay) {
    const existing = await this.findTranslationFileForPdf(pdfFile);
    const markdownContent = this.generateMarkdownForOverlay(savedOverlay, pdfFile);
    if (existing) {
      await this.app.vault.modify(existing, markdownContent);
    } else {
      const translationPath = this.getTranslationFilePath(pdfFile);
      await this.ensureStorageFolder();
      await this.app.vault.create(translationPath, markdownContent);
      this.plugin.pdfToMdMap.set(pdfFile.path, translationPath);
      if (this.plugin.settings.debugMode) {
        console.log(`PDF Translator: Created translation file at ${translationPath}`);
      }
    }
  }
  /**
   * Updates one or more pages in a SavedOverlay and writes to disk.
   * This function is now corrected to prevent race conditions.
   * pages is a map pageNumber -> array of OverlayPositionData.
   */
  async updatePageOverlaysAndWrite(pdfFile, pages) {
    const lockKey = pdfFile.path;
    const writer = async () => {
      const translationPath = this.getTranslationFilePath(pdfFile);
      const abstractFile = this.app.vault.getAbstractFileByPath(translationPath);
      let mdFile = abstractFile instanceof import_obsidian2.TFile ? abstractFile : null;
      let savedOverlay = null;
      if (mdFile) {
        try {
          const content = await this.app.vault.read(mdFile);
          savedOverlay = this.parseMarkdownOverlay(content, pdfFile);
        } catch (e) {
          this.plugin.logDebug("Failed to read or parse existing translation file, will overwrite.", e);
        }
      }
      if (!savedOverlay) {
        savedOverlay = {
          fileName: pdfFile.basename.replace(/\.pdf$/i, ""),
          filePath: pdfFile.path,
          timestamp: Date.now(),
          pageOverlays: {}
        };
      }
      for (const [pageStr, items] of Object.entries(pages)) {
        const p = Number(pageStr);
        if (items.length > 0) {
          savedOverlay.pageOverlays[p] = items;
        } else {
          delete savedOverlay.pageOverlays[p];
        }
      }
      savedOverlay.timestamp = Date.now();
      const md = this.generateMarkdownForOverlay(savedOverlay, pdfFile);
      if (mdFile) {
        await this.app.vault.modify(mdFile, md);
      } else {
        await this.ensureStorageFolder();
        await this.app.vault.create(translationPath, md);
        this.plugin.pdfToMdMap.set(pdfFile.path, translationPath);
      }
    };
    const pendingPromise = this.writingPromises.get(lockKey) || Promise.resolve();
    const newPromise = pendingPromise.then(() => writer()).finally(() => {
      if (this.writingPromises.get(lockKey) === newPromise) {
        this.writingPromises.delete(lockKey);
      }
    });
    this.writingPromises.set(lockKey, newPromise);
    await newPromise;
  }
  /**
   * Ensure an existing translation note's pdf-source wikilink points to the given PDF.
   * Repairs stale links after renames or moves. Keeps the original single-quoted wikilink format.
   */
  async ensurePdfSourceLinkPointsTo(fileMd, pdfFile) {
    const cache = this.app.metadataCache.getFileCache(fileMd);
    const fm = cache == null ? void 0 : cache.frontmatter;
    if (!fm)
      return;
    const raw = fm["pdf-source"];
    if (typeof raw !== "string")
      return;
    const singleQuoted = raw.match(/^'\[\[(.+?)\]\]'$/);
    const bare = !singleQuoted && raw.match(/^\[\[(.+?)\]\]$/);
    const linkRaw = singleQuoted ? singleQuoted[1] : bare ? bare[1] : raw.trim();
    const linkPath = linkRaw.split("|")[0].trim();
    const resolved = this.app.metadataCache.getFirstLinkpathDest(linkPath, fileMd.path);
    if (resolved && resolved.path === pdfFile.path) {
      return;
    }
    const newTarget = `[[${pdfFile.path}]]`;
    const content = await this.app.vault.read(fileMd);
    const updated = content.replace(
      /^---[\s\S]*?---/,
      (fmBlock) => {
        if (/^pdf-source:\s*/m.test(fmBlock)) {
          return fmBlock.replace(/^(pdf-source:\s*).*/m, `$1'[[${pdfFile.path}]]'`);
        } else {
          const parts = fmBlock.split("\n");
          parts.splice(1, 0, `pdf-source: '[[${pdfFile.path}]]'`);
          return parts.join("\n");
        }
      }
    );
    if (updated !== content) {
      await this.app.vault.modify(fileMd, updated);
    }
  }
};

// overlay.ts
var import_obsidian5 = require("obsidian");

// overlay-ui.ts
var import_obsidian4 = require("obsidian");

// modal-retranslate.ts
var import_obsidian3 = require("obsidian");
var RetranslateUsingOverlaysModal = class extends import_obsidian3.Modal {
  // show confirmation if overwriting non-empty items
  constructor(app, plugin, file) {
    super(app);
    this.onlyCurrentPage = true;
    this.fromPage = null;
    this.toPage = null;
    // Options
    this.onlyEmpty = false;
    // only translate items with empty translatedText
    this.confirmOverwrite = true;
    this.plugin = plugin;
    this.file = file;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Re-translate using saved overlay boxes" });
    let rangeSetting;
    new import_obsidian3.Setting(contentEl).setName("Scope").setDesc("Choose which pages to re-translate").addDropdown((dd) => {
      dd.addOption("current", "Current page only");
      dd.addOption("range", "Page range\u2026");
      dd.setValue("current");
      dd.onChange((val) => {
        this.onlyCurrentPage = val === "current";
        if (rangeSetting) {
          rangeSetting.settingEl.toggleClass("is-hidden", this.onlyCurrentPage);
        }
      });
    });
    rangeSetting = new import_obsidian3.Setting(contentEl).setName("Page range").setDesc("Inclusive page range (1-based indices)").addText((txt) => {
      txt.setPlaceholder("From").onChange((val) => {
        const n = parseInt(val, 10);
        this.fromPage = Number.isFinite(n) && n > 0 ? n : null;
      });
    }).addText((txt) => {
      txt.setPlaceholder("To").onChange((val) => {
        const n = parseInt(val, 10);
        this.toPage = Number.isFinite(n) && n > 0 ? n : null;
      });
    });
    rangeSetting.settingEl.addClass("is-hidden");
    new import_obsidian3.Setting(contentEl).setName("Only re-translate empty items").setDesc("If enabled, only items with no translated text will be translated.").addToggle((tg) => {
      tg.setValue(this.onlyEmpty).onChange((v) => this.onlyEmpty = v);
    });
    new import_obsidian3.Setting(contentEl).setName("Ask before overwriting non-empty items").setDesc("When unchecked, existing translations will be overwritten without confirmation.").addToggle((tg) => {
      tg.setValue(this.confirmOverwrite).onChange((v) => this.confirmOverwrite = v);
    });
    new import_obsidian3.Setting(contentEl).addButton((btn) => {
      btn.setButtonText("Start").setCta().onClick(async () => {
        try {
          await this.runRetranslation();
          this.close();
        } catch (e) {
          console.error(e);
          new import_obsidian3.Notice(`Retranslation failed: ${(e == null ? void 0 : e.message) || "Unknown error"}`);
        }
      });
    }).addButton((btn) => {
      btn.setButtonText("Cancel").onClick(() => this.close());
    });
    const style = document.createElement("style");
    style.textContent = `
      .is-hidden { display: none !important; }
      .modal .setting-item.is-hidden { display: none !important; }
    `;
    contentEl.appendChild(style);
  }
  onClose() {
    this.contentEl.empty();
  }
  async runRetranslation() {
    const currentPage = this.plugin.getCurrentPageNumber();
    if (currentPage == null) {
      new import_obsidian3.Notice("No active page detected.");
      return;
    }
    const translationFile = await this.plugin.storage.findTranslationFileForPdf(this.file);
    if (!translationFile) {
      new import_obsidian3.Notice("No translation file found for this PDF.");
      return;
    }
    const md = await this.app.vault.read(translationFile);
    const saved = this.plugin.storage.parseMarkdownOverlay(md, this.file);
    if (!saved) {
      new import_obsidian3.Notice("No saved overlays found.");
      return;
    }
    const targetPages = this.onlyCurrentPage ? [currentPage] : this.buildPageRange();
    if (targetPages.length === 0) {
      new import_obsidian3.Notice("Invalid or empty page range.");
      return;
    }
    const jobs = [];
    for (const p of targetPages) {
      const key = String(p);
      const items = (saved.pageOverlays[key] || []).filter((it) => (it.textContent || "").trim().length > 0);
      if (this.onlyEmpty) {
        const filtered = items.filter((it) => !it.translatedText || !it.translatedText.trim());
        if (filtered.length > 0) {
          jobs.push({ page: p, items: filtered });
        }
      } else {
        if (items.length > 0) {
          jobs.push({ page: p, items });
        }
      }
    }
    if (jobs.length === 0) {
      new import_obsidian3.Notice("No matching overlay items found for the selected scope.");
      return;
    }
    if (!this.onlyEmpty && this.confirmOverwrite) {
      const willOverwrite = jobs.some((j) => j.items.some((i) => (i.translatedText || "").trim().length > 0));
      if (willOverwrite) {
        const proceed = await this.confirm(
          "Overwrite existing translations?",
          "Some items already have translated text. Do you want to overwrite them?"
        );
        if (!proceed)
          return;
      }
    }
    let totalItems = jobs.reduce((acc, j) => acc + j.items.length, 0);
    new import_obsidian3.Notice(`Re-translating ${totalItems} item(s) across ${jobs.length} page(s)...`, 3e3);
    for (const job of jobs) {
      const texts = job.items.map((i) => i.textContent || "");
      let translated = [];
      try {
        if (this.plugin.settings.useBatchTranslation && texts.length > 1) {
          const numbered = texts.map((t, idx) => `${idx + 1}. ${t}`).join("\n");
          const maxChars = this.plugin.settings.maxBatchChars;
          const payload = numbered.length > maxChars ? numbered.slice(0, maxChars) : numbered;
          const raw = await this.plugin.translation.translateBatch(payload, texts.length);
          translated = this.plugin.processor.extractNumberedLines(raw, texts.length);
        } else {
          translated = [];
          for (const t of texts) {
            try {
              const out = await this.plugin.translation.translateWithOpenRouter(t);
              translated.push(out);
            } catch (e) {
              console.error("Sequential translate failed:", e);
              translated.push(t);
            }
          }
        }
      } catch (e) {
        console.error("Retranslation error on page", job.page, e);
        translated = texts.slice();
      }
      job.items.forEach((item, i) => {
        item.translatedText = translated[i] || item.textContent || "";
      });
      saved.pageOverlays[String(job.page)] = job.items;
    }
    saved.timestamp = Date.now();
    const newMd = this.plugin.storage.generateMarkdownForOverlay(saved, this.file);
    await this.app.vault.modify(translationFile, newMd);
    const pageToRefresh = this.onlyCurrentPage ? currentPage : this.plugin.getCurrentPageNumber();
    if (pageToRefresh != null) {
      await this.refreshPageOverlayFromSaved(saved, pageToRefresh);
    }
    new import_obsidian3.Notice("\u2705 Re-translation complete.");
  }
  buildPageRange() {
    const out = [];
    if (this.fromPage == null || this.toPage == null)
      return out;
    if (this.toPage < this.fromPage)
      return out;
    for (let p = this.fromPage; p <= this.toPage; p++)
      out.push(p);
    return out;
  }
  async refreshPageOverlayFromSaved(saved, pageNumber) {
    var _a;
    try {
      const pageData = saved.pageOverlays[String(pageNumber)];
      if (!Array.isArray(pageData) || pageData.length === 0)
        return;
      const textLayer = await this.plugin.overlay.waitForPdfTextLayer(pageNumber);
      if (!textLayer)
        return;
      const pageEl = this.getPageElementByNumber(pageNumber);
      (_a = pageEl == null ? void 0 : pageEl.querySelectorAll(".pdf-text-overlay-container")) == null ? void 0 : _a.forEach((el) => el.remove());
      this.plugin.overlay.renderSavedOverlay(pageData, pageNumber);
    } catch (e) {
      console.error("Failed to refresh overlay for page", pageNumber, e);
    }
  }
  // Use overlay helper if present; otherwise use a local query
  getPageElementByNumber(pageNumber) {
    const anyOverlay = this.plugin.overlay;
    if (typeof anyOverlay.getPageElementByNumber === "function") {
      return anyOverlay.getPageElementByNumber(pageNumber);
    }
    const viewer = document.querySelector(".pdfViewer, #viewer");
    if (!viewer)
      return null;
    return viewer.querySelector(`.page[data-page-number="${pageNumber}"]`);
  }
  async confirm(title, message) {
    return new Promise((resolve) => {
      const dlg = new import_obsidian3.Modal(this.app);
      dlg.contentEl.createEl("h3", { text: title });
      dlg.contentEl.createEl("p", { text: message });
      new import_obsidian3.Setting(dlg.contentEl).addButton((btn) => {
        btn.setButtonText("Cancel").onClick(() => {
          dlg.close();
          resolve(false);
        });
      }).addButton((btn) => {
        btn.setCta();
        btn.setButtonText("Overwrite").onClick(() => {
          dlg.close();
          resolve(true);
        });
      });
      dlg.onClose = () => dlg.contentEl.empty();
      dlg.open();
    });
  }
};

// overlay-ui.ts
var LINE_HEIGHT_MIN = 0.8;
var LINE_HEIGHT_MAX = 2;
var LINE_HEIGHT_STEP = 0.1;
var OverlayUIRenderer = class {
  // For efficient HTML to text conversion
  constructor(plugin) {
    // State and caches for UI elements
    this.createdOverlays = /* @__PURE__ */ new WeakMap();
    this.trackedOverlayElements = /* @__PURE__ */ new Set();
    this.tempDiv = null;
    this.plugin = plugin;
  }
  // ============================================================
  // Public API for OverlayRenderer (or other managers)
  // ============================================================
  /**
   * Creates the DOM element for an overlay but does NOT
   * do expensive measuring/adjustments (that's handled separately or by manager).
   */
  createReflowOverlay(rect, htmlText, referenceSpan, originalFontSizes, pageNumber, originalTextContent, overlayOpacity, outputFontSizeScale, outputLineHeight, lastKnownScale, fontFamily) {
    if (!rect || rect.width <= 0 || rect.height <= 0) {
      console.debug("[OverlayUIRenderer] createReflowOverlay: Invalid rect");
      return document.createElement("div");
    }
    const el = document.createElement("div");
    el.className = "pdf-text-overlay-reflow";
    const avgOriginalFontSize = originalFontSizes.length > 0 ? originalFontSizes.reduce((a, b) => a + b, 0) / originalFontSizes.length : parseFloat(window.getComputedStyle(referenceSpan).fontSize) || 12;
    const baseFontSize = avgOriginalFontSize * outputFontSizeScale;
    const currentFontSize = baseFontSize * lastKnownScale;
    Object.assign(el.style, {
      position: "absolute",
      left: `${rect.left}px`,
      top: `${rect.top}px`,
      width: `${rect.width}px`,
      height: `${rect.height}px`,
      fontSize: `${currentFontSize}px`,
      overflow: "auto",
      boxSizing: "border-box",
      zIndex: "101"
    });
    el.style.setProperty("--overlay-opacity", `${overlayOpacity}`);
    this.setOverlayElementVisibility(el, true);
    if (fontFamily) {
      el.style.fontFamily = fontFamily;
    }
    const inner = document.createElement("div");
    Object.assign(inner.style, {
      whiteSpace: "pre-wrap",
      wordBreak: "break-word",
      width: "100%",
      height: "100%"
    });
    inner.innerHTML = (htmlText || "").trim() || "\u2026";
    el.appendChild(inner);
    this.applyLineHeight(inner, outputLineHeight);
    el.setAttribute("data-original-text", originalTextContent);
    if (originalFontSizes.length > 0) {
      el.setAttribute("data-original-font-sizes", JSON.stringify(originalFontSizes));
    }
    const contextHandler = (event) => {
      try {
        this.showContextMenu(event, inner.textContent || "", el);
      } catch (error) {
        console.debug("[OverlayUIRenderer] contextHandler error:", error);
      }
    };
    const bringToTopHandler = () => this.bringToTop(el);
    const resetZIndexHandler = () => {
      el.style.zIndex = "101";
    };
    el.addEventListener("contextmenu", contextHandler);
    el.addEventListener("mouseover", bringToTopHandler);
    el.addEventListener("mouseleave", resetZIndexHandler);
    this.createdOverlays.set(el, {
      contextHandler,
      bringToTopHandler,
      resetZIndexHandler
    });
    this.trackedOverlayElements.add(el);
    return el;
  }
  /**
   * Adjusts overlay's line height first to fit, then font size only as last resort.
   * Ensures minimum font size doesn't go below what would naturally fit the bounding box.
   */
  adjustOverlayForOverflow(el, outputLineHeight) {
    const inner = el.querySelector("div");
    if (!inner)
      return;
    const isOverflowing = inner.scrollHeight > el.clientHeight || inner.scrollWidth > el.clientWidth;
    if (!isOverflowing) {
      el.style.overflow = "auto";
      return;
    }
    const intendedFontSize = parseFloat(el.style.fontSize);
    const intendedLineHeight = outputLineHeight;
    const minReasonableFontSize = Math.max(8, Math.min(
      el.clientHeight * 0.3,
      el.clientWidth * 0.05
    ));
    const minFontSizeFromIntention = intendedFontSize * 0.5;
    const absoluteMinimumFontSize = Math.max(minReasonableFontSize, minFontSizeFromIntention);
    let currentLineHeight = intendedLineHeight;
    let attempts = 0;
    while (currentLineHeight > 0.8 && attempts < 20) {
      currentLineHeight -= 0.03;
      this.applyLineHeight(inner, currentLineHeight);
      if (inner.scrollHeight <= el.clientHeight && inner.scrollWidth <= el.clientWidth) {
        return;
      }
      attempts++;
    }
    let testFontSize = intendedFontSize;
    attempts = 0;
    while (testFontSize > absoluteMinimumFontSize && attempts < 15) {
      el.style.fontSize = `${testFontSize}px`;
      if (inner.scrollHeight <= el.clientHeight && inner.scrollWidth <= el.clientWidth) {
        return;
      }
      testFontSize *= 0.96;
      attempts++;
    }
    if (absoluteMinimumFontSize <= intendedFontSize) {
      el.style.fontSize = `${absoluteMinimumFontSize}px`;
      if (inner.scrollHeight <= el.clientHeight && inner.scrollWidth <= el.clientWidth) {
        return;
      }
    }
    el.style.overflow = "auto";
    console.debug("[OverlayUIRenderer] Could not fit content with minimum font size, enabled scrollbar");
  }
  /**
   * Adjusts the line height for a single, specific overlay element.
   */
  adjustSingleOverlayLineHeight(overlayEl, delta) {
    const inner = overlayEl.querySelector("div");
    if (!inner)
      return;
    try {
      const currentLineHeight = parseFloat(inner.style.lineHeight) || this.plugin.settings.outputLineHeight || 1.2;
      let newValue = currentLineHeight + delta;
      newValue = Math.max(LINE_HEIGHT_MIN, Math.min(LINE_HEIGHT_MAX, newValue));
      newValue = Math.round(newValue * 10) / 10;
      this.applyLineHeight(inner, newValue);
      console.debug(`[OverlayUIRenderer] Line height for a single overlay adjusted to ${newValue}`);
    } catch (error) {
      console.debug("[OverlayUIRenderer] adjustSingleOverlayLineHeight failed:", error);
    }
  }
  /**
   * Adjusts the font size for a single, specific overlay element.
   */
  adjustSingleOverlayFontSize(overlayEl, scaleFactor) {
    if (!overlayEl)
      return;
    try {
      const currentSize = parseFloat(overlayEl.style.fontSize);
      if (isNaN(currentSize)) {
        console.debug("[OverlayUIRenderer] Could not parse current font size for adjustment.");
        return;
      }
      const FONT_SIZE_MIN_PX = 6;
      const FONT_SIZE_MAX_PX = 72;
      let newSize = currentSize * scaleFactor;
      newSize = Math.max(FONT_SIZE_MIN_PX, Math.min(FONT_SIZE_MAX_PX, newSize));
      overlayEl.style.fontSize = `${newSize}px`;
      console.debug(`[OverlayUIRenderer] Font size for a single overlay adjusted to ${newSize}px`);
    } catch (error) {
      console.debug("[OverlayUIRenderer] adjustSingleOverlayFontSize failed:", error);
    }
  }
  applyLineHeight(inner, value) {
    var _a;
    const lineHeightStr = `${value}`;
    inner.style.lineHeight = lineHeightStr;
    (_a = inner.parentElement) == null ? void 0 : _a.style.setProperty("--overlay-line-height", lineHeightStr);
  }
  setOverlayElementVisibility(el, isVisible) {
    if (isVisible) {
      el.style.opacity = el.style.getPropertyValue("--overlay-opacity") || `${this.plugin.settings.overlayOpacity}`;
      el.style.pointerEvents = "auto";
      el.style.visibility = "visible";
    } else {
      el.style.opacity = "0";
      el.style.pointerEvents = "none";
      el.style.visibility = "hidden";
    }
  }
  bringToTop(el) {
    const overlays = document.querySelectorAll(".pdf-text-overlay-reflow");
    let maxZIndex = 100;
    overlays.forEach((overlay) => {
      const zIndex = parseInt(window.getComputedStyle(overlay).zIndex, 10);
      if (!isNaN(zIndex) && zIndex > maxZIndex) {
        maxZIndex = zIndex;
      }
    });
    el.style.zIndex = `${maxZIndex + 1}`;
  }
  // ============================================================
  // Context Menu
  // ============================================================
  showContextMenu(event, textToCopy, targetOverlay) {
    var _a;
    const me = event;
    me.preventDefault();
    me.stopPropagation();
    if (!targetOverlay)
      return;
    const activeLeaf = this.plugin.app.workspace.activeLeaf;
    const activeFile = (_a = activeLeaf == null ? void 0 : activeLeaf.view) == null ? void 0 : _a.file;
    const pageNumber = this.plugin.getCurrentPageNumber();
    const menu = new import_obsidian4.Menu();
    const addItem = (title, icon, onClick) => menu.addItem((item) => item.setTitle(title).setIcon(icon).onClick(onClick));
    addItem("Copy Translation", "copy", async () => {
      try {
        await navigator.clipboard.writeText(textToCopy);
        new import_obsidian4.Notice("Translation copied.");
      } catch (e) {
        new import_obsidian4.Notice("Failed to copy translation.");
      }
    });
    const copyFormattedText = async (format, title) => {
      if (!activeFile || pageNumber === null) {
        new import_obsidian4.Notice(`Cannot copy as ${title}: PDF file or page number is not available.`);
        return;
      }
      try {
        const pageLink = `[[${activeFile.path}#page=${pageNumber}]]`;
        const blockquoteText = textToCopy.split("\n").map((line) => `> ${line}`).join("\n");
        const formattedText = format.replace(/{blockquote_text}/g, blockquoteText).replace(/{text}/g, textToCopy).replace(/{filename}/g, activeFile.name).replace(/{pagelink}/g, pageLink).replace(/{pagenumber}/g, String(pageNumber));
        await navigator.clipboard.writeText(formattedText);
        new import_obsidian4.Notice(`Copied as ${title}.`);
      } catch (error) {
        console.error(`Failed to copy translation as ${title}:`, error);
        new import_obsidian4.Notice(`Failed to copy as ${title}.`);
      }
    };
    addItem(
      "Copy as Callout",
      "",
      () => copyFormattedText(this.plugin.settings.calloutFormat, "callout")
    );
    addItem(
      "Copy as Citation",
      "",
      () => copyFormattedText(this.plugin.settings.citationFormat, "citation")
    );
    addItem(
      "Copy as Footnote",
      "",
      () => copyFormattedText(this.plugin.settings.footnoteFormat, "footnote")
    );
    menu.addSeparator();
    addItem("Retranslate Page...", "refresh-cw", () => {
      if (!activeFile)
        return;
      new RetranslateUsingOverlaysModal(this.plugin.app, this.plugin, activeFile).open();
    });
    addItem("Force Refresh Overlays", "refresh-ccw", () => {
      var _a2, _b;
      if (typeof ((_a2 = this.plugin.renderer) != null ? _a2 : this.plugin).forceRefreshVisibleOverlays === "function") {
        ((_b = this.plugin.renderer) != null ? _b : this.plugin).forceRefreshVisibleOverlays();
      } else {
        new import_obsidian4.Notice("Refresh function not available");
      }
    });
    menu.addSeparator();
    addItem("Increase Text Size", "zoom-in", () => this.adjustSingleOverlayFontSize(targetOverlay, 1.1));
    addItem("Decrease Text Size", "zoom-out", () => this.adjustSingleOverlayFontSize(targetOverlay, 1 / 1.1));
    addItem("Increase Line Height", "plus", () => this.adjustSingleOverlayLineHeight(targetOverlay, LINE_HEIGHT_STEP));
    addItem("Decrease Line Height", "minus", () => this.adjustSingleOverlayLineHeight(targetOverlay, -LINE_HEIGHT_STEP));
    menu.addSeparator();
    addItem("Go to Translation File", "file-text", () => {
      try {
        if (!activeFile || activeFile.extension !== "pdf" || pageNumber === null) {
          new import_obsidian4.Notice("No PDF or page available.");
          return;
        }
        const translationFileName = `${activeFile.basename}.translations`;
        const wikiLink = `${translationFileName}#Page ${pageNumber}`;
        this.plugin.app.workspace.openLinkText(wikiLink, "", false);
        new import_obsidian4.Notice(`Opened translation for page ${pageNumber}`);
        console.debug(`[OverlayUIRenderer] Opened translation link: ${wikiLink}`);
      } catch (error) {
        console.debug("[OverlayUIRenderer] Go to translation file error:", error);
        new import_obsidian4.Notice("Error opening translation file.");
      }
    });
    menu.showAtPosition({ x: me.clientX, y: me.clientY });
  }
  // ============================================================
  // Cleanup
  // ============================================================
  cleanupHoverHandlers(el) {
    var _a;
    const handlers = (_a = this.createdOverlays.get(el)) == null ? void 0 : _a.hoverHandlers;
    if (handlers) {
      el.removeEventListener("mouseenter", handlers.show);
      el.removeEventListener("mouseleave", handlers.hide);
      const allHandlers = this.createdOverlays.get(el);
      delete allHandlers.hoverHandlers;
      this.createdOverlays.set(el, allHandlers);
    }
  }
  cleanupOverlayElement(el) {
    this.cleanupHoverHandlers(el);
    const handlers = this.createdOverlays.get(el);
    if (handlers) {
      el.removeEventListener("contextmenu", handlers.contextHandler);
      if (handlers.bringToTopHandler) {
        el.removeEventListener("mouseover", handlers.bringToTopHandler);
      }
      if (handlers.resetZIndexHandler) {
        el.removeEventListener("mouseleave", handlers.resetZIndexHandler);
      }
      this.createdOverlays.delete(el);
    }
    this.trackedOverlayElements.delete(el);
    el.remove();
  }
  cleanup() {
    this.trackedOverlayElements.forEach((el) => this.cleanupOverlayElement(el));
    this.trackedOverlayElements.clear();
    this.createdOverlays = /* @__PURE__ */ new WeakMap();
    this.tempDiv = null;
  }
  // Helper for text extraction (if needed here)
  extractPlainTextFromHtml(html) {
    if (!this.tempDiv)
      this.tempDiv = document.createElement("div");
    this.tempDiv.innerHTML = html;
    return this.tempDiv.textContent || this.tempDiv.innerText || "";
  }
};

// overlay.ts
var OVERLAY_WAIT_TIMEOUT = 5e3;
var OVERLAY_CHECK_INTERVAL = 100;
var RETRY_DELAY = 50;
var MAX_DIMENSION_RETRIES = 50;
var EXTRACT_RETRY_INTERVAL = 100;
var EXTRACT_MAX_RETRIES = 20;
var DEBOUNCE_DELAY = 50;
var CACHE_TTL = 100;
var ZOOM_REPOSITION_DEBOUNCE = 200;
var ZOOM_DIM_STABLE_WAIT = 300;
var SCROLL_THROTTLE_DELAY = 150;
var QUICK_CHECK_MIN_INTERVAL = 100;
var OverlayRenderer = class {
  constructor(plugin) {
    this.pageObserver = null;
    this.zoomObserver = null;
    this.lastKnownScale = 1;
    // Note: createdOverlays and trackedOverlayElements are now managed by uiRenderer
    this.isReloadingOverlay = false;
    this.activeLeavesCache = null;
    this.memoCache = /* @__PURE__ */ new Map();
    // Note: tempDiv is now managed by uiRenderer
    this.zoomDebounceTimeout = null;
    this.inFlightPageLoads = /* @__PURE__ */ new Map();
    // Gradual loading properties
    this.cachedOverlayData = null;
    this.pagesWithOverlays = /* @__PURE__ */ new Set();
    this.pageIntersectionObserver = null;
    // Enhanced scroll safeguard properties
    this.scrollThrottleTimeout = null;
    this.scrollHandler = null;
    this.scrollableContainer = null;
    this.loadedOverlayPages = /* @__PURE__ */ new Set();
    this.lastScrollCheck = 0;
    this.isScrollSafeguardRunning = false;
    this.lastQuickCheck = 0;
    var _a;
    this.plugin = plugin;
    this.uiRenderer = new OverlayUIRenderer(plugin);
    this.isOverlayVisible = (_a = plugin.settings.showOverlayByDefault) != null ? _a : true;
    if (typeof this.plugin.settings.outputLineHeight !== "number") {
      this.plugin.settings.outputLineHeight = 1.2;
    }
  }
  // ============================================================
  // Public API for TextProcessor
  // ============================================================
  preparePageForOverlay(pageElement) {
    if (!pageElement) {
      this.logDebug("preparePageForOverlay: Page element is null");
      throw new Error("Page element is required");
    }
    this.clearOverlayFromPage(pageElement);
    return this.createOverlayContainer(pageElement);
  }
  renderOverlays(units, translatedLines, container, pageElement) {
    if (!(units == null ? void 0 : units.length) || !(translatedLines == null ? void 0 : translatedLines.length)) {
      this.logDebug("renderOverlays: No units or translated lines provided");
      return;
    }
    const textMemo = /* @__PURE__ */ new Map();
    try {
      const pageNumber = parseInt(pageElement.dataset.pageNumber || "0");
      units.forEach((unit, i) => {
        try {
          const translatedText = translatedLines[i] || unit.text;
          if (!translatedText.trim())
            return;
          const { rect, fontSizes, fontFamily } = this.plugin.processor.getSpansBbox(unit.originalSpans, pageElement);
          if (!rect)
            return;
          const originalPlainText = textMemo.get(unit.text) || this.uiRenderer.extractPlainTextFromHtml(unit.text);
          textMemo.set(unit.text, originalPlainText);
          const overlayEl = this.uiRenderer.createReflowOverlay(
            rect,
            translatedText,
            unit.originalSpans[0],
            fontSizes,
            pageNumber,
            originalPlainText,
            this.plugin.settings.overlayOpacity,
            this.plugin.settings.outputFontSizeScale,
            this.plugin.settings.outputLineHeight,
            this.lastKnownScale,
            fontFamily
          );
          container.appendChild(overlayEl);
        } catch (unitError) {
          this.logDebug(`Error rendering unit ${i}:`, unitError);
        }
      });
      this.loadedOverlayPages.add(pageNumber);
      this.logDebug(`Rendered ${units.length} overlay(s) for page ${pageNumber}`);
    } catch (error) {
      this.logDebug("renderOverlays failed:", error);
    }
  }
  async refreshCurrentOverlay() {
    try {
      if (!this.getCurrentPageElement()) {
        new import_obsidian5.Notice("No active PDF page found to refresh.");
        return;
      }
      new import_obsidian5.Notice("Refreshing overlay...");
      await this.plugin.processor.addTextOverlay();
    } catch (error) {
      this.logDebug("Error refreshing overlay:", error);
      new import_obsidian5.Notice("Failed to refresh overlay");
    }
  }
  adjustLineHeight(delta) {
    try {
      let newValue = (this.plugin.settings.outputLineHeight || 1.2) + delta;
      const MIN = 0.8;
      const MAX = 2;
      newValue = Math.max(MIN, Math.min(MAX, newValue));
      newValue = Math.round(newValue * 10) / 10;
      this.plugin.settings.outputLineHeight = newValue;
      document.querySelectorAll(".pdf-text-overlay-reflow div").forEach((inner) => {
        this.uiRenderer.applyLineHeight(inner, newValue);
      });
      this.plugin.saveSettings();
      new import_obsidian5.Notice(`Line height set to ${newValue}`);
      this.logDebug(`Line height adjusted to ${newValue}`);
    } catch (error) {
      this.logDebug("adjustLineHeight failed:", error);
      new import_obsidian5.Notice("Failed to adjust line height");
    }
  }
  /**
   * Force refresh all visible overlays - useful for troubleshooting
   */
  async forceRefreshVisibleOverlays() {
    try {
      const activeLeaf = this.getActivePDFLeaf();
      if (!activeLeaf) {
        new import_obsidian5.Notice("No active PDF found");
        return;
      }
      const pages = this.getPDFPagesForLeaf(activeLeaf);
      if (!pages)
        return;
      this.logDebug("Starting force refresh of visible overlays");
      const viewportHeight = window.innerHeight;
      let refreshCount = 0;
      for (const pageElement of Array.from(pages)) {
        const rect = pageElement.getBoundingClientRect();
        if (rect.bottom <= 0 || rect.top >= viewportHeight)
          continue;
        const pageNumberStr = pageElement.dataset.pageNumber;
        if (pageNumberStr) {
          const pageNumber = parseInt(pageNumberStr, 10);
          if (this.pagesWithOverlays.has(pageNumber)) {
            this.clearOverlayFromPage(pageElement);
            this.loadedOverlayPages.delete(pageNumber);
            await this.loadSavedOverlayForPage(pageNumber, true);
            refreshCount++;
          }
        }
      }
      new import_obsidian5.Notice(`Refreshed ${refreshCount} overlay(s)`);
      this.logDebug(`Force refreshed ${refreshCount} overlays`);
    } catch (error) {
      this.logDebug("forceRefreshVisibleOverlays error:", error);
      new import_obsidian5.Notice("Error refreshing overlays");
    }
  }
  // Note: applyLineHeight is now handled by uiRenderer and is private there
  // ============================================================
  // Internal DOM Management & Utilities
  // ============================================================
  createOverlayContainer(pageElement) {
    const container = document.createElement("div");
    container.className = "pdf-text-overlay-container";
    container.style.cssText = `position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; overflow: hidden;`;
    pageElement.appendChild(container);
    return container;
  }
  clearOverlayFromPage(pageElement) {
    const existingContainer = pageElement.querySelector(".pdf-text-overlay-container");
    if (existingContainer) {
      existingContainer.querySelectorAll(".pdf-text-overlay-reflow").forEach((overlay) => {
        this.uiRenderer.cleanupOverlayElement(overlay);
      });
      existingContainer.remove();
    }
    const pageNumberStr = pageElement.dataset.pageNumber;
    if (pageNumberStr) {
      const pageNumber = parseInt(pageNumberStr, 10);
      this.loadedOverlayPages.delete(pageNumber);
    }
  }
  // Note: extractPlainTextFromHtml is now handled by uiRenderer and is private there
  // If needed locally, it can be kept here or delegated via uiRenderer.
  // ============================================================
  // Setup & Monitoring (ENHANCED with better performance)
  // ============================================================
  async setupPDFMonitoring(leaf) {
    var _a;
    if (!((_a = leaf == null ? void 0 : leaf.view) == null ? void 0 : _a.file) || leaf.view.getViewType() !== "pdf") {
      this.logDebug("setupPDFMonitoring: Invalid leaf or not a PDF view.");
      return;
    }
    this.cleanupMonitoring();
    await this.initializeOverlayStateForPdf(leaf.view.file);
    if (this.pagesWithOverlays.size === 0) {
      this.logDebug("No saved overlays found for this PDF. No monitoring will be started.");
      return;
    }
    let attempts = 0;
    const maxAttempts = 50;
    const checkViewer = () => {
      attempts++;
      const viewerContainer = leaf.view.containerEl.querySelector(".pdfViewer, #viewer");
      if (viewerContainer) {
        this.logDebug(`PDF viewer found. Monitoring for ${this.pagesWithOverlays.size} pages with saved translations.`);
        this.monitorScrolling(viewerContainer);
        this.setupIntersectionObserver();
        this.monitorPageContainer(viewerContainer);
        this.monitorZoom(viewerContainer);
      } else if (attempts < maxAttempts) {
        setTimeout(checkViewer, 100);
      } else {
        this.logDebug("PDF viewer not found after maximum attempts");
      }
    };
    checkViewer();
  }
  async initializeOverlayStateForPdf(pdfFile) {
    this.cachedOverlayData = null;
    this.pagesWithOverlays.clear();
    this.loadedOverlayPages.clear();
    const translationFile = await this.plugin.storage.findTranslationFileForPdf(pdfFile);
    if (!translationFile) {
      return;
    }
    try {
      const content = await this.plugin.app.vault.read(translationFile);
      const parsedOverlay = this.plugin.storage.parseMarkdownOverlay(content, pdfFile);
      if (parsedOverlay && parsedOverlay.pageOverlays) {
        this.cachedOverlayData = parsedOverlay;
        const pageNumbers = Object.keys(parsedOverlay.pageOverlays).map(Number).filter((n) => !isNaN(n) && n > 0);
        this.pagesWithOverlays = new Set(pageNumbers);
        this.logDebug(`Initialized overlay data for ${pageNumbers.length} pages: ${pageNumbers.join(", ")}`);
      }
    } catch (error) {
      console.error("PDF Translator: Failed to read or parse translation file.", error);
    }
  }
  setupIntersectionObserver() {
    var _a;
    (_a = this.pageIntersectionObserver) == null ? void 0 : _a.disconnect();
    let root = null;
    if (this.scrollableContainer) {
      root = this.scrollableContainer;
    }
    const options = {
      root,
      rootMargin: "400px",
      // Reduced from 800px for better performance
      threshold: [0, 0.1, 0.3]
      // Multiple thresholds for better detection
    };
    this.pageIntersectionObserver = new IntersectionObserver((entries) => {
      for (const entry of entries) {
        if (entry.isIntersecting && entry.intersectionRatio > 0) {
          const pageElement = entry.target;
          const pageNumberStr = pageElement.dataset.pageNumber;
          if (pageNumberStr) {
            const pageNumber = parseInt(pageNumberStr, 10);
            if (this.pagesWithOverlays.has(pageNumber)) {
              this.ensurePageOverlayLoaded(pageNumber, pageElement).catch(
                (err) => this.logDebug(`IO load error page ${pageNumber}`, err)
              );
            }
          }
        }
      }
    }, options);
    this.observeExistingPages();
  }
  observeExistingPages() {
    const activeLeaf = this.getActivePDFLeaf();
    if (!activeLeaf)
      return;
    const pages = this.getPDFPagesForLeaf(activeLeaf);
    if (!pages)
      return;
    let observedCount = 0;
    pages.forEach((page) => {
      var _a;
      const pageNumberStr = page.dataset.pageNumber;
      if (pageNumberStr) {
        const pageNumber = parseInt(pageNumberStr, 10);
        if (this.pagesWithOverlays.has(pageNumber)) {
          (_a = this.pageIntersectionObserver) == null ? void 0 : _a.observe(page);
          observedCount++;
        }
      }
    });
    this.logDebug(`Started observing ${observedCount} pages with overlays`);
  }
  monitorPageContainer(pdfViewer) {
    var _a;
    (_a = this.pageObserver) == null ? void 0 : _a.disconnect();
    const handleMutations = (mutations) => {
      let newPagesAdded = 0;
      for (const mutation of mutations) {
        if (mutation.type === "childList") {
          mutation.addedNodes.forEach((node) => {
            var _a2;
            if (node instanceof HTMLElement && node.classList.contains("page")) {
              const pageNumberStr = node.dataset.pageNumber;
              if (pageNumberStr) {
                const pageNumber = parseInt(pageNumberStr, 10);
                if (this.pagesWithOverlays.has(pageNumber)) {
                  (_a2 = this.pageIntersectionObserver) == null ? void 0 : _a2.observe(node);
                  newPagesAdded++;
                }
              }
            }
          });
          mutation.removedNodes.forEach((node) => {
            var _a2;
            if (node instanceof HTMLElement && node.classList.contains("page")) {
              (_a2 = this.pageIntersectionObserver) == null ? void 0 : _a2.unobserve(node);
              const pageNumberStr = node.dataset.pageNumber;
              if (pageNumberStr) {
                const pageNumber = parseInt(pageNumberStr, 10);
                this.loadedOverlayPages.delete(pageNumber);
              }
            }
          });
        }
      }
      if (newPagesAdded > 0) {
        this.logDebug(`Started observing ${newPagesAdded} new pages`);
      }
    };
    this.pageObserver = new MutationObserver(handleMutations);
    this.pageObserver.observe(pdfViewer, { childList: true, subtree: true });
  }
  monitorZoom(pdfViewer) {
    var _a;
    (_a = this.zoomObserver) == null ? void 0 : _a.disconnect();
    const handleZoomChange = () => {
      const scaleFactorStr = pdfViewer.style.getPropertyValue("--scale-factor");
      if (!scaleFactorStr)
        return;
      const newScale = parseFloat(scaleFactorStr);
      if (!isNaN(newScale) && Math.abs(newScale - this.lastKnownScale) > 1e-3) {
        this.logDebug(`Zoom changed from ${this.lastKnownScale} to ${newScale}. Triggering overlay update.`);
        this.lastKnownScale = newScale;
        if (this.zoomDebounceTimeout) {
          clearTimeout(this.zoomDebounceTimeout);
        }
        this.zoomDebounceTimeout = setTimeout(() => {
          this.rerenderVisibleOverlays();
        }, ZOOM_REPOSITION_DEBOUNCE);
        this.memoCache.clear();
      }
    };
    this.zoomObserver = new MutationObserver(handleZoomChange);
    this.zoomObserver.observe(pdfViewer, { attributes: true, attributeFilter: ["style"] });
    const initialScaleStr = pdfViewer.style.getPropertyValue("--scale-factor");
    if (initialScaleStr)
      this.lastKnownScale = parseFloat(initialScaleStr) || 1;
  }
  monitorScrolling(pdfViewer) {
    if (this.scrollableContainer && this.scrollHandler) {
      this.scrollableContainer.removeEventListener("scroll", this.scrollHandler);
    }
    this.scrollableContainer = pdfViewer.closest(".mod-vertical") || pdfViewer.closest(".workspace-leaf-content") || pdfViewer.parentElement || pdfViewer;
    this.logDebug(`Scroll container detected: ${this.scrollableContainer.className || "no class"}`);
    this.scrollHandler = () => {
      const now = Date.now();
      if (now - this.lastQuickCheck > QUICK_CHECK_MIN_INTERVAL) {
        this.lastQuickCheck = now;
        this.quickVisibilityCheck();
      }
      if (this.scrollThrottleTimeout) {
        clearTimeout(this.scrollThrottleTimeout);
      }
      this.scrollThrottleTimeout = setTimeout(() => {
        if (now - this.lastScrollCheck > QUICK_CHECK_MIN_INTERVAL) {
          this.lastScrollCheck = now;
          this.comprehensiveOverlayCheck();
        }
      }, SCROLL_THROTTLE_DELAY);
    };
    this.scrollableContainer.addEventListener("scroll", this.scrollHandler, { passive: true });
  }
  // Light check that runs immediately on scroll
  quickVisibilityCheck() {
    if (this.isScrollSafeguardRunning)
      return;
    try {
      const activeLeaf = this.getActivePDFLeaf();
      if (!activeLeaf)
        return;
      const pages = this.getPDFPagesForLeaf(activeLeaf);
      if (!pages)
        return;
      const viewportHeight = window.innerHeight;
      const viewportCenter = viewportHeight / 2;
      let centralPage = null;
      let minDistanceToCenter = Infinity;
      for (const pageElement of Array.from(pages)) {
        const rect = pageElement.getBoundingClientRect();
        if (rect.bottom <= 0 || rect.top >= viewportHeight)
          continue;
        const pageCenter = rect.top + rect.height / 2;
        const distanceToCenter = Math.abs(pageCenter - viewportCenter);
        if (distanceToCenter < minDistanceToCenter) {
          minDistanceToCenter = distanceToCenter;
          centralPage = pageElement;
        }
      }
      if (centralPage) {
        const pageNumberStr = centralPage.dataset.pageNumber;
        if (pageNumberStr) {
          const pageNumber = parseInt(pageNumberStr, 10);
          this.ensurePageOverlayLoaded(pageNumber, centralPage).catch(
            (err) => this.logDebug(`Quick check load error page ${pageNumber}`, err)
          );
        }
      }
    } catch (error) {
      this.logDebug("quickVisibilityCheck error", error);
    }
  }
  // Comprehensive check that runs after scroll settles
  async comprehensiveOverlayCheck() {
    if (this.isScrollSafeguardRunning)
      return;
    this.isScrollSafeguardRunning = true;
    try {
      const activeLeaf = this.getActivePDFLeaf();
      if (!activeLeaf)
        return;
      const pages = this.getPDFPagesForLeaf(activeLeaf);
      if (!pages)
        return;
      const viewportHeight = window.innerHeight;
      const visiblePages = [];
      for (const pageElement of Array.from(pages)) {
        const rect = pageElement.getBoundingClientRect();
        if (rect.bottom < -200 || rect.top > viewportHeight + 200)
          continue;
        const pageNumberStr = pageElement.dataset.pageNumber;
        if (pageNumberStr) {
          const pageNumber = parseInt(pageNumberStr, 10);
          if (this.pagesWithOverlays.has(pageNumber)) {
            visiblePages.push({ element: pageElement, pageNumber });
          }
        }
      }
      const batchSize = 3;
      for (let i = 0; i < visiblePages.length; i += batchSize) {
        const batch = visiblePages.slice(i, i + batchSize);
        const loadPromises = batch.map(
          ({ element, pageNumber }) => this.ensurePageOverlayLoaded(pageNumber, element)
        );
        await Promise.allSettled(loadPromises);
      }
      this.logDebug(`Comprehensive check completed for ${visiblePages.length} visible pages`);
    } catch (error) {
      this.logDebug("comprehensiveOverlayCheck error", error);
    } finally {
      this.isScrollSafeguardRunning = false;
    }
  }
  // Improved single page overlay loading with better state tracking
  async ensurePageOverlayLoaded(pageNumber, pageElement) {
    if (!this.pagesWithOverlays.has(pageNumber))
      return;
    const hasOverlay = pageElement.querySelector(".pdf-text-overlay-reflow") !== null;
    const isLoaded = this.loadedOverlayPages.has(pageNumber);
    if (hasOverlay && isLoaded)
      return;
    if (hasOverlay && !isLoaded) {
      this.loadedOverlayPages.add(pageNumber);
      return;
    }
    try {
      await this.loadSavedOverlayForPage(pageNumber, false);
    } catch (error) {
      this.logDebug(`Failed to ensure overlay for page ${pageNumber}:`, error);
      this.loadedOverlayPages.delete(pageNumber);
    }
  }
  /**
   * [Optimized] Rerender all visible overlays after zoom or layout change.
   * Uses staging + batching to minimize reflows and parallelize across pages.
   */
  async rerenderVisibleOverlays() {
    var _a, _b;
    if (this.isReloadingOverlay)
      return;
    this.isReloadingOverlay = true;
    this.logDebug("Rerendering visible overlays due to zoom or layout change.");
    try {
      const leaf = this.getActivePDFLeaf();
      if (!leaf)
        return;
      const viewerContainer = leaf.view.containerEl.querySelector(".pdfViewer, #viewer");
      if (!viewerContainer) {
        this.logDebug("Could not find viewer container during rerender. Aborting.");
        return;
      }
      await new Promise((r) => setTimeout(r, ZOOM_DIM_STABLE_WAIT));
      const pages = this.getPDFPagesForLeaf(leaf);
      if (!pages)
        return;
      const viewportHeight = window.innerHeight;
      const visiblePages = Array.from(pages).filter((p) => {
        const rect = p.getBoundingClientRect();
        return rect.bottom > 0 && rect.top < viewportHeight;
      });
      if (visiblePages.length === 0)
        return;
      visiblePages.forEach((pageElement) => {
        const pageNumberStr = pageElement.dataset.pageNumber;
        if (pageNumberStr) {
          const pageNumber = parseInt(pageNumberStr, 10);
          this.loadedOverlayPages.delete(pageNumber);
        }
      });
      const stagingContainer = document.createElement("div");
      stagingContainer.style.cssText = `
                position: absolute;
                top: -99999px;
                left: -99999px;
                visibility: hidden;
            `;
      document.body.appendChild(stagingContainer);
      const pageOverlaySets = [];
      await Promise.all(visiblePages.map(async (pageElement) => {
        var _a2;
        const pageNumberStr = pageElement.dataset.pageNumber;
        if (!pageNumberStr)
          return;
        const pageNumber = parseInt(pageNumberStr, 10);
        if (!this.pagesWithOverlays.has(pageNumber))
          return;
        const pageData = (_a2 = this.cachedOverlayData) == null ? void 0 : _a2.pageOverlays[pageNumber];
        if (!pageData || pageData.length === 0)
          return;
        const textLayer = await this.waitForPdfTextLayer(pageNumber);
        if (!textLayer)
          return;
        if (pageElement.querySelector(".pdf-text-overlay-container")) {
          this.clearOverlayFromPage(pageElement);
        }
        const overlayContainer = this.preparePageForOverlay(pageElement);
        const textLayerRect = textLayer.getBoundingClientRect();
        const fallbackRef = textLayer.querySelector("span") || document.createElement("span");
        const overlays = [];
        for (const data of pageData) {
          try {
            const absRect = new DOMRect(
              data.relativeRect.left * textLayerRect.width,
              data.relativeRect.top * textLayerRect.height,
              data.relativeRect.width * textLayerRect.width,
              data.relativeRect.height * textLayerRect.height
            );
            const overlayEl = this.uiRenderer.createReflowOverlay(
              absRect,
              data.translatedText,
              fallbackRef,
              data.originalFontSizes || [],
              pageNumber,
              data.textContent || "",
              this.plugin.settings.overlayOpacity,
              this.plugin.settings.outputFontSizeScale,
              this.plugin.settings.outputLineHeight,
              this.lastKnownScale,
              data.fontFamily
            );
            stagingContainer.appendChild(overlayEl);
            overlays.push(overlayEl);
          } catch (err) {
            this.logDebug(`Error staging overlay for page ${pageNumber}`, err);
          }
        }
        pageOverlaySets.push({ pageElement: overlayContainer, overlays });
      }));
      await new Promise((resolve) => requestAnimationFrame(() => {
        for (const { overlays } of pageOverlaySets) {
          for (const el of overlays) {
            this.uiRenderer.adjustOverlayForOverflow(el, this.plugin.settings.outputLineHeight);
          }
        }
        resolve();
      }));
      for (const { pageElement, overlays } of pageOverlaySets) {
        for (const el of overlays) {
          pageElement.appendChild(el);
        }
        const pageNumberStr = (_b = (_a = pageElement.dataset) == null ? void 0 : _a.dataset) == null ? void 0 : _b.pageNumber;
        if (pageNumberStr) {
          const pageNumber = parseInt(pageNumberStr, 10);
          this.loadedOverlayPages.add(pageNumber);
        }
      }
      stagingContainer.remove();
      this.logDebug(`Rerendered overlays for ${pageOverlaySets.length} visible page(s)`);
    } catch (error) {
      this.logDebug("Error during visible overlay rerender:", error);
    } finally {
      this.isReloadingOverlay = false;
    }
  }
  clampAllBboxPositions() {
    const currentPageEl = this.getCurrentPageElement();
    if (!currentPageEl)
      return;
    const pageRect = currentPageEl.getBoundingClientRect();
    currentPageEl.querySelectorAll(".pdf-text-overlay-reflow").forEach((el) => {
      const htmlEl = el;
      let left = parseFloat(htmlEl.style.left || "0");
      let top = parseFloat(htmlEl.style.top || "0");
      const width = parseFloat(htmlEl.style.width || "0");
      const height = parseFloat(htmlEl.style.height || "0");
      left = Math.max(0, Math.min(left, pageRect.width - width));
      top = Math.max(0, Math.min(top, pageRect.height - height));
      htmlEl.style.left = `${left}px`;
      htmlEl.style.top = `${top}px`;
    });
  }
  // ============================================================
  // Visibility & Utility
  // ============================================================
  toggleOverlayVisibility() {
    this.isOverlayVisible = !this.isOverlayVisible;
    const timeoutKey = "visibilityTimeout";
    const cachedTimeout = this.memoCache.get(timeoutKey);
    if (cachedTimeout) {
      clearTimeout(cachedTimeout.value);
    }
    const timeout = setTimeout(() => this.updateAllOverlayVisibility(), DEBOUNCE_DELAY);
    this.memoCache.set(timeoutKey, { value: timeout, timestamp: Date.now() });
    new import_obsidian5.Notice(`Overlay ${this.isOverlayVisible ? "shown" : "hidden"}`);
    this.plugin.settings.showOverlayByDefault = this.isOverlayVisible;
    this.plugin.saveSettings().catch(console.error);
  }
  updateAllOverlayVisibility() {
    var _a;
    const cacheKey = "cacheRefresh";
    if (!this.activeLeavesCache || Date.now() - (((_a = this.memoCache.get(cacheKey)) == null ? void 0 : _a.timestamp) || 0) > 1e3) {
      this.activeLeavesCache = new Set(this.plugin.app.workspace.getLeavesOfType("pdf"));
      this.memoCache.set(cacheKey, { value: null, timestamp: Date.now() });
    }
    this.activeLeavesCache.forEach((leaf) => {
      const pages = this.getPDFPagesForLeaf(leaf);
      pages == null ? void 0 : pages.forEach((page) => {
        page.querySelectorAll(".pdf-text-overlay-reflow").forEach((overlay) => {
          this.uiRenderer.setOverlayElementVisibility(overlay, this.isOverlayVisible);
        });
      });
    });
  }
  // Note: adjustOverlayForOverflow is now handled by uiRenderer and is private there
  // Note: setOverlayElementVisibility is now handled by uiRenderer and is private there
  // ============================================================
  // Getters (with memoization)
  // ============================================================
  getMemoized(key, fn, ttl = CACHE_TTL) {
    const cached = this.memoCache.get(key);
    if (cached && Date.now() - cached.timestamp < ttl)
      return cached.value;
    const value = fn();
    this.memoCache.set(key, { value, timestamp: Date.now() });
    return value;
  }
  getActivePDFLeaf() {
    var _a;
    const activeLeaf = this.plugin.app.workspace.activeLeaf;
    return ((_a = activeLeaf == null ? void 0 : activeLeaf.view) == null ? void 0 : _a.getViewType()) === "pdf" ? activeLeaf : null;
  }
  getPDFPagesForLeaf(leaf) {
    var _a, _b;
    const viewerContainer = (_b = (_a = leaf == null ? void 0 : leaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.querySelector(".pdfViewer, #viewer");
    return (viewerContainer == null ? void 0 : viewerContainer.querySelectorAll(".page[data-page-number]")) || null;
  }
  getCurrentPageElement() {
    return this.getMemoized("currentPage", () => {
      try {
        const activeLeaf = this.getActivePDFLeaf();
        if (!activeLeaf)
          return null;
        const pages = this.getPDFPagesForLeaf(activeLeaf);
        return this.getCurrentVisiblePage(pages);
      } catch (error) {
        this.logDebug("getCurrentPageElement error:", error);
        return null;
      }
    });
  }
  getCurrentPageTextLayer() {
    return this.getMemoized("currentTextLayer", () => {
      const currentPage = this.getCurrentPageElement();
      return currentPage ? currentPage.querySelector(".textLayer") : null;
    });
  }
  getCurrentVisiblePage(pages) {
    if (!pages || pages.length === 0)
      return null;
    let bestPage = null;
    let maxVisibleArea = -1;
    for (const page of Array.from(pages)) {
      const rect = page.getBoundingClientRect();
      if (rect.width === 0 || rect.height === 0)
        continue;
      const viewportHeight = window.innerHeight;
      const visibleTop = Math.max(0, rect.top);
      const visibleBottom = Math.min(viewportHeight, rect.bottom);
      const visibleHeight = Math.max(0, visibleBottom - visibleTop);
      const visibleArea = visibleHeight * rect.width;
      if (visibleArea > maxVisibleArea) {
        maxVisibleArea = visibleArea;
        bestPage = page;
      }
    }
    return bestPage;
  }
  // ============================================================
  // Overlay Creation & Rendering
  // ============================================================
  async waitForPdfTextLayer(pageNumber) {
    if (pageNumber <= 0) {
      this.logDebug("waitForPdfTextLayer: Invalid page number");
      return null;
    }
    const activeLeaf = this.getActivePDFLeaf();
    if (!activeLeaf)
      return null;
    return new Promise((resolve) => {
      const startTime = Date.now();
      const interval = setInterval(() => {
        if (Date.now() - startTime > OVERLAY_WAIT_TIMEOUT) {
          clearInterval(interval);
          this.logDebug(`Timeout waiting for text layer on page ${pageNumber}`);
          resolve(null);
          return;
        }
        const pages = this.getPDFPagesForLeaf(activeLeaf);
        const page = pages ? Array.from(pages).find((p) => parseInt(p.dataset.pageNumber || "0") === pageNumber) : null;
        const textLayer = page == null ? void 0 : page.querySelector(".textLayer");
        if (textLayer) {
          clearInterval(interval);
          resolve(textLayer);
        }
      }, OVERLAY_CHECK_INTERVAL);
    });
  }
  // Note: bringToTop is now handled by uiRenderer and is private there
  // Note: createReflowOverlay is now handled by uiRenderer and is private there
  /**
   * Render all saved overlays onto a page, using a staging container
   * to batch DOM measurements and reduce layout thrashing.
   */
  async renderSavedOverlay(positionData, pageNumber) {
    try {
      const textLayer = await this.waitForPdfTextLayer(pageNumber);
      if (!textLayer) {
        this.logDebug(`Cannot render overlay \u2013 no textLayer for page ${pageNumber}`);
        return;
      }
      const pageElement = textLayer.closest(".page");
      if (!pageElement)
        return;
      let retries = 0;
      let textLayerRect = textLayer.getBoundingClientRect();
      while ((textLayerRect.width === 0 || textLayerRect.height === 0) && retries < MAX_DIMENSION_RETRIES) {
        await new Promise((r) => setTimeout(r, RETRY_DELAY));
        retries++;
        textLayerRect = textLayer.getBoundingClientRect();
      }
      if (textLayerRect.width === 0 || textLayerRect.height === 0) {
        this.logDebug(`TextLayer still unavailable for page ${pageNumber} after ${retries} retries`);
        return;
      }
      const overlayContainer = this.preparePageForOverlay(pageElement);
      const fallbackRef = textLayer.querySelector("span") || document.createElement("span");
      const stagingContainer = document.createElement("div");
      stagingContainer.style.cssText = `
                position: absolute;
                top: -99999px;
                left: -99999px;
                visibility: hidden;
            `;
      document.body.appendChild(stagingContainer);
      const overlays = [];
      for (const data of positionData) {
        try {
          const scaleX = textLayerRect.width;
          const scaleY = textLayerRect.height;
          const absoluteRect = new DOMRect(
            data.relativeRect.left * scaleX,
            data.relativeRect.top * scaleY,
            data.relativeRect.width * scaleX,
            data.relativeRect.height * scaleY
          );
          const overlayEl = this.uiRenderer.createReflowOverlay(
            absoluteRect,
            data.translatedText,
            fallbackRef,
            data.originalFontSizes || [],
            pageNumber,
            data.textContent || "",
            this.plugin.settings.overlayOpacity,
            this.plugin.settings.outputFontSizeScale,
            this.plugin.settings.outputLineHeight,
            this.lastKnownScale,
            data.fontFamily
          );
          stagingContainer.appendChild(overlayEl);
          overlays.push(overlayEl);
        } catch (itemError) {
          this.logDebug(`Error staging overlay for page ${pageNumber}`, itemError);
        }
      }
      await new Promise((resolve) => requestAnimationFrame(() => {
        for (const el of overlays) {
          this.uiRenderer.adjustOverlayForOverflow(el, this.plugin.settings.outputLineHeight);
        }
        resolve();
      }));
      for (const el of overlays) {
        overlayContainer.appendChild(el);
      }
      stagingContainer.remove();
      this.loadedOverlayPages.add(pageNumber);
      this.logDebug(`Rendered saved overlay for page ${pageNumber} (${overlays.length} items)`);
      setTimeout(() => this.clampAllBboxPositions(), 50);
    } catch (error) {
      this.logDebug(`renderSavedOverlay failed for page ${pageNumber}:`, error);
    }
  }
  // ============================================================
  // Loading & Saving (ENHANCED with better state tracking)
  // ============================================================
  async loadSavedOverlayForPage(pageNumber, force = false) {
    if (!this.cachedOverlayData) {
      this.logDebug(`No cached overlay data available for page ${pageNumber}`);
      return;
    }
    if (this.inFlightPageLoads.has(pageNumber) && !force) {
      await this.inFlightPageLoads.get(pageNumber);
      return;
    }
    const loadPromise = (async () => {
      try {
        const pageData = this.cachedOverlayData.pageOverlays[pageNumber];
        if (!pageData || pageData.length === 0) {
          this.logDebug(`No overlay data for page ${pageNumber}`);
          return;
        }
        const textLayer = await this.waitForPdfTextLayer(pageNumber);
        if (!textLayer) {
          this.logDebug(`No text layer found for page ${pageNumber}`);
          return;
        }
        const pageElement = textLayer.closest(".page");
        if (!pageElement) {
          this.logDebug(`No page element found for page ${pageNumber}`);
          return;
        }
        const hasOverlay = pageElement.querySelector(".pdf-text-overlay-reflow") !== null;
        const isLoaded = this.loadedOverlayPages.has(pageNumber);
        if (hasOverlay && isLoaded && !force) {
          return;
        }
        if (force) {
          this.clearOverlayFromPage(pageElement);
        }
        this.logDebug(`Loading overlays for page ${pageNumber}`);
        await this.renderSavedOverlay(pageData, pageNumber);
        this.memoCache.delete("currentPage");
        this.memoCache.delete("currentTextLayer");
      } catch (error) {
        this.logDebug(`Error loading overlay for page ${pageNumber}:`, error);
        this.loadedOverlayPages.delete(pageNumber);
        throw error;
      }
    })();
    this.inFlightPageLoads.set(pageNumber, loadPromise);
    try {
      await loadPromise;
    } finally {
      this.inFlightPageLoads.delete(pageNumber);
    }
  }
  async loadSavedOverlayForCurrentPage(forceReload = false) {
    var _a;
    try {
      const pageNumber = this.plugin.getCurrentPageNumber();
      if (pageNumber === null)
        return;
      const pageElement = this.getCurrentPageElement();
      if (!pageElement)
        return;
      if (forceReload) {
        this.clearOverlayFromPage(pageElement);
      }
      const hasOverlay = pageElement.querySelector(".pdf-text-overlay-container") !== null;
      const isLoaded = this.loadedOverlayPages.has(pageNumber);
      if (hasOverlay && isLoaded && !forceReload) {
        return;
      }
      const activeFile = (_a = this.getActivePDFLeaf()) == null ? void 0 : _a.view.file;
      if (activeFile) {
        await this.initializeOverlayStateForPdf(activeFile);
        await this.loadSavedOverlayForPage(pageNumber, forceReload);
      }
    } catch (error) {
      this.logDebug("loadSavedOverlayForCurrentPage failed:", error);
    }
  }
  async extractCurrentOverlayParameters() {
    var _a;
    try {
      const currentPageNumber = this.plugin.getCurrentPageNumber();
      if (currentPageNumber === null) {
        return { positionData: [], pageNumber: 0, hasData: false };
      }
      const textLayer = this.getCurrentPageTextLayer();
      const overlayContainer = (_a = textLayer == null ? void 0 : textLayer.closest(".page")) == null ? void 0 : _a.querySelector(".pdf-text-overlay-container");
      if (!textLayer || !overlayContainer) {
        return { positionData: [], pageNumber: currentPageNumber, hasData: false };
      }
      let textLayerRect = textLayer.getBoundingClientRect();
      let retries = 0;
      while ((textLayerRect.width === 0 || textLayerRect.height === 0) && retries < EXTRACT_MAX_RETRIES) {
        await new Promise((r) => setTimeout(r, EXTRACT_RETRY_INTERVAL));
        retries++;
        if (retries % 5 === 0)
          this.logDebug(`Extract retry ${retries}/${EXTRACT_MAX_RETRIES} for dims`);
        textLayerRect = textLayer.getBoundingClientRect();
      }
      if (textLayerRect.width === 0 || textLayerRect.height === 0) {
        this.logDebug("Extraction failed: Text layer dims still zero after retries.");
        return { positionData: [], pageNumber: currentPageNumber, hasData: false };
      }
      const positionData = this.extractPositionDataFrom(textLayer, overlayContainer, textLayerRect);
      return {
        positionData,
        pageNumber: currentPageNumber,
        hasData: positionData.length > 0
      };
    } catch (error) {
      this.logDebug("extractCurrentOverlayParameters failed:", error);
      return { positionData: [], pageNumber: 0, hasData: false };
    }
  }
  extractPositionDataFrom(textLayer, overlayContainer, textLayerRect) {
    var _a, _b;
    if (!textLayer || !overlayContainer) {
      return [];
    }
    const positionData = [];
    const overlays = overlayContainer.querySelectorAll(".pdf-text-overlay-reflow");
    const pageNumber = (_a = this.plugin.getCurrentPageNumber()) != null ? _a : 0;
    const pdfViewer = textLayer.closest(".pdfViewer, #viewer");
    const saveScale = parseFloat((pdfViewer == null ? void 0 : pdfViewer.style.getPropertyValue("--scale-factor")) || "1");
    if (isNaN(saveScale) || saveScale <= 0) {
      this.logDebug("Invalid saveScale; falling back to 1.0");
    }
    for (const overlay of overlays) {
      try {
        const rect = overlay.getBoundingClientRect();
        const relativeRect = {
          left: (rect.left - textLayerRect.left) / textLayerRect.width,
          top: (rect.top - textLayerRect.top) / textLayerRect.height,
          width: rect.width / textLayerRect.width,
          height: rect.height / textLayerRect.height
        };
        let originalFontSizes = [];
        const fontSizesAttr = overlay.getAttribute("data-original-font-sizes");
        if (fontSizesAttr) {
          try {
            originalFontSizes = JSON.parse(fontSizesAttr);
          } catch (e) {
            this.logDebug("Could not parse font sizes from attribute", e);
          }
        }
        const relativeFontSizes = originalFontSizes.length > 0 && saveScale > 0 ? originalFontSizes.map((fs) => fs / saveScale) : [];
        positionData.push({
          selector: "",
          textContent: overlay.getAttribute("data-original-text") || "",
          translatedText: ((_b = overlay.querySelector("div")) == null ? void 0 : _b.innerHTML) || overlay.textContent || "",
          relativeRect,
          page: pageNumber,
          originalFontSizes: relativeFontSizes,
          fontFamily: overlay.style.fontFamily || void 0
        });
      } catch (itemError) {
        this.logDebug("extractPositionDataFrom item error:", itemError);
      }
    }
    return positionData;
  }
  async saveCurrentPageOverlay() {
    var _a, _b;
    try {
      const activeFile = (_b = (_a = this.getActivePDFLeaf()) == null ? void 0 : _a.view) == null ? void 0 : _b.file;
      if (!activeFile) {
        this.logDebug("Cannot save overlay, no active PDF file.");
        return false;
      }
      const extracted = await this.extractCurrentOverlayParameters();
      if (!extracted.hasData) {
        this.logDebug("No overlay data found on the current page to save.");
        return false;
      }
      const pagesToUpdate = { [extracted.pageNumber]: extracted.positionData };
      await this.plugin.storage.updatePageOverlaysAndWrite(activeFile, pagesToUpdate);
      this.pagesWithOverlays.add(extracted.pageNumber);
      this.loadedOverlayPages.add(extracted.pageNumber);
      if (!this.cachedOverlayData) {
        this.cachedOverlayData = { filePath: activeFile.path, pageOverlays: {} };
      }
      this.cachedOverlayData.pageOverlays[extracted.pageNumber] = extracted.positionData;
      new import_obsidian5.Notice(`Saved overlay for page ${extracted.pageNumber}`);
      return true;
    } catch (error) {
      this.logDebug("saveCurrentPageOverlay failed:", error);
      new import_obsidian5.Notice("Error saving overlay data.");
      return false;
    }
  }
  // Note: adjustSingleOverlayLineHeight and adjustSingleOverlayFontSize are now handled by uiRenderer and are private there
  // ============================================================
  // Cleanup (ENHANCED with better state tracking)
  // ============================================================
  // Note: cleanupHoverHandlers and cleanupOverlayElement are now handled by uiRenderer and are private there
  // The main cleanupOverlayElement is now a delegate call to uiRenderer.cleanupOverlayElement
  cleanupMonitoring() {
    var _a, _b, _c;
    (_a = this.pageObserver) == null ? void 0 : _a.disconnect();
    this.pageObserver = null;
    (_b = this.zoomObserver) == null ? void 0 : _b.disconnect();
    this.zoomObserver = null;
    (_c = this.pageIntersectionObserver) == null ? void 0 : _c.disconnect();
    this.pageIntersectionObserver = null;
    if (this.scrollableContainer && this.scrollHandler) {
      this.scrollableContainer.removeEventListener("scroll", this.scrollHandler);
      this.scrollableContainer = null;
      this.scrollHandler = null;
    }
    if (this.scrollThrottleTimeout) {
      clearTimeout(this.scrollThrottleTimeout);
      this.scrollThrottleTimeout = null;
    }
    if (this.zoomDebounceTimeout) {
      clearTimeout(this.zoomDebounceTimeout);
      this.zoomDebounceTimeout = null;
    }
    this.loadedOverlayPages.clear();
    this.isScrollSafeguardRunning = false;
    this.lastScrollCheck = 0;
    this.lastQuickCheck = 0;
  }
  cleanup() {
    this.cleanupMonitoring();
    this.uiRenderer.cleanup();
    this.memoCache.clear();
    this.activeLeavesCache = null;
    this.cachedOverlayData = null;
    this.pagesWithOverlays.clear();
    this.loadedOverlayPages.clear();
    this.inFlightPageLoads.clear();
  }
  // Note: showContextMenu is now handled by uiRenderer and is private there
  // If the context menu logic needs to be triggered from here, it should be done
  // by calling a method on uiRenderer that receives the required context.
  // ============================================================
  // Logging Utility
  // ============================================================
  logDebug(message, ...args) {
    var _a;
    const prefixed = `[OverlayRenderer] ${message}`;
    if (typeof this.plugin.logDebug === "function") {
      this.plugin.logDebug(prefixed, ...args);
    } else if ((_a = this.plugin.settings) == null ? void 0 : _a.debugMode) {
      console.log(prefixed, ...args);
    }
  }
};

// translation.ts
var import_obsidian6 = require("obsidian");
var TranslationEngine = class {
  constructor(plugin) {
    this.warnedAboutQwen = false;
    this.plugin = plugin;
  }
  // === Language Helpers (No changes needed) ===
  getSourceLangName() {
    var _a;
    return this.plugin.settings.sourceLanguage === "auto" ? "Auto-detect" : ((_a = AVAILABLE_LANGUAGES.find((l) => l.code === this.plugin.settings.sourceLanguage)) == null ? void 0 : _a.name) || this.plugin.settings.sourceLanguage;
  }
  getTargetLangName() {
    var _a;
    return ((_a = AVAILABLE_LANGUAGES.find((l) => l.code === this.plugin.settings.targetLanguage)) == null ? void 0 : _a.name) || this.plugin.settings.targetLanguage;
  }
  // === High-Level Translation Methods ===
  /**
   * Translates a batch of text using the currently configured provider.
   */
  async translateBatch(originalText, expectedLineCount) {
    const systemPromptTemplate = this.plugin.settings.batchPrompt;
    const systemPrompt = systemPromptTemplate.replace(/{sourceLang}/g, this.getSourceLangName()).replace(/{targetLang}/g, this.getTargetLangName()).replace(/{lineCount}/g, expectedLineCount.toString()).replace(/{inputText}/g, "");
    return await this.makeApiCall(systemPrompt, originalText);
  }
  /**
   * Translates a single piece of text. Maintained for compatibility.
   */
  async translateWithOpenRouter(text) {
    const systemPromptTemplate = this.plugin.settings.singlePrompt;
    const systemPrompt = systemPromptTemplate.replace(/{sourceLang}/g, this.getSourceLangName()).replace(/{targetLang}/g, this.getTargetLangName()).replace(/{inputText}/g, "");
    return await this.makeApiCall(systemPrompt, text.slice(0, 3e3));
  }
  // === Low-Level API Communication ===
  /**
   * Safely retrieves a nested property from an object using a string path (e.g., 'choices[0].message.content').
   */
  getPropertyByPath(obj, path) {
    const keys = path.replace(/\[(\w+)\]/g, ".$1").replace(/^\./, "").split(".");
    let result = obj;
    for (const key of keys) {
      if (result === null || result === void 0) {
        return void 0;
      }
      result = result[key];
    }
    return result;
  }
  /**
   * Escapes characters in a string for safe inclusion in a JSON request body.
   */
  escapeJsonString(str) {
    return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
  }
  /**
   * Constructs the request URL, headers, and body based on the selected provider.
   */
  getRequestConfig(systemPrompt, userPrompt) {
    const providerId = this.plugin.settings.apiProvider;
    const provider = this.plugin.settings.providerSettings[providerId];
    let url;
    let body;
    let headers = { "Content-Type": "application/json" };
    switch (providerId) {
      case "openrouter":
        if (!provider.apiKey)
          throw new Error("OpenRouter API key is missing.");
        url = "https://openrouter.ai/api/v1/chat/completions";
        headers["Authorization"] = `Bearer ${provider.apiKey}`;
        headers["HTTP-Referer"] = "obsidian://pdf-translator";
        headers["X-Title"] = "PDF Translator Plugin";
        body = {
          model: provider.model,
          messages: [
            { role: "system", content: systemPrompt },
            { role: "user", content: userPrompt }
          ],
          max_tokens: 4096,
          temperature: 0.1
        };
        break;
      case "ollama":
        if (!provider.apiEndpoint || !provider.model)
          throw new Error("Ollama endpoint or model is missing.");
        const endpoint = provider.apiEndpoint.endsWith("/") ? provider.apiEndpoint.slice(0, -1) : provider.apiEndpoint;
        url = `${endpoint}/api/chat`;
        body = {
          model: provider.model,
          stream: false,
          messages: [
            { role: "system", content: systemPrompt },
            { role: "user", content: userPrompt }
          ]
        };
        break;
      case "custom":
        if (!provider.apiEndpoint)
          throw new Error("Custom API endpoint is missing.");
        url = provider.apiEndpoint;
        if (provider.headers) {
          const populatedHeaders = provider.headers.replace(/{apiKey}/g, provider.apiKey || "");
          try {
            headers = { ...headers, ...JSON.parse(populatedHeaders) };
          } catch (e) {
            throw new Error("Failed to parse custom headers JSON.");
          }
        }
        if (provider.requestBody) {
          const populatedBody = provider.requestBody.replace(/{model}/g, provider.model || "").replace(/{systemPrompt}/g, this.escapeJsonString(systemPrompt)).replace(/{userPrompt}/g, this.escapeJsonString(userPrompt));
          try {
            body = JSON.parse(populatedBody);
          } catch (e) {
            throw new Error("Failed to parse custom request body JSON.");
          }
        } else {
          throw new Error("Custom request body setting is missing.");
        }
        break;
      default:
        throw new Error(`Unsupported API provider: ${providerId}`);
    }
    return {
      url,
      options: {
        method: "POST",
        headers,
        body: JSON.stringify(body),
        throw: false
      }
    };
  }
  /**
   * Makes an API call to the configured provider with retry logic.
   */
  async makeApiCall(systemPrompt, userPrompt) {
    var _a, _b, _c;
    const providerId = this.plugin.settings.apiProvider;
    const providerSettings = this.plugin.settings.providerSettings[providerId];
    if (providerId === "openrouter" && ((_a = providerSettings.model) == null ? void 0 : _a.includes("qwen")) && !this.warnedAboutQwen) {
      new import_obsidian6.Notice("Warning: Some Qwen models have low rate limits. Consider gemini-flash.", 6e3);
      this.warnedAboutQwen = true;
    }
    const MAX_RETRIES = 3;
    const BASE_DELAY = 1e3;
    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      try {
        const { url, options } = this.getRequestConfig(systemPrompt, userPrompt);
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 45e3);
        options.signal = controller.signal;
        const response = await (0, import_obsidian6.requestUrl)({ url, ...options });
        clearTimeout(timeoutId);
        if (response.status === 200) {
          let responsePath = "choices[0].message.content";
          if (providerId === "ollama") {
            responsePath = "message.content";
          } else if (providerId === "custom") {
            responsePath = providerSettings.responsePath || responsePath;
          }
          const translatedText = this.getPropertyByPath(response.json, responsePath);
          return (translatedText == null ? void 0 : translatedText.trim()) || userPrompt;
        }
        const errorMsg = ((_c = (_b = response.json) == null ? void 0 : _b.error) == null ? void 0 : _c.message) || response.text;
        if (response.status === 429 || typeof errorMsg === "string" && errorMsg.toLowerCase().includes("rate limit")) {
          if (attempt === MAX_RETRIES)
            break;
          const delay = BASE_DELAY * Math.pow(2, attempt - 1) + Math.random() * 500;
          if (this.plugin.settings.debugMode) {
            console.log(`Rate limit hit. Retrying in ${delay}ms (attempt ${attempt})`);
          }
          await this.sleep(delay);
          continue;
        }
        throw new Error(`API Error - HTTP ${response.status}: ${errorMsg}`);
      } catch (err) {
        if (err.name === "AbortError") {
          throw new Error("Request timed out (45s)");
        }
        if (attempt === MAX_RETRIES) {
          new import_obsidian6.Notice(`API call failed: ${err.message}`);
          throw err;
        }
      }
    }
    throw new Error("Rate limit exceeded after multiple retries.");
  }
  // === Utility: Safe delay ===
  async sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
};

// processing.ts
var import_obsidian7 = require("obsidian");

// GapDetector.ts
var GapDetector = class {
  constructor() {
    // Tuning parameters
    this.MIN_STRIP_CONFIDENCE = 0.6;
    this.MAX_COLUMNS = 6;
    this.MIN_GAP_WIDTH_PX = 2;
    // Minimum horizontal gap width to consider
    this.BAND_STEP_FACTOR = 0.75;
    // step = max(6, avgLineHeight * BAND_STEP_FACTOR)
    this.MIN_STRIP_HEIGHT_FACTOR = 1.5;
    // min strip height in multiples of avgLineHeight
    this.CENTER_X_TOL_FACTOR = 0.5;
    // x clustering tolerance in multiples of avgLineHeight
    this.WIDTH_STABILITY_WEIGHT = 0.25;
    this.CENTER_STABILITY_WEIGHT = 0.25;
    this.COVERAGE_WEIGHT = 0.5;
  }
  /**
   * Compatibility API: Accepts DOM spans and page element, normalizes by DPR,
   * and delegates to detectGapsFromRects.
   */
  detectGaps(spans, pageElement) {
    const dpr = window.devicePixelRatio || 1;
    const pageRectRaw = pageElement.getBoundingClientRect();
    const pageRect = new DOMRect(
      pageRectRaw.left / dpr,
      pageRectRaw.top / dpr,
      pageRectRaw.width / dpr,
      pageRectRaw.height / dpr
    );
    const rects = spans.map((s) => {
      const r = s.getBoundingClientRect();
      return new DOMRect(r.left / dpr, r.top / dpr, r.width / dpr, r.height / dpr);
    });
    return this.detectGapsFromRects(rects, pageRect);
  }
  /**
   * Preferred API: Accepts normalized span rects and page rect.
   */
  detectGapsFromRects(spanRects, pageRect) {
    if (!spanRects || spanRects.length === 0) {
      return {
        verticalBoundaries: [],
        columns: [],
        layoutSegments: [],
        verticalStrips: [],
        horizontalBands: []
      };
    }
    const avgLineHeight = this.estimateAverageLineHeight(spanRects);
    const layoutSegments = this.segmentVerticalLayouts(spanRects, pageRect, avgLineHeight);
    const { verticalStrips, horizontalBands } = this.detectStripsAndBands(
      spanRects,
      pageRect,
      avgLineHeight
    );
    const verticalBoundaries = verticalStrips.map((s) => ({
      x: (s.left + s.right) / 2,
      confidence: s.confidence,
      width: Math.max(1, s.right - s.left),
      height: pageRect.height,
      segmentIndex: 0
    })).filter((b) => b.confidence >= this.MIN_STRIP_CONFIDENCE).sort((a, b) => a.x - b.x);
    const columns = this.createColumnsFromBoundaries(verticalBoundaries, pageRect);
    return {
      verticalBoundaries,
      columns,
      layoutSegments,
      verticalStrips,
      horizontalBands
    };
  }
  // -----------------------------
  // Core computations
  // -----------------------------
  estimateAverageLineHeight(spanRects) {
    if (!spanRects || spanRects.length === 0)
      return 15;
    const heights = spanRects.map((r) => r.height).filter((h) => h > 3);
    if (!heights.length)
      return 15;
    heights.sort((a, b) => a - b);
    const mid = Math.floor(heights.length / 2);
    return heights.length % 2 ? heights[mid] : (heights[mid - 1] + heights[mid]) / 2;
  }
  /**
   * Simple single-segment implementation.
   * Keep API so you can later swap with a more advanced segmenter if needed.
   */
  segmentVerticalLayouts(spanRects, pageRect, avgLineHeight) {
    return [{
      top: pageRect.top,
      bottom: pageRect.bottom,
      left: pageRect.left,
      right: pageRect.right
    }];
  }
  /**
   * Detect vertical strips (gaps) via y-banded occupancy and optional horizontal bands.
   * Steps:
   *  - Sweep the page in horizontal bands (y-axis), collect occupied x-intervals
   *  - Invert to gaps within each band
   *  - Cluster gaps across adjacent bands by center x
   *  - Compute strip confidence from coverage and stability
   */
  detectStripsAndBands(spanRects, pageRect, avgLine) {
    const bandStep = Math.max(6, avgLine * this.BAND_STEP_FACTOR);
    const bands = [];
    for (let y = pageRect.top; y < pageRect.bottom; y += bandStep) {
      const y1 = y;
      const y2 = Math.min(pageRect.bottom, y + bandStep);
      const active = spanRects.filter((r) => r.bottom > y1 && r.top < y2);
      if (active.length === 0) {
        bands.push({ y1, y2, gaps: [{ left: pageRect.left, right: pageRect.right }] });
        continue;
      }
      const occ = active.map((r) => ({ left: r.left, right: r.right })).sort((a, b) => a.left - b.left);
      const mergedOcc = [];
      for (const o of occ) {
        if (!mergedOcc.length || o.left > mergedOcc[mergedOcc.length - 1].right) {
          mergedOcc.push({ left: o.left, right: o.right });
        } else {
          mergedOcc[mergedOcc.length - 1].right = Math.max(mergedOcc[mergedOcc.length - 1].right, o.right);
        }
      }
      const gaps = [];
      let cursor = pageRect.left;
      for (const m of mergedOcc) {
        if (m.left - cursor >= this.MIN_GAP_WIDTH_PX) {
          gaps.push({ left: cursor, right: m.left });
        }
        cursor = Math.max(cursor, m.right);
      }
      if (pageRect.right - cursor >= this.MIN_GAP_WIDTH_PX) {
        gaps.push({ left: cursor, right: pageRect.right });
      }
      bands.push({ y1, y2, gaps });
    }
    const xTol = Math.max(4, avgLine * this.CENTER_X_TOL_FACTOR);
    const clusters = [];
    for (const band of bands) {
      const { y1, y2 } = band;
      for (const g of band.gaps) {
        const width = g.right - g.left;
        if (width < this.MIN_GAP_WIDTH_PX)
          continue;
        const center = (g.left + g.right) / 2;
        let placed = false;
        for (const c of clusters) {
          const lastCenter = c.centers[c.centers.length - 1];
          if (Math.abs(center - lastCenter) <= xTol) {
            c.centers.push(center);
            c.widths.push(width);
            c.lefts.push(g.left);
            c.rights.push(g.right);
            c.y1s.push(y1);
            c.y2s.push(y2);
            placed = true;
            break;
          }
        }
        if (!placed) {
          clusters.push({
            centers: [center],
            widths: [width],
            lefts: [g.left],
            rights: [g.right],
            y1s: [y1],
            y2s: [y2]
          });
        }
      }
    }
    const minStripHeight = avgLine * this.MIN_STRIP_HEIGHT_FACTOR;
    const totalBands = bands.length;
    const strips = [];
    for (const c of clusters) {
      if (!c.centers.length)
        continue;
      const left = median(c.lefts);
      const right = median(c.rights);
      const top = Math.min(...c.y1s);
      const bottom = Math.max(...c.y2s);
      const height = bottom - top;
      if (height < minStripHeight)
        continue;
      const coverage = approxUniqueBandCount(c.y1s) / totalBands;
      const widthStd = stddev(c.widths);
      const centerStd = stddev(c.centers);
      const normWidthStd = widthStd / Math.max(1, median(c.widths));
      const normCenterStd = centerStd / Math.max(1, median(c.centers));
      let confidence = this.COVERAGE_WEIGHT * coverage + this.WIDTH_STABILITY_WEIGHT * (1 - clamp01(normWidthStd)) + this.CENTER_STABILITY_WEIGHT * (1 - clamp01(normCenterStd));
      confidence = clamp01(confidence);
      if (confidence >= this.MIN_STRIP_CONFIDENCE) {
        strips.push({ left, right, top, bottom, confidence });
      }
    }
    const horizontalBands = [];
    const mergedStrips = this.mergeSimilarStrips(strips);
    return { verticalStrips: mergedStrips, horizontalBands };
  }
  mergeSimilarStrips(strips) {
    if (!strips.length)
      return [];
    const sorted = [...strips].sort((a, b) => (a.left + a.right) / 2 - (b.left + b.right) / 2);
    const out = [];
    const xMergeTol = 3;
    let cur = { ...sorted[0] };
    for (let i = 1; i < sorted.length; i++) {
      const s = sorted[i];
      const centersClose = Math.abs((cur.left + cur.right) / 2 - (s.left + s.right) / 2) <= xMergeTol;
      const verticalOverlap = Math.min(cur.bottom, s.bottom) - Math.max(cur.top, s.top) > 0;
      if (centersClose && verticalOverlap) {
        cur.left = Math.min(cur.left, s.left);
        cur.right = Math.max(cur.right, s.right);
        cur.top = Math.min(cur.top, s.top);
        cur.bottom = Math.max(cur.bottom, s.bottom);
        cur.confidence = Math.max(cur.confidence, s.confidence);
      } else {
        out.push(cur);
        cur = { ...s };
      }
    }
    out.push(cur);
    return out;
  }
  createColumnsFromBoundaries(boundaries, pageRect) {
    if (!(boundaries == null ? void 0 : boundaries.length))
      return [{
        left: pageRect.left,
        top: pageRect.top,
        right: pageRect.right,
        bottom: pageRect.bottom,
        width: pageRect.width,
        height: pageRect.height
      }];
    const sorted = [...boundaries].sort((a, b) => a.x - b.x);
    const cols = [];
    let prevX = pageRect.left;
    for (const b of sorted) {
      const x = Math.max(pageRect.left, Math.min(pageRect.right, b.x));
      if (x > prevX) {
        cols.push({
          left: prevX,
          top: pageRect.top,
          right: x,
          bottom: pageRect.bottom,
          width: x - prevX,
          height: pageRect.height
        });
        prevX = x;
      }
    }
    if (prevX < pageRect.right) {
      cols.push({
        left: prevX,
        top: pageRect.top,
        right: pageRect.right,
        bottom: pageRect.bottom,
        width: pageRect.right - prevX,
        height: pageRect.height
      });
    }
    return cols.slice(0, this.MAX_COLUMNS);
  }
};
function clamp01(x) {
  return Math.max(0, Math.min(1, x));
}
function median(a) {
  if (!a.length)
    return 0;
  const s = [...a].sort((x, y) => x - y);
  const m = Math.floor(s.length / 2);
  return s.length % 2 ? s[m] : (s[m - 1] + s[m]) / 2;
}
function stddev(a) {
  if (!a.length)
    return 0;
  if (a.length === 1)
    return 0;
  const mean = a.reduce((s, v) => s + v, 0) / a.length;
  const variance = a.reduce((s, v) => s + (v - mean) * (v - mean), 0) / (a.length - 1);
  return Math.sqrt(variance);
}
function approxUniqueBandCount(y1s) {
  const s = /* @__PURE__ */ new Set();
  for (const y of y1s)
    s.add(Math.round(y));
  return s.size;
}

// grid-detector.ts
var defaultGridSettings = {
  minHorizontalGapLineHeightMultiplier: 1.5,
  projectionProfileThreshold: 1
  // A very low threshold; any pixel presence counts.
};
var GridDetector = class {
  constructor(options = {}) {
    this.settings = { ...defaultGridSettings, ...options };
  }
  /**
   * Analyzes a set of rectangles to detect grid-like structures.
   *
   * @param rects - The bounding rectangles of all text spans on the page.
   * @param pageRect - The bounding rectangle for the entire page.
   * @param estimatedLineHeight - The estimated line height, used for dynamic thresholding.
   * @returns A GridAnalysis object, or null if no grid is detected.
   */
  detectGrid(rects, pageRect, estimatedLineHeight) {
    if (!rects || rects.length < 2) {
      return null;
    }
    const horizontalProfile = this.createProjectionProfile(rects, pageRect, "horizontal");
    const verticalProfile = this.createProjectionProfile(rects, pageRect, "vertical");
    const minGapHeight = estimatedLineHeight * this.settings.minHorizontalGapLineHeightMultiplier;
    const horizontalGaps = this.findGapsInProfile(horizontalProfile, minGapHeight);
    const verticalGaps = this.findGapsInProfile(verticalProfile, estimatedLineHeight);
    const horizontalLines = horizontalGaps.map((gap) => ({
      position: pageRect.top + gap.start + gap.length / 2,
      // Midpoint of the gap
      start: pageRect.left,
      end: pageRect.right
    }));
    const verticalLines = verticalGaps.map((gap) => ({
      position: pageRect.left + gap.start + gap.length / 2,
      // Midpoint
      start: pageRect.top,
      end: pageRect.bottom
    }));
    if (horizontalLines.length === 0) {
      return null;
    }
    return { horizontalLines, verticalLines };
  }
  /**
   * Creates a projection profile (a histogram of pixel occupancy).
   * @param rects - The rectangles to project.
   * @param pageRect - The bounds of the page.
   * @param orientation - 'horizontal' to scan rows, 'vertical' to scan columns.
   * @returns An array of numbers representing the profile.
   */
  createProjectionProfile(rects, pageRect, orientation) {
    const isHorizontal = orientation === "horizontal";
    const profileSize = Math.ceil(isHorizontal ? pageRect.height : pageRect.width);
    const profile = new Array(profileSize).fill(0);
    const offset = isHorizontal ? pageRect.top : pageRect.left;
    for (const rect of rects) {
      const start = Math.floor((isHorizontal ? rect.top : rect.left) - offset);
      const end = Math.ceil((isHorizontal ? rect.bottom : rect.right) - offset);
      const value = isHorizontal ? rect.width : rect.height;
      for (let i = start; i < end; i++) {
        if (i >= 0 && i < profileSize) {
          profile[i] += value;
        }
      }
    }
    return profile;
  }
  /**
   * Finds continuous sequences of near-zero values in a profile.
   * @param profile - The projection profile array.
   * @param minGapSize - The minimum length for a gap to be considered significant.
   * @returns An array of detected gaps with their start and length.
   */
  findGapsInProfile(profile, minGapSize) {
    const gaps = [];
    let gapStart = -1;
    for (let i = 0; i < profile.length; i++) {
      if (profile[i] < this.settings.projectionProfileThreshold) {
        if (gapStart === -1) {
          gapStart = i;
        }
      } else {
        if (gapStart !== -1) {
          const gapLength = i - gapStart;
          if (gapLength >= minGapSize) {
            gaps.push({ start: gapStart, length: gapLength });
          }
          gapStart = -1;
        }
      }
    }
    if (gapStart !== -1) {
      const gapLength = profile.length - gapStart;
      if (gapLength >= minGapSize) {
        gaps.push({ start: gapStart, length: gapLength });
      }
    }
    return gaps;
  }
};

// ParagraphMerger.ts
var ParagraphMerger = class {
  constructor(settings) {
    this.lineHeightMultiplier = settings.lineHeightMultiplier;
    this.debugValidation = settings.debugValidation;
    this.forceLinearMerge = settings.pmForceLinearMerge;
    this.minStripConfidenceSplit = settings.pmMinStripConfidenceSplit;
    this.minStripWidthPx = settings.pmMinStripWidthPx;
    this.minStripOverlapFrac = settings.pmMinStripOverlapFrac;
    this.initialMergeBaselineTolNonMath = settings.pmInitialMergeBaselineTolNonMath;
    this.initialMergeBaselineTolMath = settings.pmInitialMergeBaselineTolMath;
    this.initialMergeKernTolNonMath = settings.pmInitialMergeKernTolNonMath;
    this.initialMergeKernTolMath = settings.pmInitialMergeKernTolMath;
    this.hyphenContinuationTol = settings.pmHyphenContinuationTol;
    this.initialMergeAlignTolNonMath = settings.pmInitialMergeAlignTolNonMath;
    this.initialMergeAlignTolMath = settings.pmInitialMergeAlignTolMath;
    this.initialMergeVerticalGapMultiplier = settings.pmInitialMergeVerticalGapMultiplier;
    this.initialMergeVerticalGapMaxMultiplier = settings.pmInitialMergeVerticalGapMaxMultiplier;
    this.stackedMergeAlignTol = settings.pmStackedMergeAlignTol;
    this.stackedMergeOverlapFrac = settings.pmStackedMergeOverlapFrac;
    this.stackedMergeVerticalGapMultiplier = settings.pmStackedMergeVerticalGapMultiplier;
    this.stackedMergeVerticalGapMaxMultiplier = settings.pmStackedMergeVerticalGapMaxMultiplier;
    this.generalMergeAlignTol = settings.pmGeneralMergeAlignTol;
    this.generalMergeOverlapFrac = settings.pmGeneralMergeOverlapFrac;
    this.generalMergeVerticalGapMultiplier = settings.pmGeneralMergeVerticalGapMultiplier;
    this.generalMergeVerticalGapMaxMultiplier = settings.pmGeneralMergeVerticalGapMaxMultiplier;
    this.nestedMergeOverlapFrac = settings.pmNestedMergeOverlapFrac;
    this.stitchBaselineTolNonMath = settings.pmStitchBaselineTolNonMath;
    this.stitchBaselineTolMath = settings.pmStitchBaselineTolMath;
    this.stitchKernTolNonMath = settings.pmStitchKernTolNonMath;
    this.stitchKernTolMath = settings.pmStitchKernTolMath;
    this.inlineSpanBaselineTol = settings.pmInlineSpanBaselineTol;
    this.inlineSpanKernTol = settings.pmInlineSpanKernTol;
    this.sameColumnCoverageRatio = settings.pmSameColumnCoverageRatio;
    this.mathMergeBaselineTol = settings.pmMathMergeBaselineTol;
    this.mathMergeHorizTol = settings.pmMathMergeHorizTol;
    this.mathMergeCenterTol = settings.pmMathMergeCenterTol;
    this.splitLineHeightTol = settings.pmSplitLineHeightTol;
    this.splitBoundaryDedupTol = settings.pmSplitBoundaryDedupTol;
    this.splitInterWordGapTol = settings.pmSplitInterWordGapTol;
    this.splitColumnGapTol = settings.pmSplitColumnGapTol;
    this.inlineSpanMaxWeightDiff = settings.pmInlineSpanMaxWeightDiff;
    this.inlineSpanAllowMixedStyle = settings.pmInlineSpanAllowMixedStyle;
  }
  // 1) Initial span-to-paragraph grouping (math-aware), no DOM calls
  mergeIntoParagraphsFromInfos(spanInfos) {
    const spans = [...spanInfos.keys()];
    const ordered = spans.sort((a, b) => {
      const ia = spanInfos.get(a).rect;
      const ib = spanInfos.get(b).rect;
      return ia.top - ib.top || ia.left - ib.left;
    });
    const paragraphs = [];
    let current = [];
    for (let i = 0; i < ordered.length; i++) {
      const cur = ordered[i];
      const ci = spanInfos.get(cur);
      if (!current.length) {
        current.push(cur);
        continue;
      }
      const prev = current[current.length - 1];
      const pi = spanInfos.get(prev);
      const sameStyle = this.stylesMatch(ci, pi, true);
      const maxFontSize = Math.max(ci.style.fontSize, pi.style.fontSize);
      const minF = Math.min(ci.style.fontSize, pi.style.fontSize);
      const baseTol = minF * (ci.isMathElement || pi.isMathElement ? this.initialMergeBaselineTolMath : this.initialMergeBaselineTolNonMath);
      const sameBaseline = Math.abs(ci.rect.bottom - pi.rect.bottom) < baseTol;
      const isRTL = ci.style.direction === "rtl" || pi.style.direction === "rtl";
      const dx = ci.rect.left - pi.rect.right;
      const kernTol = minF * (ci.isMathElement || pi.isMathElement ? this.initialMergeKernTolMath : this.initialMergeKernTolNonMath);
      const smallInlineKerning = sameBaseline && (isRTL ? dx <= 0 && dx > -kernTol : dx >= 0 && dx < kernTol);
      const prevText = (pi.text || "").trim();
      const endsWithHyphen = /[\u00AD-]$/.test(prevText);
      const hyphenContinuation = endsWithHyphen && ci.rect.top > pi.rect.top && Math.abs(ci.rect.left - pi.rect.left) < ci.style.fontSize * this.hyphenContinuationTol;
      const leftAlignTol = minF * (ci.isMathElement || pi.isMathElement ? this.initialMergeAlignTolMath : this.initialMergeAlignTolNonMath);
      const rightAlignTol = leftAlignTol;
      const leftAligned = Math.abs(ci.rect.left - pi.rect.left) < leftAlignTol;
      const rightAligned = Math.abs(ci.rect.right - pi.rect.right) < rightAlignTol;
      const lineHeightGuess = maxFontSize * this.lineHeightMultiplier;
      const verticalTolerance = Math.min(
        lineHeightGuess * this.initialMergeVerticalGapMultiplier,
        maxFontSize * this.initialMergeVerticalGapMaxMultiplier
      );
      const verticalGap = ci.rect.top - pi.rect.bottom;
      if (sameStyle && (verticalGap <= verticalTolerance && (leftAligned || rightAligned) || smallInlineKerning || hyphenContinuation)) {
        current.push(cur);
      } else {
        paragraphs.push(current);
        current = [cur];
      }
    }
    if (current.length)
      paragraphs.push(current);
    return paragraphs;
  }
  // 2) Split paragraphs if they cross vertical strips (with noise gating)
  validateParagraphsAgainstStripsFromInfos(paragraphs, spanInfos, verticalStrips = [], lineHeight = 0, viewportWidth) {
    if (this.forceLinearMerge) {
      return paragraphs;
    }
    if (!(verticalStrips == null ? void 0 : verticalStrips.length))
      return paragraphs;
    const results = [];
    const filteredStrips = this.filterStrips(verticalStrips, viewportWidth);
    if (!filteredStrips.length)
      return paragraphs;
    for (const para of paragraphs) {
      const parts = this.splitParagraphByStrips(para, spanInfos, filteredStrips, lineHeight);
      results.push(...parts);
    }
    return results;
  }
  // 3) Merge vertically stacked paragraphs within the same column and style, respecting gaps
  mergeParagraphsFromInfos(paragraphs, spanInfos, lineHeight, verticalStrips = [], horizontalBands = [], viewportWidth) {
    const merged = [];
    const used = /* @__PURE__ */ new Set();
    const filteredStrips = this.filterStrips(verticalStrips, viewportWidth);
    for (let i = 0; i < paragraphs.length; i++) {
      if (used.has(i))
        continue;
      let current = [...paragraphs[i]];
      const currStyle = spanInfos.get(current[0]).style;
      const currBbox = this.getParaBbox(current, spanInfos);
      for (let j = i + 1; j < paragraphs.length; j++) {
        if (used.has(j))
          continue;
        const next = paragraphs[j];
        const nextStyle = spanInfos.get(next[0]).style;
        if (!this.stylesMatchStyle(currStyle, nextStyle, true))
          continue;
        const nextBbox = this.getParaBbox(next, spanInfos);
        if (!this.sameColumnByStrips(currBbox, nextBbox, filteredStrips))
          continue;
        if (this.hasHorizontalBandBetween(currBbox, nextBbox, horizontalBands))
          continue;
        const verticalGap = nextBbox.top - currBbox.bottom;
        const horizontalOverlap = currBbox.left < nextBbox.right && currBbox.right > nextBbox.left;
        const overlapWidth = Math.max(0, Math.min(currBbox.right, nextBbox.right) - Math.max(currBbox.left, nextBbox.left));
        const minParaWidth = Math.max(1, Math.min(currBbox.width, nextBbox.width));
        const overlapStrong = horizontalOverlap && overlapWidth > this.generalMergeOverlapFrac * minParaWidth;
        const leftAlignTol = currStyle.fontSize * this.generalMergeAlignTol;
        const leftAligned = Math.abs(currBbox.left - nextBbox.left) < leftAlignTol;
        const rightAligned = Math.abs(currBbox.right - nextBbox.right) < leftAlignTol;
        const aligned = leftAligned || rightAligned;
        const mergeThreshold = Math.min(lineHeight * this.generalMergeVerticalGapMultiplier, Math.max(currStyle.fontSize, nextStyle.fontSize) * this.generalMergeVerticalGapMaxMultiplier);
        const permissiveAlignment = this.forceLinearMerge || (aligned || overlapStrong);
        if (verticalGap <= mergeThreshold && permissiveAlignment) {
          current.push(...next);
          used.add(j);
          const newBbox = this.getParaBbox(current, spanInfos);
          Object.assign(currBbox, newBbox);
        }
      }
      merged.push(current);
      used.add(i);
    }
    return merged;
  }
  // 3.5) Merge stacked column-aligned paragraphs (final stacked pass)
  mergeStackedColumnParagraphsFromInfos(paragraphs, spanInfos, lineHeight, verticalStrips = [], horizontalBands = [], viewportWidth) {
    if (!paragraphs.length)
      return paragraphs;
    const filteredStrips = this.filterStrips(verticalStrips, viewportWidth);
    const infos = paragraphs.map((spans) => {
      const bbox = this.getParaBbox(spans, spanInfos);
      const style = spanInfos.get(spans[0]).style;
      const isMath = spans.some((s) => spanInfos.get(s).isMathElement);
      return { spans, bbox, style, isMath };
    });
    infos.sort((a, b) => a.bbox.top - b.bbox.top || a.bbox.left - b.bbox.left);
    let changed = true;
    while (changed) {
      changed = false;
      const used = /* @__PURE__ */ new Set();
      const out = [];
      for (let i = 0; i < infos.length; i++) {
        if (used.has(i))
          continue;
        let base = infos[i];
        for (let j = i + 1; j < infos.length; j++) {
          if (used.has(j))
            continue;
          const cand = infos[j];
          if (!this.stylesMatchStyle(base.style, cand.style, true))
            continue;
          if (!this.sameColumnByStrips(base.bbox, cand.bbox, filteredStrips))
            continue;
          if (this.hasHorizontalBandBetween(base.bbox, cand.bbox, horizontalBands))
            continue;
          const verticalGap = cand.bbox.top - base.bbox.bottom;
          if (verticalGap < 0)
            continue;
          const horizontalOverlap = base.bbox.left < cand.bbox.right && base.bbox.right > cand.bbox.left;
          const overlapWidth = Math.max(0, Math.min(base.bbox.right, cand.bbox.right) - Math.max(base.bbox.left, cand.bbox.left));
          const minParaWidth = Math.max(1, Math.min(base.bbox.width, cand.bbox.width));
          const overlapStrong = horizontalOverlap && overlapWidth > this.stackedMergeOverlapFrac * minParaWidth;
          const leftAlignTol = Math.max(1, Math.min(base.style.fontSize, cand.style.fontSize) * this.stackedMergeAlignTol);
          const leftAligned = Math.abs(base.bbox.left - cand.bbox.left) < leftAlignTol;
          const rightAligned = Math.abs(base.bbox.right - cand.bbox.right) < leftAlignTol;
          const aligned = leftAligned || rightAligned;
          const maxFontSize = Math.max(base.style.fontSize, cand.style.fontSize);
          const mergeThreshold = Math.min(lineHeight * this.stackedMergeVerticalGapMultiplier, maxFontSize * this.stackedMergeVerticalGapMaxMultiplier);
          const permissiveAlignment = this.forceLinearMerge || (aligned || overlapStrong);
          if (permissiveAlignment && verticalGap <= mergeThreshold) {
            const combinedSpans = [...base.spans, ...cand.spans].map((s) => ({ s, r: spanInfos.get(s).rect })).sort((a, b) => a.r.top - b.r.top || a.r.left - b.r.left).map((x) => x.s);
            base = {
              spans: combinedSpans,
              bbox: this.getParaBbox(combinedSpans, spanInfos),
              style: base.style,
              isMath: combinedSpans.some((s) => spanInfos.get(s).isMathElement)
            };
            used.add(j);
            changed = true;
          }
        }
        out.push(base);
        used.add(i);
      }
      if (changed) {
        infos.length = 0;
        infos.push(...out.sort((a, b) => a.bbox.top - b.bbox.top || a.bbox.left - b.bbox.left));
      } else {
        return out.map((p) => p.spans);
      }
    }
    return paragraphs;
  }
  // 4) Single-pass nested/overlap merging, math-aware, respecting strips
  mergeNestedParagraphsOnceFromInfos(paragraphs, spanInfos, verticalStrips = [], horizontalBands = [], viewportWidth) {
    if (!paragraphs.length)
      return { paragraphs, changed: false };
    const filteredStrips = this.filterStrips(verticalStrips, viewportWidth);
    const infos = paragraphs.map((p) => {
      const bbox = this.getParaBbox(p, spanInfos);
      const style = spanInfos.get(p[0]).style;
      const isMath = p.some((s) => spanInfos.get(s).isMathElement);
      const text = p.map((s) => spanInfos.get(s).text).join("");
      return { spans: [...p], bbox, style, isMath, text };
    });
    let changed = false;
    const used = /* @__PURE__ */ new Set();
    const out = [];
    for (let i = 0; i < infos.length; i++) {
      if (used.has(i))
        continue;
      let base = infos[i];
      let merged = false;
      for (let j = 0; j < infos.length; j++) {
        if (i === j || used.has(j))
          continue;
        const cand = infos[j];
        if (!this.stylesMatchStyle(base.style, cand.style, true))
          continue;
        if (!this.sameColumnByStrips(base.bbox, cand.bbox, filteredStrips))
          continue;
        if (this.hasHorizontalBandBetween(base.bbox, cand.bbox, horizontalBands))
          continue;
        const containsIJ = this.rectContains(base.bbox, cand.bbox, 1);
        const containsJI = this.rectContains(cand.bbox, base.bbox, 1);
        let strongOverlap = false;
        if (!containsIJ && !containsJI) {
          const inter = this.rectIntersection(base.bbox, cand.bbox);
          if (inter) {
            const interArea = inter.width * inter.height;
            const smaller = Math.min(this.area(base.bbox), this.area(cand.bbox)) || 1;
            strongOverlap = interArea / smaller > this.nestedMergeOverlapFrac;
          }
        }
        const mathMerge = (base.isMath || cand.isMath) && this.isMathMergeCandidate(base, cand, filteredStrips);
        if (containsIJ || containsJI || strongOverlap || mathMerge) {
          const baseLarger = this.area(base.bbox) >= this.area(cand.bbox);
          const keep = baseLarger ? base : cand;
          const add = baseLarger ? cand : base;
          const combined = [...keep.spans, ...add.spans].map((s) => ({ s, r: spanInfos.get(s).rect })).sort((a, b) => a.r.top - b.r.top || a.r.left - b.r.left).map((x) => x.s);
          base = {
            spans: combined,
            bbox: this.getParaBbox(combined, spanInfos),
            style: keep.style,
            isMath: combined.some((s) => spanInfos.get(s).isMathElement),
            text: combined.map((s) => spanInfos.get(s).text).join("")
          };
          used.add(i);
          used.add(j);
          merged = true;
          changed = true;
          break;
        }
      }
      out.push(base.spans);
      if (!merged)
        used.add(i);
    }
    return { paragraphs: out, changed };
  }
  // 5) Inline ligature/fragment stitching at same baseline
  stitchInlineLigaturesFromInfos(paragraphs, spanInfos) {
    if (!paragraphs.length)
      return paragraphs;
    const results = [];
    for (const p of paragraphs) {
      if (p.length < 2) {
        results.push(p);
        continue;
      }
      const ordered = p.map((s) => ({ s, info: spanInfos.get(s) })).sort((a, b) => a.info.rect.top - b.info.rect.top || a.info.rect.left - b.info.rect.left);
      const stitched = [];
      let group = [ordered[0].s];
      for (let i = 1; i < ordered.length; i++) {
        const prevI = ordered[i - 1].info;
        const curI = ordered[i].info;
        const sameStyle = this.stylesMatch(prevI, curI, true);
        const minF = Math.min(prevI.style.fontSize, curI.style.fontSize);
        const baseTol = minF * (prevI.isMathElement || curI.isMathElement ? this.stitchBaselineTolMath : this.stitchBaselineTolNonMath);
        const baselineClose = Math.abs(prevI.rect.bottom - curI.rect.bottom) < baseTol;
        const dx = curI.rect.left - prevI.rect.right;
        const kernTol = minF * (prevI.isMathElement || curI.isMathElement ? this.stitchKernTolMath : this.stitchKernTolNonMath);
        if (sameStyle && baselineClose && dx >= 0 && dx < kernTol) {
          group.push(ordered[i].s);
        } else {
          stitched.push(...group);
          group = [ordered[i].s];
        }
      }
      stitched.push(...group);
      results.push(stitched);
    }
    return results;
  }
  /**
   * Merge nested inline spans (cursive/bold) that share the same line and font family
   * back into their parent paragraphs.
   */
  mergeNestedInlineSpansFromInfos(paragraphs, spanInfos) {
    if (!paragraphs.length)
      return paragraphs;
    const results = [];
    for (const paragraph of paragraphs) {
      if (paragraph.length <= 1) {
        results.push([...paragraph]);
        continue;
      }
      const paraStyle = spanInfos.get(paragraph[0]).style;
      const sortedSpans = [...paragraph].sort((a, b) => {
        const rectA = spanInfos.get(a).rect;
        const rectB = spanInfos.get(b).rect;
        return rectA.top - rectB.top || rectA.left - rectB.left;
      });
      const lines = [];
      let currentLine = [];
      let currentLineTop = -Infinity;
      const lineHeightTolerance = paraStyle.fontSize * this.splitLineHeightTol;
      for (const span of sortedSpans) {
        const spanInfo = spanInfos.get(span);
        const spanTop = spanInfo.rect.top;
        if (currentLine.length === 0 || Math.abs(spanTop - currentLineTop) > lineHeightTolerance) {
          if (currentLine.length > 0) {
            lines.push(currentLine);
          }
          currentLine = [span];
          currentLineTop = spanTop;
        } else {
          currentLine.push(span);
        }
      }
      if (currentLine.length > 0) {
        lines.push(currentLine);
      }
      const mergedSpans = [];
      for (const line of lines) {
        if (line.length <= 1) {
          mergedSpans.push(...line);
          continue;
        }
        const lineSpans = [...line].sort((a, b) => {
          return spanInfos.get(a).rect.left - spanInfos.get(b).rect.left;
        });
        let currentGroup = [lineSpans[0]];
        for (let i = 1; i < lineSpans.length; i++) {
          const prevSpan = currentGroup[currentGroup.length - 1];
          const currentSpan = lineSpans[i];
          const prevInfo = spanInfos.get(prevSpan);
          const currentInfo = spanInfos.get(currentSpan);
          const baselineTolerance = Math.min(prevInfo.style.fontSize, currentInfo.style.fontSize) * this.inlineSpanBaselineTol;
          const sameBaseline = Math.abs(prevInfo.rect.bottom - currentInfo.rect.bottom) < baselineTolerance;
          const horizontalGap = currentInfo.rect.left - prevInfo.rect.right;
          const kerningTolerance = Math.min(prevInfo.style.fontSize, currentInfo.style.fontSize) * this.inlineSpanKernTol;
          const closeHorizontally = Math.abs(horizontalGap) <= kerningTolerance;
          const stylesAreCompatible = this.stylesMatch(prevInfo, currentInfo, true);
          if (sameBaseline && closeHorizontally && stylesAreCompatible) {
            currentGroup.push(currentSpan);
          } else {
            mergedSpans.push(...this.mergeSpanGroup(currentGroup, spanInfos));
            currentGroup = [currentSpan];
          }
        }
        mergedSpans.push(...this.mergeSpanGroup(currentGroup, spanInfos));
      }
      results.push(mergedSpans);
    }
    return results;
  }
  // -----------------------
  // Internal helpers
  // -----------------------
  getNumericFontWeight(weight) {
    if (typeof weight === "number")
      return weight;
    if (weight === "normal")
      return 400;
    if (weight === "bold")
      return 700;
    const numericWeight = parseInt(weight, 10);
    return isNaN(numericWeight) ? 400 : numericWeight;
  }
  isCursiveOrBoldSpan(spanInfo) {
    const isCursive = spanInfo.style.fontStyle === "italic" || spanInfo.style.fontStyle === "oblique";
    const isBold = spanInfo.style.fontWeight === "bold" || typeof spanInfo.style.fontWeight === "number" && spanInfo.style.fontWeight >= 600;
    return isCursive || isBold;
  }
  mergeSpanGroup(spans, spanInfos) {
    return spans.sort((a, b) => {
      const rectA = spanInfos.get(a).rect;
      const rectB = spanInfos.get(b).rect;
      return rectA.top - rectB.top || rectA.left - rectB.left;
    });
  }
  stylesMatch(a, b, mathAware = true) {
    return this.stylesMatchStyle(a.style, b.style, mathAware);
  }
  /**
   * OVERHAULED: Matches styles, but strictly returns TRUE if forceLinearMerge is on.
   */
  stylesMatchStyle(a, b, mathAware = true) {
    if (this.forceLinearMerge)
      return true;
    if (mathAware && (a.isMathElement || b.isMathElement)) {
      if (a.fontFamily !== b.fontFamily)
        return false;
      if (a.fontStyle !== b.fontStyle)
        return false;
      if (a.fontWeight !== b.fontWeight)
        return false;
      if (Math.abs(a.fontSize - b.fontSize) > 1)
        return false;
      const dist = Math.hypot(
        a.colorRGB[0] - b.colorRGB[0],
        a.colorRGB[1] - b.colorRGB[1],
        a.colorRGB[2] - b.colorRGB[2]
      );
      return dist < 10;
    }
    if (a.fontFamily !== b.fontFamily)
      return false;
    if (Math.abs(a.fontSize - b.fontSize) > 1)
      return false;
    const colorDist = Math.hypot(
      a.colorRGB[0] - b.colorRGB[0],
      a.colorRGB[1] - b.colorRGB[1],
      a.colorRGB[2] - b.colorRGB[2]
    );
    if (colorDist >= 10)
      return false;
    const weightDiff = Math.abs(
      this.getNumericFontWeight(a.fontWeight) - this.getNumericFontWeight(b.fontWeight)
    );
    if (weightDiff > this.inlineSpanMaxWeightDiff) {
      return false;
    }
    if (!this.inlineSpanAllowMixedStyle && a.fontStyle !== b.fontStyle) {
      return false;
    }
    return true;
  }
  getParaBbox(spans, infos) {
    let left = Infinity, top = Infinity, right = -Infinity, bottom = -Infinity;
    for (const s of spans) {
      const r = infos.get(s).rect;
      if (r.left < left)
        left = r.left;
      if (r.top < top)
        top = r.top;
      if (r.right > right)
        right = r.right;
      if (r.bottom > bottom)
        bottom = r.bottom;
    }
    if (left === Infinity)
      return { left: 0, top: 0, right: 0, bottom: 0, width: 0, height: 0 };
    return { left, top, right, bottom, width: right - left, height: bottom - top };
  }
  sameColumnByStrips(a, b, strips) {
    if (this.forceLinearMerge)
      return true;
    if (!(strips == null ? void 0 : strips.length)) {
      const horizontalOverlap2 = Math.max(0, Math.min(a.right, b.right) - Math.max(a.left, b.left));
      const minWidth = Math.min(a.width, b.width) * 0.3;
      const maxReasonableColumnWidth = Math.max(a.width, b.width) * 3;
      const horizontalDistance = Math.abs((a.left + a.right) / 2 - (b.left + b.right) / 2);
      return horizontalOverlap2 > minWidth && horizontalDistance < maxReasonableColumnWidth;
    }
    const yTop = Math.min(a.top, b.top);
    const yBot = Math.max(a.bottom, b.bottom);
    const totalHeight = yBot - yTop;
    if (totalHeight <= 0)
      return true;
    const [leftPara, rightPara] = a.left < b.left ? [a, b] : [b, a];
    const horizontalOverlap = Math.max(0, Math.min(a.right, b.right) - Math.max(a.left, b.left));
    const minWidthOverlap = Math.min(a.width, b.width) * 0.3;
    if (horizontalOverlap > minWidthOverlap)
      return true;
    const gapLeft = leftPara.right;
    const gapRight = rightPara.left;
    const gapWidth = gapRight - gapLeft;
    if (gapWidth <= 0)
      return true;
    let totalStripCoverage = 0;
    const minStripCoverage = Math.max(3, gapWidth * 0.1);
    const minVerticalAlignment = this.minStripOverlapFrac;
    for (const s of strips) {
      if (s.confidence < this.minStripConfidenceSplit)
        continue;
      if (s.right - s.left < this.minStripWidthPx)
        continue;
      const stripHeight = s.bottom - s.top;
      const yOverlap = Math.min(yBot, s.bottom) - Math.max(yTop, s.top);
      const verticalAlignment = yOverlap / stripHeight;
      if (verticalAlignment < minVerticalAlignment)
        continue;
      const stripInGap = Math.max(
        0,
        Math.min(s.right, gapRight) - Math.max(s.left, gapLeft)
      );
      if (stripInGap >= minStripCoverage) {
        totalStripCoverage += stripInGap;
      }
    }
    const coverageRatio = totalStripCoverage / gapWidth;
    return coverageRatio < this.sameColumnCoverageRatio;
  }
  hasHorizontalBandBetween(a, b, bands = []) {
    if (this.forceLinearMerge)
      return false;
    if (!(bands == null ? void 0 : bands.length))
      return false;
    const top = Math.min(a.bottom, b.bottom);
    const bottom = Math.max(a.top, b.top);
    for (const band of bands) {
      if (band.confidence < 0.6)
        continue;
      const within = band.y > top && band.y + band.height < bottom;
      if (within)
        return true;
    }
    return false;
  }
  rectContains(a, b, tol = 1) {
    return a.left - tol <= b.left && a.right + tol >= b.right && a.top - tol <= b.top && a.bottom + tol >= b.bottom;
  }
  rectIntersection(a, b) {
    const left = Math.max(a.left, b.left);
    const top = Math.max(a.top, b.top);
    const right = Math.min(a.right, b.right);
    const bottom = Math.min(a.bottom, b.bottom);
    if (right <= left || bottom <= top)
      return null;
    return { left, top, right, bottom, width: right - left, height: bottom - top };
  }
  area(r) {
    return Math.max(0, r.width) * Math.max(0, r.height);
  }
  isMathMergeCandidate(a, b, strips) {
    const fontSize = Math.max(a.style.fontSize, b.style.fontSize) || 12;
    const verticalProximity = Math.abs(a.bbox.top - b.bbox.top) < fontSize * this.mathMergeBaselineTol;
    const horizontalProximity = Math.abs(a.bbox.left - b.bbox.left) < fontSize * this.mathMergeHorizTol;
    if (!this.sameColumnByStrips(a.bbox, b.bbox, strips))
      return false;
    const opRe = /[=+\-]/;
    const aIsOp = !!(a.text && opRe.test(a.text));
    const bIsOp = !!(b.text && opRe.test(b.text));
    if (aIsOp || bIsOp)
      return verticalProximity && horizontalProximity;
    const centerA = (a.bbox.left + a.bbox.right) / 2;
    const centerB = (b.bbox.left + b.bbox.right) / 2;
    return verticalProximity && Math.abs(centerA - centerB) < fontSize * this.mathMergeCenterTol;
  }
  splitParagraphByStrips(paragraph, infos, strips, lineHeight = 0) {
    if (!paragraph.length || !strips.length)
      return [paragraph];
    const paraBbox = this.getParaBbox(paragraph, infos);
    const sorted = [...paragraph].sort((a, b) => {
      const ra = infos.get(a).rect;
      const rb = infos.get(b).rect;
      return ra.top - rb.top || ra.left - rb.left;
    });
    const columnBoundaries = [];
    let currentLineTop = -Infinity;
    let currentLineSpans = [];
    for (const span of sorted) {
      const rect = infos.get(span).rect;
      if (currentLineTop === -Infinity || Math.abs(rect.top - currentLineTop) > lineHeight * this.splitLineHeightTol) {
        if (currentLineSpans.length > 1) {
          this.processLineForColumnBoundaries(currentLineSpans, columnBoundaries, lineHeight);
        }
        currentLineTop = rect.top;
        currentLineSpans = [{ span, rect }];
      } else {
        currentLineSpans.push({ span, rect });
      }
    }
    if (currentLineSpans.length > 1) {
      this.processLineForColumnBoundaries(currentLineSpans, columnBoundaries, lineHeight);
    }
    if (columnBoundaries.length === 0)
      return [paragraph];
    columnBoundaries.sort((a, b) => a - b);
    const uniqueBoundaries = [columnBoundaries[0]];
    for (let i = 1; i < columnBoundaries.length; i++) {
      if (columnBoundaries[i] - uniqueBoundaries[uniqueBoundaries.length - 1] > lineHeight * this.splitBoundaryDedupTol) {
        uniqueBoundaries.push(columnBoundaries[i]);
      }
    }
    const boundaries = [paraBbox.left, ...uniqueBoundaries, paraBbox.right];
    const regions = [];
    for (let i = 0; i < boundaries.length - 1; i++) {
      regions.push({ left: boundaries[i], right: boundaries[i + 1] });
    }
    const buckets = regions.map(() => []);
    for (const span of sorted) {
      const rect = infos.get(span).rect;
      const cx = (rect.left + rect.right) / 2;
      let regionIndex = regions.findIndex((r) => cx >= r.left && cx < r.right);
      if (regionIndex === -1) {
        regionIndex = cx < regions[0].left ? 0 : regions.length - 1;
      }
      if (regionIndex >= 0 && regionIndex < regions.length) {
        buckets[regionIndex].push(span);
      }
    }
    const groups = [];
    for (const bucket of buckets) {
      if (bucket.length === 0)
        continue;
      bucket.sort((a, b) => {
        const ra = infos.get(a).rect;
        const rb = infos.get(b).rect;
        return ra.top - rb.top || ra.left - rb.left;
      });
      groups.push(bucket);
    }
    return groups.length > 1 ? groups : [paragraph];
  }
  processLineForColumnBoundaries(lineSpans, columnBoundaries, lineHeight) {
    lineSpans.sort((a, b) => a.rect.left - b.rect.left);
    for (let i = 1; i < lineSpans.length; i++) {
      const prev = lineSpans[i - 1].rect;
      const curr = lineSpans[i].rect;
      const gap = curr.left - prev.right;
      const fontSize = Math.min(prev.height, curr.height) * 0.8;
      const maxInterWordGap = fontSize * this.splitInterWordGapTol;
      const minColumnGap = fontSize * this.splitColumnGapTol;
      if (gap > minColumnGap && gap > maxInterWordGap) {
        const gapCenter = (prev.right + curr.left) / 2;
        columnBoundaries.push(gapCenter);
      }
    }
  }
  filterStrips(strips, viewportWidth) {
    if (!(strips == null ? void 0 : strips.length))
      return [];
    return strips.filter((s) => {
      const width = s.right - s.left;
      const height = s.bottom - s.top;
      if (width < viewportWidth * 3e-3)
        return false;
      const minHeight = Math.max(12, height * 0.7);
      if (height < minHeight)
        return false;
      return s.confidence >= this.minStripConfidenceSplit && width >= this.minStripWidthPx && height > 0;
    });
  }
};

// Snapshot.ts
var MATH_FONT_RE = /math|cambria|stix|asana|euler|latin modern/i;
var MATH_CHAR_RE = /[=+\-%]|[\u0370-\u03FF\u2070-\u209F]/;
function parseColorToRGB(color) {
  if (!color)
    return [0, 0, 0];
  const m = color.match(/rgba?\(\s*(\d+)[,\s]+(\d+)[,\s]+(\d+)/i);
  if (m)
    return [parseInt(m[1]), parseInt(m[2]), parseInt(m[3])];
  const hex = color.trim().toLowerCase();
  if (/^#([0-9a-f]{3}){1,2}$/i.test(hex)) {
    if (hex.length === 4) {
      return [
        parseInt(hex[1] + hex[1], 16),
        parseInt(hex[2] + hex[2], 16),
        parseInt(hex[3] + hex[3], 16)
      ];
    }
    return [
      parseInt(hex.slice(1, 3), 16),
      parseInt(hex.slice(3, 5), 16),
      parseInt(hex.slice(5, 7), 16)
    ];
  }
  return [0, 0, 0];
}
function normalizeWeight(weight) {
  const num = parseInt(weight, 10);
  if (!isNaN(num))
    return num;
  const w = (weight || "").toLowerCase();
  if (w === "bold")
    return 700;
  if (w === "normal")
    return 400;
  return 400;
}
function isMathContentFont(fontFamily) {
  return MATH_FONT_RE.test(fontFamily || "");
}
function isMathElementText(text, fontFamily) {
  if (!text)
    return false;
  if (isMathContentFont(fontFamily))
    return true;
  return MATH_CHAR_RE.test(text);
}
function determineMathContext(text, fontFamily) {
  if (isMathElementText(text, fontFamily)) {
    return text.includes("=") || text.includes("\u2211") ? "equation" : "inline";
  }
  return "none";
}
function buildSnapshot(spans) {
  const dpr = window.devicePixelRatio || 1;
  const map = /* @__PURE__ */ new Map();
  for (const s of spans) {
    const rectRaw = s.getBoundingClientRect();
    const rect = new DOMRect(
      rectRaw.left / dpr,
      rectRaw.top / dpr,
      rectRaw.width / dpr,
      rectRaw.height / dpr
    );
    const style = window.getComputedStyle(s);
    const fontSize = (parseFloat(style.fontSize) || 12) / dpr;
    const fontWeight = normalizeWeight(style.fontWeight);
    const colorRGB = parseColorToRGB(style.color);
    const text = s.textContent || "";
    const isMath = isMathElementText(text, style.fontFamily);
    const mathContext = determineMathContext(text, style.fontFamily);
    const fontSizeRounded = Math.round(fontSize * 2) / 2;
    const styleSig = [
      style.fontFamily,
      fontSizeRounded.toFixed(1),
      fontWeight,
      style.fontStyle,
      `${colorRGB[0]},${colorRGB[1]},${colorRGB[2]}`
    ].join("|");
    const normStyle = {
      fontFamily: style.fontFamily,
      fontSize,
      fontWeight,
      fontStyle: style.fontStyle,
      color: style.color,
      colorRGB,
      styleSig
    };
    map.set(s, {
      span: s,
      rect,
      style: normStyle,
      isMathElement: isMath,
      mathContext,
      text
    });
  }
  return map;
}

// layout-modal.ts
var defaultLayoutSettings = {
  lineHeightMultiplier: 1.6,
  minStripConfidence: 0.7,
  minStripWidthPx: 4,
  debugValidation: false,
  maxIterMerges: 10,
  minBandConfidence: 0.6,
  bandTopBottomThresholdMultiplier: 0.75,
  inferredBandConfidence: 0.8,
  bandMergeGapPx: 2,
  bandMergeGapLineHeightMultiplier: 0.2,
  maxGapFractionOfPageHeight: 0.5,
  minGapsForTrim: 5,
  trimPercent: 0.15,
  lineHeightFromAvgMultiplier: 1.25,
  floorMultiplier: 0.8,
  minOverlapFracForBand: 0.4,
  minRegionWidth: 1,
  columnThresholdLineHeightMultiplier: 2,
  columnThresholdFallback: 20,
  // -- Paragraph Merger Defaults --
  pmForceLinearMerge: false,
  // Default: Off
  pmMinStripConfidenceSplit: 0.7,
  pmMinStripWidthPx: 6,
  pmMinStripOverlapFrac: 0.6,
  pmInitialMergeBaselineTolNonMath: 0.45,
  pmInitialMergeBaselineTolMath: 0.75,
  pmInitialMergeKernTolNonMath: 0.55,
  pmInitialMergeKernTolMath: 0.9,
  pmHyphenContinuationTol: 1.8,
  pmInitialMergeAlignTolNonMath: 2,
  pmInitialMergeAlignTolMath: 2,
  pmInitialMergeVerticalGapMultiplier: 1.3,
  pmInitialMergeVerticalGapMaxMultiplier: 2.2,
  pmStackedMergeAlignTol: 2,
  pmStackedMergeOverlapFrac: 0.25,
  pmStackedMergeVerticalGapMultiplier: 1.35,
  pmStackedMergeVerticalGapMaxMultiplier: 2,
  pmGeneralMergeAlignTol: 2,
  pmGeneralMergeOverlapFrac: 0.25,
  pmGeneralMergeVerticalGapMultiplier: 1.35,
  pmGeneralMergeVerticalGapMaxMultiplier: 2,
  pmNestedMergeOverlapFrac: 0.7,
  pmStitchBaselineTolNonMath: 0.45,
  pmStitchBaselineTolMath: 0.75,
  pmStitchKernTolNonMath: 0.55,
  pmStitchKernTolMath: 0.9,
  pmInlineSpanBaselineTol: 0.3,
  pmInlineSpanKernTol: 0.6,
  pmInlineSpanMaxWeightDiff: 300,
  pmInlineSpanAllowMixedStyle: true,
  pmSameColumnCoverageRatio: 0.65,
  pmMathMergeBaselineTol: 2,
  pmMathMergeHorizTol: 1.5,
  pmMathMergeCenterTol: 2.5,
  pmSplitLineHeightTol: 0.7,
  pmSplitBoundaryDedupTol: 0.3,
  pmSplitInterWordGapTol: 1.2,
  pmSplitColumnGapTol: 2.5
};
var PRESETS_STORAGE_KEY = "layoutSettingsPresets";
var PresetManager = class {
  static getAllPresets() {
    try {
      const stored = localStorage.getItem(PRESETS_STORAGE_KEY);
      if (!stored)
        return [];
      const presets = JSON.parse(stored);
      return presets.map((preset) => ({
        ...preset,
        createdAt: new Date(preset.createdAt),
        updatedAt: new Date(preset.updatedAt)
      }));
    } catch (error) {
      console.error("Error loading presets:", error);
      return [];
    }
  }
  static savePreset(preset) {
    const allPresets = this.getAllPresets();
    const now = new Date();
    const newPreset = {
      id: preset.id || Date.now().toString(),
      name: preset.name,
      settings: preset.settings,
      createdAt: preset.createdAt || now,
      updatedAt: now
    };
    const existingIndex = allPresets.findIndex((p) => p.id === newPreset.id);
    if (existingIndex >= 0) {
      newPreset.createdAt = allPresets[existingIndex].createdAt;
      allPresets[existingIndex] = newPreset;
    } else {
      allPresets.push(newPreset);
    }
    localStorage.setItem(PRESETS_STORAGE_KEY, JSON.stringify(allPresets));
    return newPreset;
  }
  static deletePreset(id) {
    const allPresets = this.getAllPresets();
    const filteredPresets = allPresets.filter((preset) => preset.id !== id);
    if (filteredPresets.length < allPresets.length) {
      localStorage.setItem(PRESETS_STORAGE_KEY, JSON.stringify(filteredPresets));
      return true;
    }
    return false;
  }
  static getPresetById(id) {
    const allPresets = this.getAllPresets();
    return allPresets.find((preset) => preset.id === id);
  }
};
function showLayoutSettingsModal(currentSettings = defaultLayoutSettings, onSave) {
  const EXISTING_MODAL_ID = "layout-settings-modal-container";
  if (document.getElementById(EXISTING_MODAL_ID)) {
    return;
  }
  const UID = Math.random().toString(36).substring(2, 9);
  const dialog = document.createElement("dialog");
  dialog.id = EXISTING_MODAL_ID;
  dialog.style.padding = "20px";
  dialog.style.border = "1px solid var(--background-modifier-border, #ccc)";
  dialog.style.borderRadius = "8px";
  dialog.style.maxWidth = "700px";
  dialog.style.width = "90%";
  dialog.style.overflowY = "auto";
  dialog.style.maxHeight = "85vh";
  dialog.style.backgroundColor = "var(--background-primary, #ffffff)";
  dialog.style.color = "var(--text-normal, #000000)";
  dialog.style.fontFamily = "var(--font-interface, sans-serif)";
  dialog.style.boxShadow = "0 10px 40px rgba(0,0,0,0.3)";
  dialog.style.zIndex = "9999";
  const style = document.createElement("style");
  style.textContent = `
    .toggle-switch { position: relative; display: inline-block; width: 44px; height: 24px; justify-self: start; }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
    .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
    input:checked + .slider { background-color: var(--interactive-accent, #007acc); }
    input:focus + .slider { box-shadow: 0 0 1px var(--interactive-accent, #007acc); }
    input:checked + .slider:before { transform: translateX(20px); }
  `;
  dialog.appendChild(style);
  const form = document.createElement("form");
  form.style.display = "grid";
  form.style.gap = "10px";
  form.onsubmit = (e) => e.preventDefault();
  const title = document.createElement("h2");
  title.textContent = "Adjust Layout Settings";
  title.style.marginTop = "0";
  form.appendChild(title);
  const presetSection = document.createElement("div");
  presetSection.style.border = "1px solid var(--background-modifier-border, #ddd)";
  presetSection.style.borderRadius = "4px";
  presetSection.style.padding = "15px";
  presetSection.style.marginBottom = "15px";
  presetSection.style.backgroundColor = "var(--background-secondary, #f9f9f9)";
  const presetTitle = document.createElement("h3");
  presetTitle.textContent = "Presets";
  presetTitle.style.marginTop = "0";
  presetTitle.style.marginBottom = "10px";
  presetSection.appendChild(presetTitle);
  const getCurrentFormValues = () => {
    const newSettings = {};
    for (const key in defaultLayoutSettings) {
      const input = form.elements.namedItem(key);
      if (input) {
        if (input.type === "checkbox") {
          newSettings[key] = input.checked;
        } else {
          const parsedValue = parseFloat(input.value);
          if (!isNaN(parsedValue)) {
            newSettings[key] = parsedValue;
          } else {
            newSettings[key] = 0;
          }
        }
      }
    }
    return { ...currentSettings, ...newSettings };
  };
  const presetSelect = document.createElement("select");
  presetSelect.style.marginRight = "10px";
  presetSelect.style.padding = "5px";
  presetSelect.style.marginBottom = "10px";
  presetSelect.style.width = "100%";
  presetSelect.style.backgroundColor = "var(--background-modifier-form-field, #ffffff)";
  presetSelect.style.border = "1px solid var(--background-modifier-border, #ddd)";
  const defaultOption = document.createElement("option");
  defaultOption.value = "";
  defaultOption.textContent = "Select a preset...";
  presetSelect.appendChild(defaultOption);
  const refreshPresetDropdown = (selectId) => {
    presetSelect.innerHTML = "";
    presetSelect.appendChild(defaultOption);
    PresetManager.getAllPresets().forEach((p) => {
      const opt = document.createElement("option");
      opt.value = p.id;
      opt.textContent = p.name;
      presetSelect.appendChild(opt);
    });
    presetSelect.value = selectId;
  };
  refreshPresetDropdown("");
  const presetNameInput = document.createElement("input");
  presetNameInput.type = "text";
  presetNameInput.placeholder = 'Preset Name (required for "Save New")';
  presetNameInput.classList.add("mousetrap");
  presetNameInput.style.marginRight = "10px";
  presetNameInput.style.padding = "5px";
  presetNameInput.style.marginBottom = "10px";
  presetNameInput.style.width = "100%";
  presetNameInput.style.backgroundColor = "var(--background-modifier-form-field, #ffffff)";
  presetNameInput.style.border = "1px solid var(--background-modifier-border, #ddd)";
  ["keydown", "keyup", "keypress"].forEach((evt) => {
    presetNameInput.addEventListener(evt, (e) => {
      if (e.key === "Escape")
        return;
      e.stopPropagation();
    });
  });
  const presetButtonsDiv = document.createElement("div");
  presetButtonsDiv.style.display = "flex";
  presetButtonsDiv.style.gap = "8px";
  presetButtonsDiv.style.alignItems = "center";
  presetButtonsDiv.style.flexWrap = "wrap";
  const statusLabel = document.createElement("span");
  statusLabel.style.marginLeft = "8px";
  statusLabel.style.color = "var(--text-success, green)";
  statusLabel.style.fontWeight = "bold";
  statusLabel.style.opacity = "0";
  statusLabel.style.transition = "opacity 0.5s";
  statusLabel.textContent = "Saved!";
  const showStatus = (msg) => {
    statusLabel.textContent = msg;
    statusLabel.style.opacity = "1";
    setTimeout(() => {
      statusLabel.style.opacity = "0";
    }, 2e3);
  };
  const saveNewPresetBtn = document.createElement("button");
  saveNewPresetBtn.type = "button";
  saveNewPresetBtn.textContent = "\u{1F4BE} Save New";
  saveNewPresetBtn.title = "Save current settings as a NEW preset";
  saveNewPresetBtn.onclick = () => {
    const presetName = presetNameInput.value.trim();
    if (!presetName) {
      alert("Please enter a name for the new preset.");
      presetNameInput.focus();
      return;
    }
    const fullSettings = getCurrentFormValues();
    const savedPreset = PresetManager.savePreset({
      name: presetName,
      settings: fullSettings
    });
    refreshPresetDropdown(savedPreset.id);
    updatePresetBtn.disabled = false;
    deletePresetButton.disabled = false;
    showStatus(`Saved: ${presetName}`);
  };
  const updatePresetBtn = document.createElement("button");
  updatePresetBtn.type = "button";
  updatePresetBtn.textContent = "\u{1F504} Update Selected";
  updatePresetBtn.disabled = true;
  updatePresetBtn.onclick = () => {
    const selectedId = presetSelect.value;
    if (!selectedId)
      return;
    const existing = PresetManager.getPresetById(selectedId);
    if (!existing) {
      alert("Error: Preset not found.");
      return;
    }
    const presetName = presetNameInput.value.trim() || existing.name;
    if (confirm(`Overwrite settings for preset "${existing.name}"?`)) {
      const fullSettings = getCurrentFormValues();
      PresetManager.savePreset({
        id: selectedId,
        name: presetName,
        settings: fullSettings
      });
      refreshPresetDropdown(selectedId);
      updatePresetBtn.disabled = false;
      deletePresetButton.disabled = false;
      showStatus("Preset Updated!");
    }
  };
  const deletePresetButton = document.createElement("button");
  deletePresetButton.type = "button";
  deletePresetButton.textContent = "\u{1F5D1}\uFE0F Delete";
  deletePresetButton.disabled = true;
  deletePresetButton.onclick = () => {
    const selectedId = presetSelect.value;
    if (selectedId && confirm("Delete this preset?")) {
      PresetManager.deletePreset(selectedId);
      refreshPresetDropdown("");
      presetNameInput.value = "";
      updatePresetBtn.disabled = true;
      deletePresetButton.disabled = true;
    }
  };
  const restoreDefaultsButton = document.createElement("button");
  restoreDefaultsButton.type = "button";
  restoreDefaultsButton.textContent = "\u21BA Form Defaults";
  restoreDefaultsButton.title = "Reset the form below to factory default values";
  restoreDefaultsButton.style.marginLeft = "auto";
  restoreDefaultsButton.onclick = () => {
    if (confirm("Reset current form to factory default settings?")) {
      Object.entries(defaultLayoutSettings).forEach(([key, value]) => {
        const input = form.elements.namedItem(key);
        if (input) {
          if (typeof value === "boolean")
            input.checked = value;
          else
            input.value = value.toString();
        }
      });
    }
  };
  presetSelect.addEventListener("change", () => {
    const selectedId = presetSelect.value;
    if (!selectedId) {
      updatePresetBtn.disabled = true;
      deletePresetButton.disabled = true;
      return;
    }
    updatePresetBtn.disabled = false;
    deletePresetButton.disabled = false;
    const preset = PresetManager.getPresetById(selectedId);
    if (preset) {
      Object.entries(preset.settings).forEach(([key, value]) => {
        const input = form.elements.namedItem(key);
        if (input) {
          if (input.type === "checkbox") {
            input.checked = value;
          } else {
            input.value = value.toString();
          }
        }
      });
      presetNameInput.value = preset.name;
    }
  });
  presetButtonsDiv.appendChild(saveNewPresetBtn);
  presetButtonsDiv.appendChild(updatePresetBtn);
  presetButtonsDiv.appendChild(deletePresetButton);
  presetButtonsDiv.appendChild(restoreDefaultsButton);
  presetButtonsDiv.appendChild(statusLabel);
  presetSection.appendChild(presetSelect);
  presetSection.appendChild(presetNameInput);
  presetSection.appendChild(presetButtonsDiv);
  form.appendChild(presetSection);
  const settingsContainer = document.createElement("div");
  settingsContainer.style.maxHeight = "400px";
  settingsContainer.style.overflowY = "auto";
  settingsContainer.style.padding = "5px";
  settingsContainer.style.border = "1px solid var(--background-modifier-border, #ddd)";
  settingsContainer.style.borderRadius = "4px";
  const addInput = (key, label, type = "number") => {
    var _a;
    const div = document.createElement("div");
    div.style.display = "grid";
    div.style.gridTemplateColumns = "2fr 1fr";
    div.style.alignItems = "center";
    div.style.padding = "5px 0";
    div.style.borderBottom = "1px solid var(--background-modifier-border, #eee)";
    const scopedId = `${key}_${UID}`;
    const lbl = document.createElement("label");
    lbl.textContent = label;
    lbl.htmlFor = scopedId;
    div.appendChild(lbl);
    if (type === "checkbox") {
      const toggleSwitch = document.createElement("label");
      toggleSwitch.className = "toggle-switch";
      const input = document.createElement("input");
      input.type = "checkbox";
      input.checked = !!currentSettings[key];
      input.id = scopedId;
      input.name = key;
      input.classList.add("mousetrap");
      const slider = document.createElement("span");
      slider.className = "slider";
      toggleSwitch.appendChild(input);
      toggleSwitch.appendChild(slider);
      div.appendChild(toggleSwitch);
    } else {
      const input = document.createElement("input");
      input.type = "text";
      input.inputMode = "decimal";
      input.classList.add("mousetrap");
      input.value = ((_a = currentSettings[key]) == null ? void 0 : _a.toString()) || "0";
      input.id = scopedId;
      input.name = key;
      input.style.width = "100%";
      input.style.padding = "4px";
      input.style.border = "1px solid var(--background-modifier-border, #ddd)";
      input.style.borderRadius = "4px";
      ["keydown", "keyup", "keypress"].forEach((evt) => {
        input.addEventListener(evt, (e) => {
          if (e.key === "Escape" || e.key === "Tab")
            return;
          e.stopPropagation();
        });
      });
      div.appendChild(input);
    }
    settingsContainer.appendChild(div);
  };
  addInput("lineHeightMultiplier", "Line Height Multiplier");
  addInput("minStripConfidence", "Min Strip Confidence");
  addInput("minStripWidthPx", "Min Strip Width (px)");
  addInput("debugValidation", "Debug Validation", "checkbox");
  addInput("maxIterMerges", "Max Iter Merges");
  addInput("minBandConfidence", "Min Band Confidence");
  addInput("bandTopBottomThresholdMultiplier", "Band Top/Bottom Threshold Multiplier");
  addInput("inferredBandConfidence", "Inferred Band Confidence");
  addInput("bandMergeGapPx", "Band Merge Gap (px)");
  addInput("bandMergeGapLineHeightMultiplier", "Band Merge Gap Line Height Multiplier");
  addInput("maxGapFractionOfPageHeight", "Max Gap Fraction of Page Height");
  addInput("minGapsForTrim", "Min Gaps For Trim");
  addInput("trimPercent", "Trim Percent");
  addInput("lineHeightFromAvgMultiplier", "Line Height From Avg Multiplier");
  addInput("floorMultiplier", "Floor Multiplier");
  addInput("minOverlapFracForBand", "Min Overlap Frac For Band");
  addInput("minRegionWidth", "Min Region Width");
  addInput("columnThresholdLineHeightMultiplier", "Column Threshold Line Height Multiplier");
  addInput("columnThresholdFallback", "Column Threshold Fallback");
  addInput("pmForceLinearMerge", "\u{1F525} Force Linear Merge (Ignore All Layout/Styles)", "checkbox");
  addInput("pmMinStripConfidenceSplit", "PM Min Strip Confidence Split");
  addInput("pmMinStripWidthPx", "PM Min Strip Width Px (for PM)");
  addInput("pmMinStripOverlapFrac", "PM Min Strip Overlap Frac");
  addInput("pmInitialMergeBaselineTolNonMath", "PM Init Merge Baseline Tol Non-Math");
  addInput("pmInitialMergeBaselineTolMath", "PM Init Merge Baseline Tol Math");
  addInput("pmInitialMergeKernTolNonMath", "PM Init Merge Kern Tol Non-Math");
  addInput("pmInitialMergeKernTolMath", "PM Init Merge Kern Tol Math");
  addInput("pmHyphenContinuationTol", "PM Hyphen Continuation Tol");
  addInput("pmInitialMergeAlignTolNonMath", "PM Init Merge Align Tol Non-Math");
  addInput("pmInitialMergeAlignTolMath", "PM Init Merge Align Tol Math");
  addInput("pmInitialMergeVerticalGapMultiplier", "PM Init Merge Vertical Gap Multiplier");
  addInput("pmInitialMergeVerticalGapMaxMultiplier", "PM Init Merge Vertical Gap Max Multiplier");
  addInput("pmStackedMergeAlignTol", "PM Stacked Merge Align Tol");
  addInput("pmStackedMergeOverlapFrac", "PM Stacked Merge Overlap Frac");
  addInput("pmStackedMergeVerticalGapMultiplier", "PM Stacked Merge Vertical Gap Multiplier");
  addInput("pmStackedMergeVerticalGapMaxMultiplier", "PM Stacked Merge Vertical Gap Max Multiplier");
  addInput("pmGeneralMergeAlignTol", "PM General Merge Align Tol");
  addInput("pmGeneralMergeOverlapFrac", "PM General Merge Overlap Frac");
  addInput("pmGeneralMergeVerticalGapMultiplier", "PM General Merge Vertical Gap Multiplier");
  addInput("pmGeneralMergeVerticalGapMaxMultiplier", "PM General Merge Vertical Gap Max Multiplier");
  addInput("pmNestedMergeOverlapFrac", "PM Nested Merge Overlap Frac");
  addInput("pmStitchBaselineTolNonMath", "PM Stitch Baseline Tol Non-Math");
  addInput("pmStitchBaselineTolMath", "PM Stitch Baseline Tol Math");
  addInput("pmStitchKernTolNonMath", "PM Stitch Kern Tol Non-Math");
  addInput("pmStitchKernTolMath", "PM Stitch Kern Tol Math");
  addInput("pmInlineSpanBaselineTol", "PM Inline Span Baseline Tol");
  addInput("pmInlineSpanKernTol", "PM Inline Span Kern Tol");
  addInput("pmInlineSpanMaxWeightDiff", "PM Inline Span Max Weight Diff");
  addInput("pmInlineSpanAllowMixedStyle", "PM Inline Span Allow Mixed Style", "checkbox");
  addInput("pmSameColumnCoverageRatio", "PM Same Column Coverage Ratio");
  addInput("pmMathMergeBaselineTol", "PM Math Merge Baseline Tol");
  addInput("pmMathMergeHorizTol", "PM Math Merge Horiz Tol");
  addInput("pmMathMergeCenterTol", "PM Math Merge Center Tol");
  addInput("pmSplitLineHeightTol", "PM Split Line Height Tol");
  addInput("pmSplitBoundaryDedupTol", "PM Split Boundary Dedup Tol");
  addInput("pmSplitInterWordGapTol", "PM Split Inter Word Gap Tol");
  addInput("pmSplitColumnGapTol", "PM Split Column Gap Tol");
  form.appendChild(settingsContainer);
  const buttonDiv = document.createElement("div");
  buttonDiv.style.display = "flex";
  buttonDiv.style.justifyContent = "flex-end";
  buttonDiv.style.gap = "10px";
  buttonDiv.style.marginTop = "20px";
  buttonDiv.style.paddingTop = "10px";
  buttonDiv.style.borderTop = "1px solid var(--background-modifier-border, #ddd)";
  const closeDialog = () => {
    dialog.close();
    if (document.body.contains(dialog)) {
      document.body.removeChild(dialog);
    }
  };
  const cancelButton = document.createElement("button");
  cancelButton.type = "button";
  cancelButton.textContent = "Close";
  cancelButton.onclick = closeDialog;
  const saveButton = document.createElement("button");
  saveButton.type = "button";
  saveButton.textContent = "Save & Close";
  saveButton.style.backgroundColor = "var(--interactive-accent, #007acc)";
  saveButton.style.color = "white";
  saveButton.style.border = "none";
  saveButton.style.padding = "6px 12px";
  saveButton.style.borderRadius = "4px";
  saveButton.style.cursor = "pointer";
  saveButton.onclick = () => {
    const s = getCurrentFormValues();
    onSave(s);
    closeDialog();
  };
  buttonDiv.appendChild(cancelButton);
  buttonDiv.appendChild(saveButton);
  form.appendChild(buttonDiv);
  dialog.appendChild(form);
  document.body.appendChild(dialog);
  dialog.showModal();
  dialog.addEventListener("keydown", (e) => {
    const isInput = e.target instanceof HTMLInputElement;
    if (e.key === "Enter" && !isInput && e.target instanceof HTMLElement && e.target.tagName !== "TEXTAREA") {
      if (e.target.tagName !== "BUTTON") {
        e.preventDefault();
        saveButton.click();
      }
    }
  });
  dialog.addEventListener("click", (e) => {
    const rect = dialog.getBoundingClientRect();
    const isInDialog = rect.top <= e.clientY && e.clientY <= rect.top + rect.height && rect.left <= e.clientX && e.clientX <= rect.left + rect.width;
    if (!isInDialog) {
      closeDialog();
    }
  });
}

// layout-detector.ts
var LayoutDetector = class {
  // <-- NEW: Add GridDetector instance
  constructor(options = {}) {
    // -----------------------------
    // New Column Analysis Implementation (unchanged)
    // -----------------------------
    this.average = (arr) => arr.reduce((a, b) => a + b, 0) / arr.length || 0;
    this.settings = { ...defaultLayoutSettings, ...options };
    this.gapDetector = new GapDetector();
    this.paragraphMerger = new ParagraphMerger(this.settings);
    this.gridDetector = new GridDetector();
  }
  removeDuplicateSpans(paragraphs, infoMap) {
    var _a;
    const seenSpans = /* @__PURE__ */ new Set();
    const uniqueParagraphs = [];
    for (const paragraph of paragraphs) {
      const uniqueSpans = [];
      for (const span of paragraph) {
        const rect = (_a = infoMap.get(span)) == null ? void 0 : _a.rect;
        if (!rect) {
          if (!seenSpans.has(span.id || span.textContent || span.outerHTML || span.getBoundingClientRect().toString())) {
            seenSpans.add(span.id || span.textContent || span.outerHTML || span.getBoundingClientRect().toString());
            uniqueSpans.push(span);
          }
        } else {
          const spanKey = `${rect.left}-${rect.top}-${rect.right}-${rect.bottom}-${span.textContent || ""}-${span.id || ""}`;
          if (!seenSpans.has(spanKey)) {
            seenSpans.add(spanKey);
            uniqueSpans.push(span);
          }
        }
      }
      if (uniqueSpans.length > 0) {
        uniqueParagraphs.push(uniqueSpans);
      }
    }
    return uniqueParagraphs;
  }
  // Alternative method: Remove duplicates within each paragraph and across all paragraphs
  deduplicateParagraphs(paragraphs) {
    const globalSeen = /* @__PURE__ */ new Set();
    const uniqueParagraphs = [];
    for (const paragraph of paragraphs) {
      const paragraphSeen = /* @__PURE__ */ new Set();
      const uniqueSpans = [];
      for (const span of paragraph) {
        if (!globalSeen.has(span) && !paragraphSeen.has(span)) {
          globalSeen.add(span);
          paragraphSeen.add(span);
          uniqueSpans.push(span);
        }
      }
      if (uniqueSpans.length > 0) {
        uniqueParagraphs.push(uniqueSpans);
      }
    }
    return uniqueParagraphs;
  }
  detectLayout(spans, pageElement) {
    if (!spans || !Array.isArray(spans) || !pageElement || !(pageElement instanceof HTMLElement)) {
      this.logDebug("Invalid input; returning empty result");
      return this.createEmptyResult();
    }
    const start = performance.now();
    const infoMap = buildSnapshot(spans);
    const rects = [...infoMap.values()].map((i) => i.rect);
    const dpr = window.devicePixelRatio || 1;
    const pr = pageElement.getBoundingClientRect();
    const pageRect = new DOMRect(pr.left / dpr, pr.top / dpr, pr.width / dpr, pr.height / dpr);
    let paragraphs = this.paragraphMerger.mergeIntoParagraphsFromInfos(infoMap);
    const lineHeight = this.estimateLineHeightFromInfos(paragraphs, infoMap, pageRect);
    const gapAnalysis = this.gapDetector.detectGapsFromRects(rects, pageRect);
    const gridAnalysis = this.gridDetector.detectGrid(rects, pageRect, lineHeight);
    const gridBands = [];
    if (gridAnalysis && gridAnalysis.horizontalLines.length > 0) {
      this.logDebug(`Grid detector found ${gridAnalysis.horizontalLines.length} horizontal lines.`);
      for (const line of gridAnalysis.horizontalLines) {
        const gapHeight = lineHeight * (this.settings.bandMergeGapLineHeightMultiplier || 1);
        gridBands.push({
          y: line.position - gapHeight / 2,
          height: gapHeight,
          confidence: 0.95
          // Assign a very high confidence to respect these gaps
        });
      }
    }
    const verticalStripsAll = gapAnalysis.verticalStrips || [];
    const verticalStrips = verticalStripsAll.filter((s) => s.confidence >= this.settings.minStripConfidence && s.right - s.left >= this.settings.minStripWidthPx).sort((a, b) => (a.left + a.right) / 2 - (b.left + b.right) / 2);
    const horizontalBandsRaw = (gapAnalysis.horizontalBands || []).filter((b) => b.confidence >= this.settings.minBandConfidence);
    const combinedBands = [...horizontalBandsRaw, ...gridBands];
    const layoutBands = this.buildLayoutBands(combinedBands, verticalStrips, pageRect, lineHeight);
    if (this.settings.debugValidation) {
      const filteredOut = verticalStripsAll.length - verticalStrips.length;
      this.logDebug(`Strips kept=${verticalStrips.length}, filtered=${filteredOut}, bands=${layoutBands.length}`);
    }
    paragraphs = this.paragraphMerger.validateParagraphsAgainstStripsFromInfos(
      paragraphs,
      infoMap,
      verticalStrips
    );
    paragraphs = this.paragraphMerger.mergeParagraphsFromInfos(
      paragraphs,
      infoMap,
      lineHeight,
      verticalStrips,
      layoutBands
    );
    let guard = 0;
    while (guard++ < this.settings.maxIterMerges) {
      const { paragraphs: mergedOnce, changed } = this.paragraphMerger.mergeNestedParagraphsOnceFromInfos(
        paragraphs,
        infoMap,
        verticalStrips,
        layoutBands
      );
      paragraphs = mergedOnce;
      if (!changed)
        break;
      paragraphs = this.paragraphMerger.validateParagraphsAgainstStripsFromInfos(
        paragraphs,
        infoMap,
        verticalStrips
      );
      paragraphs = this.paragraphMerger.mergeParagraphsFromInfos(
        paragraphs,
        infoMap,
        lineHeight,
        verticalStrips,
        layoutBands
      );
    }
    paragraphs = this.paragraphMerger.mergeStackedColumnParagraphsFromInfos(
      paragraphs,
      infoMap,
      lineHeight,
      verticalStrips,
      layoutBands
    );
    paragraphs = this.paragraphMerger.stitchInlineLigaturesFromInfos(paragraphs, infoMap);
    if (layoutBands.length) {
      const perBandColumnRegions = this.buildPerBandColumnRegions(verticalStrips, pageRect, layoutBands);
      paragraphs = paragraphs.map(
        (para) => this.orderParagraphByBandsAndColumns(para, infoMap, layoutBands, perBandColumnRegions)
      );
    }
    paragraphs = paragraphs.map(
      (para) => [...para].sort((a, b) => {
        const ra = infoMap.get(a).rect;
        const rb = infoMap.get(b).rect;
        return ra.top - rb.top || ra.left - rb.left;
      })
    );
    paragraphs = this.deduplicateParagraphs(paragraphs);
    const columnAnalysis = this.analyzeColumns(paragraphs, infoMap, pageRect);
    this.logDebug(
      `Layout detection done in ${(performance.now() - start).toFixed(2)}ms`,
      { paragraphs: paragraphs.length, columns: columnAnalysis.columns.length }
    );
    return { paragraphs, columnAnalysis, layoutRegions: gapAnalysis.layoutSegments };
  }
  getAverageLineHeight(paragraphs, infoMap) {
    const lineHeights = [];
    for (const p of paragraphs) {
      for (const span of p) {
        const info = infoMap.get(span);
        if (info) {
          lineHeights.push(info.rect.height);
        }
      }
    }
    return this.average(lineHeights);
  }
  analyzeColumns(paragraphs, infoMap, pageRect) {
    var _a, _b;
    const allSpans = paragraphs.flat();
    if (allSpans.length < 2) {
      return {
        columns: [{
          left: pageRect.left,
          top: pageRect.top,
          right: pageRect.right,
          bottom: pageRect.bottom,
          width: pageRect.width,
          height: pageRect.height
        }],
        edgeCols: [],
        gapCols: [],
        verticalGaps: [],
        horizontalGaps: []
      };
    }
    const avgLineHeight = this.getAverageLineHeight(paragraphs, infoMap);
    const columnThreshold = avgLineHeight > 0 ? avgLineHeight * this.settings.columnThresholdLineHeightMultiplier : this.settings.columnThresholdFallback;
    const sortedByX = [...allSpans].sort((a, b) => {
      var _a2, _b2;
      const rectA = (_a2 = infoMap.get(a)) == null ? void 0 : _a2.rect;
      const rectB = (_b2 = infoMap.get(b)) == null ? void 0 : _b2.rect;
      if (!rectA || !rectB)
        return 0;
      return rectA.left - rectB.left;
    });
    const columns = [];
    if (sortedByX.length > 0) {
      columns.push([sortedByX[0]]);
      for (let i = 1; i < sortedByX.length; i++) {
        const currentSpan = sortedByX[i];
        const currentRect = (_a = infoMap.get(currentSpan)) == null ? void 0 : _a.rect;
        if (!currentRect)
          continue;
        const lastColumn = columns[columns.length - 1];
        const lastSpanInColumn = lastColumn[lastColumn.length - 1];
        const lastRect = (_b = infoMap.get(lastSpanInColumn)) == null ? void 0 : _b.rect;
        if (!lastRect)
          continue;
        if (Math.abs(currentRect.left - lastRect.left) < columnThreshold) {
          lastColumn.push(currentSpan);
        } else {
          columns.push([currentSpan]);
        }
      }
    }
    const columnRects = columns.map((column) => {
      var _a2;
      let left = Infinity, top = Infinity, right = -Infinity, bottom = -Infinity;
      for (const span of column) {
        const rect = (_a2 = infoMap.get(span)) == null ? void 0 : _a2.rect;
        if (rect) {
          left = Math.min(left, rect.left);
          top = Math.min(top, rect.top);
          right = Math.max(right, rect.right);
          bottom = Math.max(bottom, rect.bottom);
        }
      }
      if (left === Infinity) {
        return {
          left: pageRect.left,
          top: pageRect.top,
          right: pageRect.right,
          bottom: pageRect.bottom,
          width: pageRect.width,
          height: pageRect.height
        };
      }
      return { left, top, right, bottom, width: right - left, height: bottom - top };
    });
    const edgeCols = columnRects.length ? [columnRects[0], columnRects[columnRects.length - 1]] : [];
    const gapCols = columnRects.slice(1, -1);
    const verticalGaps = [];
    for (let i = 1; i < columnRects.length; i++) {
      verticalGaps.push((columnRects[i].left + columnRects[i - 1].right) / 2);
    }
    return { columns: columnRects, edgeCols, gapCols, verticalGaps, horizontalGaps: [] };
  }
  // -----------------------------
  // Existing Helpers (unchanged)
  // -----------------------------
  estimateLineHeightFromInfos(paragraphs, infoMap, pageRect) {
    const gaps = [];
    for (const p of paragraphs) {
      if (p.length < 2)
        continue;
      const lines = [...p].map((s) => infoMap.get(s).rect).sort((a, b) => a.top - b.top);
      for (let i = 1; i < lines.length; i++) {
        const gap = lines[i].top - lines[i - 1].bottom;
        if (gap > 0 && gap < pageRect.height * this.settings.maxGapFractionOfPageHeight)
          gaps.push(gap);
      }
    }
    let lhFromGaps;
    if (gaps.length >= this.settings.minGapsForTrim) {
      gaps.sort((a, b) => a - b);
      const trim = Math.floor(gaps.length * this.settings.trimPercent);
      const trimmed = gaps.slice(trim, gaps.length - trim);
      if (trimmed.length) {
        const avg = trimmed.reduce((s, v) => s + v, 0) / trimmed.length;
        lhFromGaps = avg * this.settings.lineHeightFromAvgMultiplier;
      }
    }
    const fontSizes = [...infoMap.values()].map((i) => i.style.fontSize).filter((v) => v > 0);
    if (!fontSizes.length)
      return 16;
    fontSizes.sort((a, b) => a - b);
    const mid = Math.floor(fontSizes.length / 2);
    const median2 = fontSizes.length % 2 ? fontSizes[mid] : (fontSizes[mid - 1] + fontSizes[mid]) / 2;
    const floor = median2 * this.settings.lineHeightMultiplier * this.settings.floorMultiplier;
    const chosen = Math.max(lhFromGaps != null ? lhFromGaps : 0, floor);
    return chosen || median2 * this.settings.lineHeightMultiplier;
  }
  buildLayoutBands(bands, strips, pageRect, lineHeight) {
    const out = [];
    for (const b of bands)
      out.push({ ...b });
    if (strips.length) {
      let minTop = Infinity, maxBottom = -Infinity;
      for (const s of strips) {
        minTop = Math.min(minTop, s.top);
        maxBottom = Math.max(maxBottom, s.bottom);
      }
      if (minTop > pageRect.top + lineHeight * this.settings.bandTopBottomThresholdMultiplier) {
        out.push({ y: pageRect.top, height: minTop - pageRect.top, confidence: this.settings.inferredBandConfidence });
      }
      if (maxBottom < pageRect.bottom - lineHeight * this.settings.bandTopBottomThresholdMultiplier) {
        out.push({ y: maxBottom, height: pageRect.bottom - maxBottom, confidence: this.settings.inferredBandConfidence });
      }
    }
    out.sort((a, b) => a.y - b.y);
    const merged = [];
    for (const b of out) {
      if (!merged.length) {
        merged.push({ ...b });
        continue;
      }
      const last = merged[merged.length - 1];
      const lastBottom = last.y + last.height;
      if (b.y <= lastBottom + Math.max(this.settings.bandMergeGapPx, lineHeight * this.settings.bandMergeGapLineHeightMultiplier)) {
        const newBottom = Math.max(lastBottom, b.y + b.height);
        last.height = newBottom - last.y;
        last.confidence = Math.max(last.confidence, b.confidence);
      } else {
        merged.push({ ...b });
      }
    }
    return merged;
  }
  buildPerBandColumnRegions(strips, pageRect, bands) {
    const results = [];
    for (const band of bands) {
      const top = band.y;
      const bottom = band.y + band.height;
      const bandStrips = strips.filter((s) => {
        const yOverlap = Math.min(bottom, s.bottom) - Math.max(top, s.top);
        const stripH = s.bottom - s.top;
        const overlapFrac = yOverlap / Math.max(1, stripH, bottom - top);
        return yOverlap > 0 && overlapFrac >= this.settings.minOverlapFracForBand;
      });
      const regions = this.buildColumnRegionsFromStrips(bandStrips, pageRect);
      results.push({ band: { top, bottom }, regions });
    }
    if (!bands.length) {
      results.push({
        band: { top: pageRect.top, bottom: pageRect.bottom },
        regions: this.buildColumnRegionsFromStrips(strips, pageRect)
      });
    }
    return results;
  }
  buildColumnRegionsFromStrips(strips, pageRect) {
    if (!(strips == null ? void 0 : strips.length)) {
      return [{ left: pageRect.left, right: pageRect.right }];
    }
    const s = [...strips].sort((a, b) => (a.left + a.right) / 2 - (b.left + b.right) / 2);
    const xs = [pageRect.left];
    for (const st of s) {
      const mid = (st.left + st.right) / 2;
      if (mid > xs[xs.length - 1])
        xs.push(mid);
    }
    xs.push(pageRect.right);
    const regions = [];
    for (let i = 0; i < xs.length - 1; i++) {
      const l = xs[i], r = xs[i + 1];
      if (r - l > this.settings.minRegionWidth)
        regions.push({ left: l, right: r });
    }
    return regions;
  }
  orderParagraphByBandsAndColumns(paragraph, infoMap, bands, perBandRegions) {
    if (!paragraph.length)
      return paragraph;
    const bandBuckets = perBandRegions.map((entry) => ({ spans: [], regions: entry.regions }));
    for (const s of paragraph) {
      const r = infoMap.get(s).rect;
      const sTop = r.top, sBot = r.bottom;
      let bestIdx = -1, bestOverlap = 0;
      for (let i = 0; i < perBandRegions.length; i++) {
        const band = perBandRegions[i].band;
        const yOverlap = Math.min(sBot, band.bottom) - Math.max(sTop, band.top);
        if (yOverlap <= 0)
          continue;
        const overlap = yOverlap / Math.max(1, sBot - sTop, band.bottom - band.top);
        if (overlap > bestOverlap) {
          bestOverlap = overlap;
          bestIdx = i;
        }
      }
      if (bestIdx >= 0) {
        bandBuckets[bestIdx].spans.push(s);
      } else {
        if (perBandRegions.length) {
          let idx = 0, bestDist = Infinity;
          const sc = (sTop + sBot) / 2;
          for (let i = 0; i < perBandRegions.length; i++) {
            const band = perBandRegions[i].band;
            const bc = (band.top + band.bottom) / 2;
            const d = Math.abs(sc - bc);
            if (d < bestDist) {
              bestDist = d;
              idx = i;
            }
          }
          bandBuckets[idx].spans.push(s);
        } else {
          if (!bandBuckets.length)
            bandBuckets.push({ spans: [], regions: [{ left: -Infinity, right: Infinity }] });
          bandBuckets[0].spans.push(s);
        }
      }
    }
    const ordered = [];
    for (const bucket of bandBuckets) {
      if (!bucket.spans.length)
        continue;
      const regions = bucket.regions.length ? bucket.regions : [{ left: -Infinity, right: Infinity }];
      const colBuckets = regions.map(() => []);
      for (const s of bucket.spans) {
        const r = infoMap.get(s).rect;
        const cx = (r.left + r.right) / 2;
        let idx = regions.findIndex((reg) => cx >= reg.left && cx < reg.right);
        if (idx < 0) {
          idx = cx < regions[0].left ? 0 : regions.length - 1;
        }
        colBuckets[idx].push(s);
      }
      if (colBuckets.filter((b) => b.length > 0).length <= 1) {
        const sorted = bucket.spans.slice().sort((a, b) => {
          const ra = infoMap.get(a).rect;
          const rb = infoMap.get(b).rect;
          return ra.top - rb.top || ra.left - rb.left;
        });
        ordered.push(...sorted);
        continue;
      }
      for (const b of colBuckets) {
        b.sort((a, b2) => {
          const ra = infoMap.get(a).rect;
          const rb = infoMap.get(b2).rect;
          return ra.top - rb.top || ra.left - rb.left;
        });
        ordered.push(...b);
      }
    }
    return ordered.length ? ordered : paragraph;
  }
  createEmptyResult() {
    return {
      paragraphs: [],
      columnAnalysis: {
        columns: [],
        edgeCols: [],
        gapCols: [],
        verticalGaps: [],
        horizontalGaps: []
      },
      layoutRegions: []
    };
  }
  logDebug(message, details) {
    if (!this.settings.debugValidation)
      return;
    if (details !== void 0) {
      console.log(`[LayoutDetector] ${message}`, details);
    } else {
      console.log(`[LayoutDetector] ${message}`);
    }
  }
};

// processing.ts
var TextProcessor = class {
  constructor(plugin) {
    // Caches
    this.measurementCache = /* @__PURE__ */ new Map();
    this.styleCache = /* @__PURE__ */ new Map();
    this.colorDistanceCache = /* @__PURE__ */ new Map();
    this.lastPreparedUnits = null;
    // State
    this.overlayContainers = [];
    this.translationFailures = [];
    this.lastColumnAnalysis = null;
    this.plugin = plugin;
    this.layoutDetector = new LayoutDetector(this.plugin.settings.layoutSettings);
  }
  /**
   * Updates the LayoutDetector instance with new settings.
   * @param newSettings The new LayoutSettings object from the modal.
   */
  updateLayoutDetectorSettings(newSettings) {
    console.log("Updating LayoutDetector with new settings:", newSettings);
    this.layoutDetector = new LayoutDetector(newSettings);
    new import_obsidian7.Notice("Layout detection settings have been updated.");
  }
  /**
   * Main entry point for the "Translate Page" command.
   */
  async addTextOverlay() {
    const currentPage = this.plugin.overlay.getCurrentPageElement();
    if (currentPage) {
      await this.addOverlayToPage(currentPage);
    } else {
      new import_obsidian7.Notice("No active PDF page found.");
    }
  }
  /**
   * Orchestrates the entire translation and rendering process for a single page.
   * @param pageElement The .page element to add the overlay to.
   */
  async addOverlayToPage(pageElement) {
    try {
      const translatedText = await this.translatePageContent(pageElement);
      if (translatedText) {
        await this.createOverlayWithText(pageElement, translatedText);
        const successfulTranslations = translatedText.split("\n").filter((line) => line !== "Translation missing").length;
        new import_obsidian7.Notice(`\u2705 Translation complete. Rendered ${successfulTranslations} segment(s).`, 3e3);
      }
    } catch (error) {
      console.error("addOverlayToPage process failed:", error);
      new import_obsidian7.Notice(`\u26A0\uFE0F Translation failed: ${error.message}`, 4e3);
    }
  }
  /**
   * Extracts text, gets the translation, but does NOT modify the DOM.
   * @param pageElement The .page element to process.
   * @returns A single string containing all translated text, or null if failed.
   */
  async translatePageContent(pageElement) {
    const textLayer = pageElement.querySelector(".textLayer");
    if (!textLayer) {
      new import_obsidian7.Notice("Text layer not found. Wait for PDF to fully render.");
      return null;
    }
    const translationUnits = this.prepareTranslationUnits(textLayer, pageElement);
    if (!translationUnits || translationUnits.length === 0) {
      new import_obsidian7.Notice("No valid text to translate.", 2e3);
      return null;
    }
    this.lastPreparedUnits = { pageElement, units: [...translationUnits] };
    const translatedLines = await this.executeTranslation(translationUnits);
    return translatedLines.join("\n");
  }
  /**
   * Creates an overlay on the page using pre-translated text.
   * @param pageElement The .page element to add the overlay to.
   * @param translatedText A single string of translated text, with lines separated by '\n'.
   */
  async createOverlayWithText(pageElement, translatedText) {
    var _a;
    const prepResult = this.validateAndPreparePrerequisites(pageElement);
    if (!prepResult)
      return;
    const { textLayer, overlayContainer } = prepResult;
    this.overlayContainers.push(overlayContainer);
    let translationUnits = ((_a = this.lastPreparedUnits) == null ? void 0 : _a.pageElement) === pageElement ? this.lastPreparedUnits.units : this.prepareTranslationUnits(textLayer, pageElement);
    if (!translationUnits || translationUnits.length === 0) {
      overlayContainer.remove();
      return;
    }
    const translatedLines = translatedText.split("\n");
    if (translatedLines.length !== translationUnits.length) {
      console.error("Translation structure mismatch. Original units:", translationUnits.length, "Translated lines:", translatedLines.length);
      new import_obsidian7.Notice("\u26A0\uFE0F Error: Translation structure mismatch. Cannot create overlay.");
      overlayContainer.remove();
      return;
    }
    this.renderOverlay(translationUnits, translatedLines, overlayContainer, pageElement);
    if (this.plugin.settings.autoSaveOverlay) {
      requestAnimationFrame(() => this.plugin.overlay.saveCurrentPageOverlay());
    }
  }
  // 
  // CORE LOGIC (Now more modular for reuse)
  // 
  validateAndPreparePrerequisites(pageElement) {
    if (!this.validatePageElement(pageElement)) {
      new import_obsidian7.Notice("Invalid page element");
      return null;
    }
    const overlayContainer = this.plugin.overlay.preparePageForOverlay(pageElement);
    const textLayer = pageElement.querySelector(".textLayer");
    if (!textLayer) {
      new import_obsidian7.Notice("Text layer not found. Wait for PDF to fully render.");
      overlayContainer.remove();
      return null;
    }
    return { textLayer, overlayContainer };
  }
  /**
   * MODIFIED: Now a public method that can accept either the textLayer element
   * to process a whole page, or a specific array of spans for reprocessing.
   * @param textLayerOrSpans The parent .textLayer element OR an array of HTMLSpanElement.
   * @param pageElement The root .page element for context.
   * @returns An array of TranslationUnit[] or null.
   */
  prepareTranslationUnits(textLayerOrSpans, pageElement) {
    const rawSpans = Array.isArray(textLayerOrSpans) ? textLayerOrSpans : Array.from(textLayerOrSpans.querySelectorAll("span"));
    const textSpans = this.validateSpans(rawSpans).filter((span) => this.isValidSpan(span));
    if (textSpans.length === 0) {
      return null;
    }
    const result = this.layoutDetector.detectLayout(textSpans, pageElement);
    this.lastColumnAnalysis = result.columnAnalysis;
    this.clearCaches();
    if (this.plugin.settings.debugMode) {
      console.log(`PDF Translator: Found ${result.paragraphs.length} paragraph(s) to process.`);
    }
    const { maxBatchChars } = this.plugin.settings;
    return result.paragraphs.flatMap((paragraphSpans, paraIndex) => {
      if (!paragraphSpans || paragraphSpans.length === 0)
        return [];
      const paragraphId = `para-${paraIndex}`;
      const paragraphAsHtml = this.spansToHtml(paragraphSpans);
      if (paragraphAsHtml.length <= maxBatchChars) {
        if (paragraphAsHtml.length <= 5)
          return [];
        return [{
          originalSpans: paragraphSpans,
          text: paragraphAsHtml,
          id: paragraphId,
          paragraphId
        }];
      }
      if (this.plugin.settings.debugMode) {
        console.log(`PDF Translator: Paragraph ${paraIndex} is too long, splitting into sentences.`);
      }
      const sortedSpans = [...paragraphSpans].sort((a, b) => {
        const rectA = this.getBoundingClientRectCached(a);
        const rectB = this.getBoundingClientRectCached(b);
        if (Math.abs(rectA.top - rectB.top) > 5)
          return rectA.top - rectB.top;
        return rectA.left - rectB.left;
      });
      const sentenceSpanGroups = [];
      let currentSentenceSpans = [];
      const sentenceEndRegex = /[.?!]\s*$/;
      for (const span of sortedSpans) {
        currentSentenceSpans.push(span);
        if (sentenceEndRegex.test((span.textContent || "").trim())) {
          sentenceSpanGroups.push(currentSentenceSpans);
          currentSentenceSpans = [];
        }
      }
      if (currentSentenceSpans.length > 0) {
        sentenceSpanGroups.push(currentSentenceSpans);
      }
      return sentenceSpanGroups.map((spans, sentenceIndex) => {
        const text = this.spansToHtml(spans);
        if (!text || text.length <= 5)
          return null;
        return {
          originalSpans: spans,
          text,
          id: `${paragraphId}-sent-${sentenceIndex}`,
          paragraphId
        };
      }).filter((unit) => !!unit);
    });
  }
  /**
   * MODIFIED: Now a public method.
   * Executes the translation process for a given set of text units.
   * @param units The text units to be translated.
   * @returns A promise that resolves to an array of translated strings.
   */
  async executeTranslation(units) {
    this.translationFailures = [];
    const fullText = units.map((u, i) => `${i + 1}. ${u.text}`).join("\n");
    const { useBatchTranslation: useBatch, maxBatchChars } = this.plugin.settings;
    const shouldUseChunking = useBatch && units.length > 1 && fullText.length > maxBatchChars;
    try {
      let translatedLines;
      if (shouldUseChunking) {
        new import_obsidian7.Notice(`Long page detected. Translating in multiple batches...`, 4e3);
        translatedLines = await this.performChunkedTranslation(units, maxBatchChars);
      } else if (useBatch && units.length > 1) {
        new import_obsidian7.Notice(`Translating ${units.length} segments in a batch...`, 3e3);
        const raw = await this.plugin.translation.translateBatch(fullText, units.length);
        translatedLines = this.extractNumberedLines(raw, units.length);
      } else {
        new import_obsidian7.Notice(`Translating ${units.length} segment(s) sequentially...`, 3e3);
        translatedLines = await this.performSequentialTranslation(units);
      }
      const missingCount = translatedLines.filter((t) => t === "Translation missing").length;
      if (missingCount > 0.5 * units.length && units.length > 1) {
        new import_obsidian7.Notice("\u26A0\uFE0F Invalid response. Falling back to original text.");
        return units.map((u) => u.text);
      } else if (missingCount > 0) {
        new import_obsidian7.Notice(`\u26A0\uFE0F ${missingCount} segments failed translation. See console for details.`);
        this.reportTranslationFailures(units, translatedLines);
      }
      return translatedLines;
    } catch (err) {
      this.plugin.logDebug("Translation failed:", err);
      this.translationFailures.push({
        segmentIndex: -1,
        error: `Batch translation failed: ${err.message || "Unknown error"}`
      });
      throw err;
    }
  }
  async performChunkedTranslation(units, maxChunkChars) {
    const allTranslatedLines = Array(units.length).fill("Translation missing");
    const endsWithSentenceTerminator = (htmlText) => {
      const trimmed = htmlText.trim();
      if (trimmed.endsWith("<br>"))
        return true;
      const regex = /[.?!](?:\s*<\/[bi]>)*\s*$/;
      return regex.test(trimmed);
    };
    const chunks = [];
    let currentChunkText = "";
    let currentChunkIndices = [];
    for (let i = 0; i < units.length; i++) {
      const unit = units[i];
      const line = `${currentChunkIndices.length + 1}. ${unit.text}
`;
      if (currentChunkText.length + line.length > maxChunkChars && currentChunkText.length > 0) {
        const lastUnitIndex = currentChunkIndices[currentChunkIndices.length - 1];
        const lastUnit = units[lastUnitIndex];
        if (currentChunkIndices.length > 1 && !endsWithSentenceTerminator(lastUnit.text)) {
          currentChunkIndices.pop();
          const newChunkText = currentChunkIndices.map((originalIndex, newIndex) => `${newIndex + 1}. ${units[originalIndex].text}`).join("\n");
          chunks.push({ text: newChunkText, originalIndices: [...currentChunkIndices] });
          currentChunkText = "";
          currentChunkIndices = [];
          i = lastUnitIndex - 1;
          continue;
        } else {
          chunks.push({ text: currentChunkText.trim(), originalIndices: [...currentChunkIndices] });
          currentChunkText = "";
          currentChunkIndices = [];
        }
      }
      currentChunkText += `${currentChunkIndices.length + 1}. ${unit.text}
`;
      currentChunkIndices.push(i);
    }
    if (currentChunkText.length > 0) {
      chunks.push({ text: currentChunkText.trim(), originalIndices: currentChunkIndices });
    }
    if (this.plugin.settings.debugMode) {
      console.log(`PDF Translator: Splitting translation into ${chunks.length} chunks.`);
    }
    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];
      try {
        new import_obsidian7.Notice(`Translating batch ${i + 1} of ${chunks.length}...`);
        const raw = await this.plugin.translation.translateBatch(chunk.text, chunk.originalIndices.length);
        const translatedChunkLines = this.extractNumberedLines(raw, chunk.originalIndices.length);
        for (let j = 0; j < translatedChunkLines.length; j++) {
          const originalIndex = chunk.originalIndices[j];
          if (originalIndex !== void 0)
            allTranslatedLines[originalIndex] = translatedChunkLines[j];
        }
      } catch (error) {
        this.plugin.logDebug(`Translation for chunk ${i + 1} failed:`, error);
        new import_obsidian7.Notice(`\u26A0\uFE0F Batch ${i + 1} failed. Original text will be used for that section.`);
        chunk.originalIndices.forEach((originalIndex) => {
          allTranslatedLines[originalIndex] = units[originalIndex].text;
        });
      }
    }
    return allTranslatedLines;
  }
  renderOverlay(units, translatedLines, overlayContainer, pageElement) {
    const reassembledParagraphs = /* @__PURE__ */ new Map();
    units.forEach((unit, index) => {
      const { paragraphId, originalSpans } = unit;
      const translatedLine = translatedLines[index];
      if (!reassembledParagraphs.has(paragraphId))
        reassembledParagraphs.set(paragraphId, { originalSpans: [], translatedText: "" });
      const group = reassembledParagraphs.get(paragraphId);
      group.originalSpans.push(...originalSpans);
      group.translatedText += (group.translatedText ? " " : "") + translatedLine;
    });
    const mergedUnits = [];
    const mergedTranslatedLines = [];
    reassembledParagraphs.forEach((group, paragraphId) => {
      mergedUnits.push({ id: paragraphId, paragraphId, originalSpans: group.originalSpans, text: "" });
      mergedTranslatedLines.push(group.translatedText);
    });
    this.plugin.overlay.renderOverlays(mergedUnits, mergedTranslatedLines, overlayContainer, pageElement);
  }
  spansToHtml(spans) {
    if (!(spans == null ? void 0 : spans.length))
      return "";
    const lines = /* @__PURE__ */ new Map();
    spans.forEach((span) => {
      const lineKey = Math.round(this.getBoundingClientRectCached(span).top);
      if (!lines.has(lineKey))
        lines.set(lineKey, []);
      lines.get(lineKey).push(span);
    });
    return Array.from(lines.entries()).sort((a, b) => a[0] - b[0]).map(([_, lineSpans]) => lineSpans.sort((a, b) => this.getBoundingClientRectCached(a).left - this.getBoundingClientRectCached(b).left).map((span) => {
      const style = this.getComputedStyleCached(span);
      let content = this.escapeHtml(span.textContent || "");
      const isBold = parseInt(style.fontWeight, 10) >= 700 || style.fontWeight === "bold";
      if (isBold)
        content = `<b>${content}</b>`;
      if (style.fontStyle === "italic")
        content = `<i>${content}</i>`;
      return content;
    }).join(" ")).join("<br>");
  }
  escapeHtml(text) {
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  extractNumberedLines(rawText, expectedCount) {
    const lines = Array(expectedCount).fill("Translation missing");
    const regex = /^\s*(\d+)\.\s+(.+?)(?:\n|$)/gm;
    let match, found = 0;
    while ((match = regex.exec(rawText)) !== null) {
      const num = parseInt(match[1], 10) - 1;
      if (num >= 0 && num < expectedCount) {
        lines[num] = match[2].trim();
        found++;
      }
    }
    if (found < expectedCount * 0.5 && found < expectedCount) {
      const rawLines = rawText.trim().split("\n").map((l) => l.trim().replace(/^\s*\d+\.\s*/, ""));
      if (rawLines.length === expectedCount)
        return rawLines;
      for (let i = 0; i < Math.min(rawLines.length, expectedCount); i++)
        lines[i] = rawLines[i];
    }
    return lines;
  }
  isValidSpan(span) {
    const rect = this.getBoundingClientRectCached(span);
    const text = (span.textContent || "").trim();
    if (rect.width <= 1 || rect.height <= 1 || !text)
      return false;
    if (/^\d{1,3}$/.test(text))
      return false;
    if (text.length === 1 && /[\-]/.test(text))
      return false;
    if (text.startsWith("http"))
      return false;
    return true;
  }
  validateSpans(spans) {
    return spans.filter((span) => span instanceof HTMLSpanElement && span.isConnected);
  }
  validatePageElement(pageElement) {
    return pageElement instanceof HTMLElement && pageElement.isConnected;
  }
  getBoundingClientRectCached(element) {
    const now = Date.now();
    const cached = this.measurementCache.get(element);
    if (cached && now - cached.timestamp < 100)
      return cached.rect;
    const rect = element.getBoundingClientRect();
    this.measurementCache.set(element, { rect, timestamp: now });
    return rect;
  }
  getComputedStyleCached(element) {
    return this.styleCache.get(element) || this.styleCache.set(element, window.getComputedStyle(element)).get(element);
  }
  clearCaches() {
    this.measurementCache.clear();
    this.styleCache.clear();
    if (this.colorDistanceCache.size > 1e3)
      this.colorDistanceCache.clear();
  }
  getSpansBbox(spans, pageElement) {
    if (!(spans == null ? void 0 : spans.length))
      return { rect: null, fontSizes: [], avgFontSize: 12, fontFamily: "sans-serif" };
    const pageRect = pageElement.getBoundingClientRect();
    let left = Infinity, top = Infinity, right = -Infinity, bottom = -Infinity;
    const fontSizes = [];
    let fontFamily = "sans-serif";
    for (const span of spans) {
      const rect2 = this.getBoundingClientRectCached(span);
      left = Math.min(left, rect2.left);
      top = Math.min(top, rect2.top);
      right = Math.max(right, rect2.right);
      bottom = Math.max(bottom, rect2.bottom);
      const style = this.getComputedStyleCached(span);
      fontSizes.push(parseFloat(style.fontSize) || 12);
      if (fontFamily === "sans-serif" && style.fontFamily)
        fontFamily = style.fontFamily.split(",")[0].replace(/['"]/g, "").trim();
    }
    if (!isFinite(left))
      return { rect: null, fontSizes: [], avgFontSize: 12, fontFamily };
    const rect = new DOMRect(left - pageRect.left, top - pageRect.top, right - left, bottom - top);
    const avgFontSize = fontSizes.reduce((a, b) => a + b, 0) / fontSizes.length || 12;
    return { rect, fontSizes, avgFontSize, fontFamily };
  }
  async performSequentialTranslation(units) {
    return Promise.all(units.map(async (unit, i) => {
      try {
        return await this.plugin.translation.translateWithOpenRouter(unit.text);
      } catch (error) {
        this.plugin.logDebug(`Translation failed for segment ${i}:`, error);
        this.translationFailures.push({ segmentIndex: i, error: error.message || "Unknown error" });
        return "Translation missing";
      }
    }));
  }
  reportTranslationFailures(units, translatedLines) {
    this.translationFailures.forEach(({ segmentIndex, error }) => {
      if (segmentIndex >= 0)
        this.plugin.logDebug(`Segment ${segmentIndex + 1} failed:`, error, `Original: "${units[segmentIndex].text.substring(0, 100)}..."`);
      else
        this.plugin.logDebug(`Batch translation failed:`, error);
    });
    for (let i = 0; i < translatedLines.length; i++) {
      if (translatedLines[i] === "Translation missing") {
        this.plugin.logDebug(`Segment ${i + 1} was missing from the batch response. Original: "${units[i].text.substring(0, 100)}..."`);
        translatedLines[i] = units[i].text;
      }
    }
  }
  cleanup() {
    this.overlayContainers.forEach((container) => container.remove());
    this.overlayContainers = [];
    this.clearCaches();
    this.translationFailures = [];
    this.lastColumnAnalysis = null;
    this.lastPreparedUnits = null;
  }
};

// modal.ts
var import_obsidian8 = require("obsidian");
var _TranslateMultiplePagesModal = class extends import_obsidian8.Modal {
  constructor(plugin, file) {
    super(plugin.app);
    // User-configurable settings for the current job
    this.startPage = 1;
    this.endPage = 1;
    this.totalPages = 1;
    this.useTimeWindow = false;
    this.timeWindowHours = 2;
    // Default time window of 2 hours
    // Internal state management
    this.isProcessing = false;
    this.isCancelled = false;
    this.activeOverlays = [];
    this.retryTimeout = 0;
    // NEW: Cache to store translated text, preventing data loss on DOM errors.
    this.translationCache = /* @__PURE__ */ new Map();
    // State for pacing
    this.pacingDelay = 200;
    // Default "sprint" delay
    // Properties for live progress tracking
    this.progressMessage = "Initializing...";
    this.progressEl = null;
    this.plugin = plugin;
    this.file = file;
  }
  /**
   * Called when the modal is opened. Renders the UI.
   */
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    if (_TranslateMultiplePagesModal.isBulkTranslationInProgress && _TranslateMultiplePagesModal.currentInstance) {
      this.displayManagementView(contentEl);
      return;
    }
    this.titleEl.setText("Translate Multiple Pages");
    contentEl.createEl("p", { text: `File: ${this.file.basename}` });
    this.totalPages = await this.estimateTotalPages();
    this.endPage = this.totalPages;
    contentEl.createEl("p", { text: `Estimated total pages: ${this.totalPages}` });
    this.renderSettings(contentEl);
    const progressContainer = contentEl.createDiv({ cls: "translator-progress-container" });
    this.progressEl = progressContainer;
    const buttonContainer = contentEl.createDiv({ cls: "translator-button-container" });
    this.renderActionButtons(buttonContainer);
  }
  /**
   * Renders a view to manage an in-progress translation job.
   */
  displayManagementView(contentEl) {
    this.titleEl.setText("Translation in Progress");
    const instance = _TranslateMultiplePagesModal.currentInstance;
    if (!instance) {
      contentEl.setText("Could not find the active translation process.");
      return;
    }
    contentEl.createEl("p", { text: "A batch translation is already running." });
    const progressDisplay = contentEl.createEl("p", { cls: "translator-progress-display" });
    progressDisplay.setText(instance.progressMessage);
    const intervalId = window.setInterval(() => {
      if (_TranslateMultiplePagesModal.isBulkTranslationInProgress && instance) {
        progressDisplay.setText(instance.progressMessage);
      } else {
        window.clearInterval(intervalId);
        new import_obsidian8.Notice("Translation job has finished.");
        this.close();
      }
    }, 1e3);
    const buttonContainer = contentEl.createDiv({ cls: "translator-button-container" });
    new import_obsidian8.ButtonComponent(buttonContainer).setButtonText("Cancel Translation").setWarning().onClick(() => {
      if (_TranslateMultiplePagesModal.cancelCurrentTranslation()) {
        new import_obsidian8.Notice("Translation aborted.");
      }
      this.close();
    });
    new import_obsidian8.ButtonComponent(buttonContainer).setButtonText("Close").onClick(() => this.close());
  }
  /**
   * Renders the settings for page range and time window.
   */
  renderSettings(contentEl) {
    let startInput;
    let endInput;
    new import_obsidian8.Setting(contentEl).setName("Start page").addText((cb) => {
      startInput = cb.el;
      cb.setValue(String(this.startPage)).onChange((value) => {
        const n = parseInt(value, 10);
        if (!isNaN(n) && n >= 1 && n <= this.totalPages)
          this.startPage = n;
      });
    });
    new import_obsidian8.Setting(contentEl).setName("End page").addText((cb) => {
      endInput = cb.el;
      cb.setValue(String(this.endPage)).onChange((value) => {
        const n = parseInt(value, 10);
        if (!isNaN(n) && n >= this.startPage && n <= this.totalPages)
          this.endPage = n;
      });
    });
    new import_obsidian8.Setting(contentEl).addButton((cb) => {
      cb.setButtonText("All Pages").setCta().onClick(() => {
        this.startPage = 1;
        this.endPage = this.totalPages;
        startInput.value = "1";
        endInput.value = String(this.totalPages);
      });
    });
    const timeWindowSetting = new import_obsidian8.Setting(contentEl).setName("Use Time Window").setDesc("Distribute translations over a set time to avoid rate limits. If off, it will run as fast as possible.").addToggle((toggle) => toggle.setValue(this.useTimeWindow).onChange((value) => {
      this.useTimeWindow = value;
      timeInputSetting.settingEl.style.display = value ? "" : "none";
    }));
    const timeInputSetting = new import_obsidian8.Setting(contentEl).setName("Job Time (Hours)").setDesc("The total time to spread the translation job over.").addText((text) => text.setValue(String(this.timeWindowHours)).onChange((value) => {
      const n = parseFloat(value);
      if (!isNaN(n) && n > 0)
        this.timeWindowHours = n;
    }));
    timeInputSetting.settingEl.style.display = this.useTimeWindow ? "" : "none";
  }
  /**
   * Renders the Start and Abort buttons.
   */
  renderActionButtons(container) {
    const startButton = new import_obsidian8.ButtonComponent(container).setButtonText("Start Translation").setCta().onClick(async () => {
      if (this.startPage > this.endPage) {
        new import_obsidian8.Notice("Start page must be less than or equal to End page.");
        return;
      }
      this.initializeJobState();
      startButton.setDisabled(true);
      abortButton.setDisabled(false);
      this.updateProgress("Starting translation job...");
      try {
        await this.translatePageRange(this.file, this.startPage, this.endPage);
        if (!this.isCancelled) {
          this.close();
        }
      } catch (err) {
        new import_obsidian8.Notice("Error: " + (err.message || "Unknown error"), 7e3);
        console.error("Bulk translation failed:", err);
      } finally {
        this.cleanup();
        if (!this.isCancelled) {
          startButton.setDisabled(false);
        }
        abortButton.setDisabled(true);
      }
    });
    const abortButton = new import_obsidian8.ButtonComponent(container).setButtonText("Abort").setDisabled(true).onClick(() => {
      if (this.isProcessing) {
        new import_obsidian8.Notice("Aborting translation...");
        this.isCancelled = true;
        abortButton.setButtonText("Aborting...").setDisabled(true);
      }
    });
  }
  /**
   * Sets the initial state for a new translation job.
   */
  initializeJobState() {
    this.isProcessing = true;
    this.isCancelled = false;
    _TranslateMultiplePagesModal.isBulkTranslationInProgress = true;
    _TranslateMultiplePagesModal.currentInstance = this;
  }
  /**
   * Centralized method for updating the progress message.
   */
  updateProgress(msg) {
    this.progressMessage = msg;
    if (this.progressEl) {
      this.progressEl.setText(msg);
    }
  }
  /**
   * The main logic loop for processing a range of pages.
   */
  async translatePageRange(pdfFile, startPage, endPage) {
    var _a;
    const pdfLeaf = this.app.workspace.getLeavesOfType("pdf")[0] || this.app.workspace.getMostRecentLeaf();
    if (!pdfLeaf) {
      throw new Error("No available workspace leaf to open PDF.");
    }
    try {
      await pdfLeaf.openFile(pdfFile);
      if (!await this.waitForEl(".pdfViewer", 1e4))
        throw new Error("Failed to load PDF viewer.");
    } catch (err) {
      throw new Error("Could not open the specified PDF file.");
    }
    const originalAutoSave = this.plugin.settings.autoSaveOverlay;
    this.plugin.settings.autoSaveOverlay = true;
    let completed = 0, failed = 0;
    const totalPagesToProcess = endPage - startPage + 1;
    const processingQueue = Array.from({ length: totalPagesToProcess }, (_, i) => startPage + i);
    if (this.useTimeWindow && this.timeWindowHours > 0 && totalPagesToProcess > 0) {
      const totalMilliseconds = this.timeWindowHours * 3600 * 1e3;
      this.pacingDelay = totalMilliseconds / totalPagesToProcess;
      const paceInSeconds = Math.round(this.pacingDelay / 1e3);
      this.updateProgress(`Pacing enabled. Each page will be processed approx. every ${paceInSeconds} seconds.`);
      await this.sleep(1e3);
    } else {
      this.pacingDelay = 200;
    }
    try {
      while (processingQueue.length > 0) {
        if (this.isCancelled) {
          this.updateProgress("\u23F9\uFE0F Translation cancelled by user.");
          return;
        }
        const pageNum = processingQueue.shift();
        const progressPrefix = `[${completed + 1}/${totalPagesToProcess}]`;
        this.updateProgress(`${progressPrefix} \u{1F504} Processing page ${pageNum}...`);
        try {
          await this.retryWithBackoff(async () => {
            const navSuccess = await this.navigateToPage(pdfLeaf, pageNum);
            if (!navSuccess)
              throw new Error("Navigation failed.");
            const pageEl = await this.waitForPageAndTextLayer(pageNum, 3e4);
            if (!pageEl)
              throw new Error("Page or text layer failed to render.");
            let translatedText = this.translationCache.get(pageNum);
            if (!translatedText) {
              this.updateProgress(`${progressPrefix} \u270D\uFE0F Translating page ${pageNum}...`);
              translatedText = await this.plugin.processor.translatePageContent(pageEl);
              if (!translatedText || translatedText.trim() === "") {
                throw new Error("Translation returned empty content.");
              }
              this.translationCache.set(pageNum, translatedText);
            } else {
              this.updateProgress(`${progressPrefix} \u{1F4C4} Using cached translation for page ${pageNum}.`);
            }
            await this.plugin.processor.createOverlayWithText(pageEl, translatedText);
            const newOverlay = pageEl.querySelector(".pdf-text-overlay-container");
            if (!newOverlay) {
              throw new Error("Overlay element was not found after creation.");
            }
            const overlayText = newOverlay.innerText.trim();
            const verificationSnippet = translatedText.substring(0, 50);
            if (!overlayText.includes(verificationSnippet)) {
              console.error(`Verification FAILED for page ${pageNum}. Overlay text did not match translated text.`);
              console.log("Expected snippet:", verificationSnippet);
              console.log("Actual overlay text:", overlayText.substring(0, 100));
              throw new Error("Overlay content verification failed.");
            }
            this.activeOverlays.push(newOverlay);
          }, pageNum);
          completed++;
          this.updateProgress(`${progressPrefix} \u2705 Page ${pageNum} complete.`);
          if (this.activeOverlays.length > 5) {
            const oldOverlay = this.activeOverlays.shift();
            (_a = oldOverlay == null ? void 0 : oldOverlay.parentElement) == null ? void 0 : _a.removeChild(oldOverlay);
          }
        } catch (err) {
          if (this.isCancelled)
            break;
          console.error(`Page ${pageNum} failed permanently after all retries:`, err);
          this.updateProgress(`${progressPrefix} \u274C Page ${pageNum} failed: ${err.message || "Unknown error"}`);
          failed++;
        }
        if (this.pacingDelay > 1e3) {
          this.updateProgress(`Pacing... Next page in ${Math.round(this.pacingDelay / 1e3)}s`);
        }
        await this.sleep(this.pacingDelay);
      }
    } finally {
      this.plugin.settings.autoSaveOverlay = originalAutoSave;
      const summary = `\u{1F3C1} Finished: ${completed}/${totalPagesToProcess} succeeded${failed ? `, ${failed} failed` : ""}.`;
      this.updateProgress(summary);
      new import_obsidian8.Notice(summary, 7e3);
    }
  }
  /**
   * A robust retry mechanism that handles transient errors.
   */
  async retryWithBackoff(operation, pageNum) {
    const maxRetries = 3;
    const baseDelay = 1500;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      if (this.isCancelled)
        throw new Error("Operation cancelled");
      try {
        return await operation();
      } catch (error) {
        if (attempt < maxRetries - 1) {
          const delay = baseDelay * Math.pow(2, attempt);
          this.updateProgress(`Page ${pageNum} failed (attempt ${attempt + 1}), retrying in ${delay / 1e3}s...`);
          await this.sleep(delay);
        } else {
          throw error;
        }
      }
    }
    throw new Error("Retry mechanism failed unexpectedly.");
  }
  onClose() {
    this.contentEl.empty();
    if (this.isProcessing) {
      this.cleanup();
    }
  }
  cleanup() {
    this.isProcessing = false;
    this.translationCache.clear();
    this.activeOverlays.forEach((overlay) => {
      var _a;
      return (_a = overlay.parentElement) == null ? void 0 : _a.removeChild(overlay);
    });
    this.activeOverlays = [];
    clearTimeout(this.retryTimeout);
    if (_TranslateMultiplePagesModal.currentInstance === this) {
      _TranslateMultiplePagesModal.isBulkTranslationInProgress = false;
      _TranslateMultiplePagesModal.currentInstance = null;
    }
  }
  async estimateTotalPages() {
    await this.sleep(500);
    const viewer = await this.waitForEl(".pdfViewer", 8e3);
    return (viewer == null ? void 0 : viewer.querySelectorAll(".page[data-page-number]").length) || 1;
  }
  async navigateToPage(pdfLeaf, pageNum) {
    if (this.isCancelled)
      return false;
    const pdfView = pdfLeaf.view;
    const pageEl = document.querySelector(`.page[data-page-number="${pageNum}"]`);
    if (!pdfView || !pageEl) {
      console.error(`PDF view or page element ${pageNum} not found.`);
      return false;
    }
    pageEl.scrollIntoView({ block: "nearest" });
    const success = await this.waitForCondition(() => {
      const rect = pageEl.getBoundingClientRect();
      const viewHeight = window.innerHeight || document.documentElement.clientHeight;
      return rect.bottom > 0 && rect.top < viewHeight;
    }, 15e3);
    if (!success)
      console.warn(`Failed to confirm page ${pageNum} is in view.`);
    await this.sleep(500);
    return true;
  }
  async waitForPageAndTextLayer(pageNum, timeoutMs) {
    return this.waitForCondition(async () => {
      var _a, _b, _c;
      const pageEl = document.querySelector(`.page[data-page-number="${pageNum}"] .textLayer`);
      const hasText = (_c = (_b = (_a = pageEl == null ? void 0 : pageEl.querySelector('span[role="presentation"]')) == null ? void 0 : _a.textContent) == null ? void 0 : _b.trim().length) != null ? _c : 0 > 0;
      return hasText ? pageEl.parentElement : null;
    }, timeoutMs, 250);
  }
  async sleep(ms) {
    return new Promise((resolve) => {
      if (this.isCancelled)
        return resolve();
      this.retryTimeout = window.setTimeout(resolve, ms);
    });
  }
  async waitForEl(selector, timeoutMs) {
    return this.waitForCondition(() => document.querySelector(selector), timeoutMs);
  }
  async waitForCondition(condition, timeoutMs, intervalMs = 100) {
    const start = Date.now();
    while (Date.now() - start < timeoutMs) {
      if (this.isCancelled)
        return null;
      const result = condition();
      if (result)
        return result;
      await this.sleep(intervalMs);
    }
    return null;
  }
  static isTranslationInProgress() {
    return this.isBulkTranslationInProgress;
  }
  static cancelCurrentTranslation() {
    var _a;
    if ((_a = this.currentInstance) == null ? void 0 : _a.isProcessing) {
      this.currentInstance.isCancelled = true;
      return true;
    }
    return false;
  }
};
var TranslateMultiplePagesModal = _TranslateMultiplePagesModal;
// Static properties to ensure only one bulk translation runs at a time
TranslateMultiplePagesModal.isBulkTranslationInProgress = false;
TranslateMultiplePagesModal.currentInstance = null;

// reprocessor.ts
var import_obsidian9 = require("obsidian");
var RegionReprocessor = class {
  constructor(plugin) {
    this.isDragging = false;
    this.dragStart = null;
    this.box = null;
    this.cleanup = /* @__PURE__ */ new Set();
    this.isActive = false;
    this.frameId = null;
    this.debugGuides = /* @__PURE__ */ new Set();
    this.plugin = plugin;
    this.debug = plugin.settings.debugMode;
  }
  /**
   * Starts a new reprocessing session.
   */
  start() {
    if (this.isActive) {
      new import_obsidian9.Notice("Another reprocessing session is active. Canceling previous one.");
      this.cleanupAll();
    }
    this.isActive = true;
    void this.run();
  }
  /**
   * Sets up drag-to-select event listeners on the current PDF page.
   */
  async run() {
    const { app, settings } = this.plugin;
    if (this.debug) {
      console.log("[RegionReprocessor] Starting \u2013 waiting for Shift+drag...");
    }
    if (!settings.enableTranslation) {
      new import_obsidian9.Notice("PDF translation is disabled in settings.");
      this.finish();
      return;
    }
    const file = app.workspace.getActiveFile();
    if (!file || file.extension !== "pdf") {
      new import_obsidian9.Notice("Please open a PDF file first.");
      this.finish();
      return;
    }
    const pageNumber = this.plugin.getCurrentPageNumber();
    if (!pageNumber) {
      new import_obsidian9.Notice("No page currently visible.");
      this.finish();
      return;
    }
    const pageEl = document.querySelector(`.page[data-page-number="${pageNumber}"]`);
    if (!pageEl) {
      new import_obsidian9.Notice("Page is not rendered. Please scroll into view.");
      this.finish();
      return;
    }
    const textLayer = pageEl.querySelector(".textLayer");
    if (!textLayer) {
      new import_obsidian9.Notice("Text layer not ready. Please wait for PDF to render.");
      this.finish();
      return;
    }
    new import_obsidian9.Notice("\u{1F524} Hold Shift + drag to reprocess a region", 3e3);
    const registerListener = (target, type, handler) => {
      const cleanup = () => target.removeEventListener(type, handler);
      this.cleanup.add(cleanup);
      target.addEventListener(type, handler);
    };
    const onMouseDown = (e) => {
      var _a;
      if (!e.shiftKey)
        return;
      e.preventDefault();
      e.stopPropagation();
      if (this.isDragging)
        return;
      this.isDragging = true;
      this.dragStart = { x: e.clientX, y: e.clientY };
      (_a = this.box) == null ? void 0 : _a.remove();
      this.box = createEl("div", { cls: "pdf-translation-selection-box" });
      Object.assign(this.box.style, {
        position: "fixed",
        left: "0px",
        top: "0px",
        width: "0px",
        height: "0px",
        border: "2px dashed rgba(0, 120, 255, 0.8)",
        background: "rgba(0, 120, 255, 0.1)",
        pointerEvents: "none",
        zIndex: "99999",
        boxSizing: "border-box",
        borderRadius: "2px",
        boxShadow: "0 0 6px rgba(0, 0, 0, 0.2)",
        transform: "translateZ(0)",
        willChange: "transform"
      });
      document.body.appendChild(this.box);
    };
    const onMouseMove = (e) => {
      if (!this.isDragging || !this.dragStart || !this.box)
        return;
      e.preventDefault();
      if (this.frameId !== null)
        return;
      this.frameId = window.requestAnimationFrame(() => {
        this.frameId = null;
        const { clientX, clientY } = e;
        const { x: startX, y: startY } = this.dragStart;
        const left = Math.min(startX, clientX);
        const top = Math.min(startY, clientY);
        const width = Math.abs(clientX - startX);
        const height = Math.abs(clientY - startY);
        this.box.style.transform = `translate(${left}px, ${top}px)`;
        this.box.style.width = `${width}px`;
        this.box.style.height = `${height}px`;
      });
    };
    const onMouseUp = (e) => {
      if (!this.isDragging)
        return;
      e.preventDefault();
      e.stopPropagation();
      this.isDragging = false;
      if (this.frameId !== null) {
        cancelAnimationFrame(this.frameId);
        this.frameId = null;
      }
      const rect = new DOMRect(
        Math.min(this.dragStart.x, e.clientX),
        Math.min(this.dragStart.y, e.clientY),
        Math.abs(e.clientX - this.dragStart.x),
        Math.abs(e.clientY - this.dragStart.y)
      );
      this.cleanupAll();
      if (rect.width > 5 && rect.height > 5) {
        void this.handleRegionReprocessing(rect, pageNumber, file);
      } else {
        this.finish();
      }
    };
    const onKeyDown = (e) => {
      if (e.key === "Escape") {
        new import_obsidian9.Notice("Region selection canceled.");
        this.cleanupAll();
        this.finish();
      }
    };
    registerListener(pageEl, "mousedown", onMouseDown);
    registerListener(document, "mousemove", onMouseMove);
    registerListener(document, "mouseup", onMouseUp);
    registerListener(document, "keydown", onKeyDown);
    const timeoutId = window.setTimeout(() => {
      if (this.isActive) {
        new import_obsidian9.Notice("Region selection timed out.", 2e3);
        this.cleanupAll();
        this.finish();
      }
    }, 15e3);
    this.cleanup.add(() => clearTimeout(timeoutId));
  }
  /**
   * REFACTORED: Processes the selected region by delegating paragraph detection
   * and translation to the main TextProcessor, then handles saving the results.
   * Calculates original font sizes correctly based on the current viewer scale.
   */
  async handleRegionReprocessing(screenRect, pageNumber, file) {
    const pageEl = document.querySelector(`.page[data-page-number="${pageNumber}"]`);
    const textLayer = pageEl == null ? void 0 : pageEl.querySelector(".textLayer");
    if (!pageEl || !textLayer) {
      new import_obsidian9.Notice("\u26A0\uFE0F Page or text layer not available.");
      this.finish();
      return;
    }
    const selectedSpans = Array.from(textLayer.querySelectorAll("span")).filter((span) => {
      const r = span.getBoundingClientRect();
      const overlaps = !(r.right < screenRect.left || r.left > screenRect.right || r.bottom < screenRect.top || r.top > screenRect.bottom);
      return overlaps;
    }).filter((span) => this.plugin.processor.isValidSpan(span));
    if (selectedSpans.length === 0) {
      new import_obsidian9.Notice("\u26A0\uFE0F No valid text found in selected region.");
      this.finish();
      return;
    }
    const translationUnits = this.plugin.processor.prepareTranslationUnits(selectedSpans, pageEl);
    if (!translationUnits || translationUnits.length === 0) {
      new import_obsidian9.Notice("No translatable segments found in the selected region.");
      this.finish();
      return;
    }
    new import_obsidian9.Notice(`\u{1F501} Translating ${translationUnits.length} segment(s)...`, 3e3);
    let translatedTexts;
    try {
      translatedTexts = await this.plugin.processor.executeTranslation(translationUnits);
    } catch (err) {
      console.error("[RegionReprocessor] Translation failed:", err);
      new import_obsidian9.Notice(`\u274C Translation failed: ${err.message}. Using original text.`);
      translatedTexts = translationUnits.map((u) => u.text);
    }
    const newItems = [];
    const pdfViewer = pageEl.closest(".pdfViewer, #viewer");
    const currentScaleFromViewer = parseFloat((pdfViewer == null ? void 0 : pdfViewer.style.getPropertyValue("--scale-factor")) || "1");
    if (isNaN(currentScaleFromViewer) || currentScaleFromViewer <= 0) {
      console.warn("[RegionReprocessor] Invalid scale factor found, defaulting to 1.0");
    }
    for (let i = 0; i < translationUnits.length; i++) {
      const { originalSpans, text } = translationUnits[i];
      if (originalSpans.length === 0)
        continue;
      const bboxResult = this.plugin.processor.getSpansBbox(originalSpans, pageEl);
      if (!bboxResult || !bboxResult.rect)
        continue;
      const rawBbox = bboxResult.rect;
      const pageRect = pageEl.getBoundingClientRect();
      const relativeRect = {
        left: rawBbox.left / pageRect.width,
        // rawBbox.left is relative to pageEl's content (scaled)
        top: rawBbox.top / pageRect.height,
        // rawBbox.top is relative to pageEl's content (scaled)
        width: rawBbox.width / pageRect.width,
        height: rawBbox.height / pageRect.height
      };
      if (Object.values(relativeRect).some((v) => !isFinite(v)) || relativeRect.width <= 0 || relativeRect.height <= 0) {
        console.debug("[RegionReprocessor] Skipping item with invalid relative rect:", relativeRect);
        continue;
      }
      const observedAvgFontSize = bboxResult.avgFontSize;
      const observedOriginalFontSizes = bboxResult.fontSizes;
      const baseAvgFontSize = observedAvgFontSize / currentScaleFromViewer;
      const baseOriginalFontSizes = observedOriginalFontSizes.map((fs) => fs / currentScaleFromViewer);
      newItems.push({
        selector: "",
        // Not used for saved overlays typically
        textContent: text,
        // Original HTML text content
        translatedText: translatedTexts[i] || text,
        // Translated text
        relativeRect,
        // Relative position
        page: pageNumber,
        // Page number
        // Store the *base* (unscaled) font sizes, as expected by OverlayUIRenderer
        originalFontSizes: baseOriginalFontSizes,
        fontFamily: bboxResult.fontFamily,
        // fontSize is often derived from originalFontSizes or not strictly needed if originalFontSizes is present
        // If you still want to store it, store the base size:
        fontSize: baseAvgFontSize,
        id: `reproc-${Date.now()}-${i}`
        // Unique ID for the item
      });
    }
    if (newItems.length === 0) {
      new import_obsidian9.Notice("\u26A0\uFE0F No valid layout regions could be generated from the selection.");
      this.finish();
      return;
    }
    const savedOverlay = await this.loadSavedOverlay(file);
    const pageKey = String(pageNumber);
    const existingItems = savedOverlay.pageOverlays[pageKey] || [];
    const nonOverlappingOldItems = existingItems.filter(
      (oldItem) => !newItems.some((newItem) => this.isOverlapping(oldItem.relativeRect, newItem.relativeRect))
    );
    savedOverlay.pageOverlays[pageKey] = [...nonOverlappingOldItems, ...newItems];
    savedOverlay.timestamp = Date.now();
    await this.saveOverlay(savedOverlay, file);
    this.plugin.clearAllOverlays();
    await this.plugin.storage.loadSavedOverlayForCurrentPage(file, true);
    new import_obsidian9.Notice(`\u2705 Reprocessed and saved ${newItems.length} segment(s)`);
    this.finish();
  }
  async loadSavedOverlay(file) {
    const { storage } = this.plugin;
    const result = await storage.readSavedOverlayForFile(file);
    return (result == null ? void 0 : result.overlay) || {
      fileName: file.basename.replace(/\.pdf$/i, ""),
      filePath: file.path,
      timestamp: Date.now(),
      pageOverlays: {}
    };
  }
  async saveOverlay(savedOverlay, file) {
    await this.plugin.storage.writeSavedOverlayForFile(file, savedOverlay);
    if (this.debug) {
      console.log(`[RegionReprocessor] Saved updates for ${file.path}`);
    }
  }
  isOverlapping(a, b) {
    const eps = 1e-5;
    return !(a.left + a.width < b.left - eps || b.left + b.width < a.left - eps || a.top + a.height < b.top - eps || b.top + b.height < a.top - eps);
  }
  cleanupAll() {
    var _a;
    this.cleanup.forEach((fn) => fn());
    this.cleanup.clear();
    (_a = this.box) == null ? void 0 : _a.remove();
    this.box = null;
    this.dragStart = null;
    this.isDragging = false;
    if (this.frameId !== null) {
      cancelAnimationFrame(this.frameId);
      this.frameId = null;
    }
    this.debugGuides.forEach((el) => el.remove());
    this.debugGuides.clear();
  }
  finish() {
    this.cleanupAll();
    this.isActive = false;
  }
};

// main.ts
var OpenRouterTranslatorPlugin = class extends import_obsidian10.Plugin {
  constructor() {
    super(...arguments);
    // Fast lookup: PDF path  .translations.md file path
    this.pdfToMdMap = /* @__PURE__ */ new Map();
    this.overlayCleanupFunctions = /* @__PURE__ */ new Set();
  }
  async onload() {
    console.log("\u{1F9E9} OpenRouter PDF Translator plugin loaded");
    await this.loadSettings();
    this.debouncedBuildMap = (0, import_obsidian10.debounce)(async () => {
      this.logDebug("Debounced: Rebuilding PDF map...");
      await this.buildPdfTranslationMap();
      await this.refreshAffectedOverlays();
    }, 500, true);
    this.isReady = new Promise((resolve) => {
      this.resolveReady = resolve;
    });
    this.translation = new TranslationEngine(this);
    this.overlay = new OverlayRenderer(this);
    this.processor = new TextProcessor(this);
    this.storage = new TranslationStorage(this);
    this.app.workspace.onLayoutReady(async () => {
      this.logDebug("Layout ready. Building initial translation map...");
      await this.buildPdfTranslationMap();
      this.resolveReady();
      await this.isReady;
      const activeLeaf = this.app.workspace.activeLeaf;
      if (activeLeaf && activeLeaf.view.getViewType() === "pdf") {
        this.overlay.setupPDFMonitoring(activeLeaf);
        await this.refreshAffectedOverlays();
      }
    });
    this.registerEvent(this.app.metadataCache.on("changed", (file) => {
      if (this.isTranslationFile(file)) {
        this.logDebug(`Translation file changed: ${file.path}. Rebuilding map.`);
        this.debouncedBuildMap();
      }
    }));
    this.registerEvent(this.app.vault.on("rename", async (file, oldPath) => {
      var _a;
      if (!(file instanceof import_obsidian10.TFile))
        return;
      if (file.extension === "pdf") {
        const mdPath = this.pdfToMdMap.get(oldPath);
        if (mdPath) {
          setTimeout(async () => {
            try {
              const mdFile = this.app.vault.getAbstractFileByPath(mdPath);
              if (mdFile instanceof import_obsidian10.TFile) {
                const newMdPath = this.storage.getTranslationFilePath(file);
                if ((0, import_obsidian10.normalizePath)(mdFile.path) !== (0, import_obsidian10.normalizePath)(newMdPath)) {
                  await this.app.vault.rename(mdFile, newMdPath);
                }
              }
            } catch (e) {
              console.error(e);
            } finally {
              this.debouncedBuildMap();
            }
          }, 200);
        }
      } else if (this.isTranslationFile(file)) {
        const oldPdfPath = (_a = [...this.pdfToMdMap.entries()].find(([_, md]) => md === oldPath)) == null ? void 0 : _a[0];
        if (oldPdfPath)
          this.pdfToMdMap.delete(oldPdfPath);
        this.debouncedBuildMap();
      }
    }));
    this.registerEvent(this.app.vault.on("delete", async (file) => {
      var _a;
      if (file instanceof import_obsidian10.TFile && this.isTranslationFile(file)) {
        const oldPdfPath = (_a = [...this.pdfToMdMap.entries()].find(([_, mdPath]) => mdPath === file.path)) == null ? void 0 : _a[0];
        if (oldPdfPath)
          this.pdfToMdMap.delete(oldPdfPath);
        this.debouncedBuildMap();
      }
    }));
    this.addCommand({
      id: "rebuild-pdf-translation-map",
      name: "Rebuild PDF-to-translation file map",
      callback: async () => {
        new import_obsidian10.Notice("Rebuilding map...");
        await this.buildPdfTranslationMap();
        await this.refreshAffectedOverlays();
        new import_obsidian10.Notice("Map rebuilt.");
      }
    });
    this.addCommand({
      id: "translate-multiple-pages",
      name: "Translate multiple pages...",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (file && file.extension === "pdf") {
          new TranslateMultiplePagesModal(this, file).open();
        } else {
          new import_obsidian10.Notice("Please open a PDF first.");
        }
      }
    });
    this.addCommand({
      id: "adjust-layout-settings",
      name: "Adjust Layout Detector Settings...",
      callback: () => {
        showLayoutSettingsModal(this.layoutSettings, (newSettings) => {
          this.activateLayoutSettings(newSettings, null);
        });
      }
    });
    this.addCommand({
      id: "quick-switch-layout-preset",
      name: "Layout: Quick switch preset...",
      callback: () => {
        new PresetFuzzyModal(this.app, this).open();
      }
    });
    const savedPresets = PresetManager.getAllPresets();
    savedPresets.forEach((preset) => {
      this.addCommand({
        id: `load-layout-preset-${preset.id}`,
        name: `Layout Preset: Load "${preset.name}"`,
        callback: () => this.activateLayoutSettings(preset.settings, preset.name)
      });
    });
    this.addCommand({
      id: "add-pdf-text-overlay",
      name: "Translate and add overlay to current PDF page",
      callback: () => this.processor.addTextOverlay()
    });
    this.addCommand({
      id: "save-pdf-overlay",
      name: "Save current PDF overlay",
      callback: () => this.storage.saveCurrentOverlay()
    });
    this.addCommand({
      id: "refresh-pdf-overlay",
      name: "Refresh current PDF overlay",
      callback: () => this.overlay.refreshCurrentOverlay()
    });
    this.addCommand({
      id: "delete-pdf-overlay",
      name: "Delete current PDF overlay",
      callback: () => this.storage.deleteCurrentOverlay()
    });
    this.addCommand({
      id: "toggle-pdf-overlay",
      name: "Toggle PDF overlay visibility",
      callback: () => this.overlay.toggleOverlayVisibility()
    });
    this.addCommand({
      id: "retranslate-using-overlays",
      name: "Re-translate using saved overlay boxes\u2026",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (file && file.extension === "pdf") {
          new RetranslateUsingOverlaysModal(this.app, this, file).open();
        } else {
          new import_obsidian10.Notice("Please open a PDF first.");
        }
      }
    });
    this.addCommand({
      id: "retranslate-region-fast",
      name: "Re-translate region by dragging (fast)",
      callback: () => new RegionReprocessor(this).start()
    });
    this.registerEvent(this.app.workspace.on("active-leaf-change", (leaf) => {
      if (leaf && leaf.view.getViewType() === "pdf") {
        setTimeout(() => this.overlay.setupPDFMonitoring(leaf), 300);
      }
    }));
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian10.TFile && file.extension === "pdf") {
          this.overlay.addOverlayToggleToPDFMenu(menu, file);
        }
      })
    );
    this.addSettingTab(new OpenRouterSettingsTab(this.app, this));
  }
  isTranslationFile(file) {
    return file instanceof import_obsidian10.TFile && file.extension === "md" && file.name.endsWith(".translations.md");
  }
  async activateLayoutSettings(newSettings, presetName) {
    this.layoutSettings = newSettings;
    await this.saveSettings();
    if (this.processor) {
      this.processor.updateLayoutDetectorSettings(newSettings);
    }
    if (presetName) {
      new import_obsidian10.Notice(`Layout preset loaded: "${presetName}"`);
    } else if (presetName === null) {
      new import_obsidian10.Notice("Layout settings saved.");
    }
  }
  // === Helper: Build Map ===
  async buildPdfTranslationMap() {
    this.pdfToMdMap.clear();
    let mdFiles = this.app.vault.getMarkdownFiles();
    if (this.settings.storageLocation) {
      mdFiles = mdFiles.filter((file) => file.path.startsWith(this.settings.storageLocation));
    }
    let count = 0;
    for (const mdFile of mdFiles) {
      if (!mdFile.name.endsWith(".translations.md"))
        continue;
      const cache = this.app.metadataCache.getFileCache(mdFile);
      if (!(cache == null ? void 0 : cache.frontmatter))
        continue;
      const raw = cache.frontmatter["pdf-source"];
      if (!raw || typeof raw !== "string")
        continue;
      let linkPath = raw.trim();
      if (linkPath.startsWith("[[") && linkPath.endsWith("]]")) {
        linkPath = linkPath.slice(2, -2);
      } else if (linkPath.startsWith('"') && linkPath.endsWith('"') || linkPath.startsWith("'") && linkPath.endsWith("'")) {
        linkPath = linkPath.slice(1, -1);
      }
      if (linkPath.includes("|")) {
        linkPath = linkPath.split("|")[0];
      }
      linkPath = linkPath.trim();
      if (!linkPath)
        continue;
      let resolved = null;
      resolved = this.app.metadataCache.getFirstLinkpathDest(linkPath, mdFile.path);
      if (!resolved) {
        const abstractFile = this.app.vault.getAbstractFileByPath(linkPath);
        if (abstractFile instanceof import_obsidian10.TFile) {
          resolved = abstractFile;
        }
      }
      if (!resolved) {
        const normalized = (0, import_obsidian10.normalizePath)(linkPath);
        const abstractFile = this.app.vault.getAbstractFileByPath(normalized);
        if (abstractFile instanceof import_obsidian10.TFile) {
          resolved = abstractFile;
        }
      }
      if (resolved && resolved.extension === "pdf") {
        this.pdfToMdMap.set(resolved.path, mdFile.path);
        count++;
      }
    }
    this.logDebug(`Rebuilt map. Found ${count} translation files.`);
  }
  async refreshAffectedOverlays() {
    await this.isReady;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "pdf")
      return;
    const mdPath = this.pdfToMdMap.get(activeFile.path);
    if (mdPath) {
      this.logDebug(`Found translation for current PDF: ${mdPath}`);
      await this.overlay.loadSavedOverlayForCurrentPage(true);
    } else {
      this.logDebug(`No translation found for current PDF: ${activeFile.path}`);
    }
  }
  // ... (Rest of the class methods remain unchanged) ...
  async loadSettings() {
    const data = await this.loadData() || {};
    this.settings = { ...DEFAULT_SETTINGS, ...data.settings || {} };
    this.layoutSettings = { ...defaultLayoutSettings, ...data.layoutSettings || {} };
    if (this.settings.storageLocation) {
      let trimmed = this.settings.storageLocation.trim();
      if (["/", ".", "..", ""].includes(trimmed)) {
        this.settings.storageLocation = "";
      } else {
        trimmed = (0, import_obsidian10.normalizePath)(trimmed);
        if (!trimmed.endsWith("/"))
          trimmed += "/";
        this.settings.storageLocation = trimmed.replace(/\/+/g, "/");
      }
    }
  }
  async saveSettings() {
    await this.saveData({
      settings: this.settings,
      layoutSettings: this.layoutSettings
    });
  }
  getCurrentPageNumber() {
    const activeLeaf = this.app.workspace.activeLeaf;
    if (!activeLeaf || activeLeaf.view.getViewType() !== "pdf")
      return null;
    const pdfView = activeLeaf.view;
    const containerEl = pdfView.containerEl;
    const viewerContainer = containerEl.querySelector(".pdfViewer, #viewer");
    if (!viewerContainer)
      return null;
    const pages = viewerContainer.querySelectorAll(".page[data-page-number]");
    const currentPageEl = this.overlay.getCurrentVisiblePage(pages);
    if (!currentPageEl)
      return null;
    const pageNumberStr = currentPageEl.getAttribute("data-page-number");
    const pageNumber = pageNumberStr ? parseInt(pageNumberStr, 10) : 0;
    return pageNumber > 0 ? pageNumber : null;
  }
  onunload() {
    console.log("\u{1F9E9} OpenRouter PDF Translator plugin unloaded");
    this.overlay.cleanup();
    this.clearAllOverlays();
    this.pdfToMdMap.clear();
  }
  clearAllOverlays() {
    document.querySelectorAll(".pdf-text-overlay-container").forEach((el) => el.remove());
  }
  getCurrentPageElement() {
    return this.overlay.getCurrentPageElement();
  }
  logDebug(message, ...args) {
    if (this.settings.debugMode) {
      console.log(`[PDF Translator] ${message}`, ...args);
    }
  }
};
var PresetFuzzyModal = class extends import_obsidian10.FuzzySuggestModal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.setPlaceholder("Select a preset to load...");
  }
  getItems() {
    return PresetManager.getAllPresets();
  }
  getItemText(preset) {
    return preset.name;
  }
  onChooseItem(preset, evt) {
    this.plugin.activateLayoutSettings(preset.settings, preset.name);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzZXR0aW5ncy50cyIsICJ0eXBlcy50cyIsICJzdG9yYWdlLnRzIiwgIm92ZXJsYXkudHMiLCAib3ZlcmxheS11aS50cyIsICJtb2RhbC1yZXRyYW5zbGF0ZS50cyIsICJ0cmFuc2xhdGlvbi50cyIsICJwcm9jZXNzaW5nLnRzIiwgIkdhcERldGVjdG9yLnRzIiwgImdyaWQtZGV0ZWN0b3IudHMiLCAiUGFyYWdyYXBoTWVyZ2VyLnRzIiwgIlNuYXBzaG90LnRzIiwgImxheW91dC1tb2RhbC50cyIsICJsYXlvdXQtZGV0ZWN0b3IudHMiLCAibW9kYWwudHMiLCAicmVwcm9jZXNzb3IudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8vIG1haW4udHNcclxuaW1wb3J0IHsgUGx1Z2luLCBURmlsZSwgbm9ybWFsaXplUGF0aCwgQXBwLCBOb3RpY2UsIE1lbnUsIEZ1enp5U3VnZ2VzdE1vZGFsLCBkZWJvdW5jZSB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IE9wZW5Sb3V0ZXJTZXR0aW5nc1RhYiBmcm9tICcuL3NldHRpbmdzJztcclxuaW1wb3J0IHsgT3BlblJvdXRlclRyYW5zbGF0b3JTZXR0aW5ncywgREVGQVVMVF9TRVRUSU5HUyB9IGZyb20gJy4vdHlwZXMnO1xyXG5cclxuLy8gTW9kdWxhciBjbGFzc2VzXHJcbmltcG9ydCB7IFRyYW5zbGF0aW9uU3RvcmFnZSB9IGZyb20gJy4vc3RvcmFnZSc7XHJcbmltcG9ydCB7IE92ZXJsYXlSZW5kZXJlciB9IGZyb20gJy4vb3ZlcmxheSc7XHJcbmltcG9ydCB7IFRyYW5zbGF0aW9uRW5naW5lIH0gZnJvbSAnLi90cmFuc2xhdGlvbic7XHJcbmltcG9ydCB7IFRleHRQcm9jZXNzb3IgfSBmcm9tICcuL3Byb2Nlc3NpbmcnO1xyXG5pbXBvcnQgeyBUcmFuc2xhdGVNdWx0aXBsZVBhZ2VzTW9kYWwgfSBmcm9tICcuL21vZGFsJztcclxuaW1wb3J0IHsgUmVnaW9uUmVwcm9jZXNzb3IgfSBmcm9tICcuL3JlcHJvY2Vzc29yJztcclxuaW1wb3J0IHsgUmV0cmFuc2xhdGVVc2luZ092ZXJsYXlzTW9kYWwgfSBmcm9tICcuL21vZGFsLXJldHJhbnNsYXRlJztcclxuaW1wb3J0IHsgXHJcbiAgICBzaG93TGF5b3V0U2V0dGluZ3NNb2RhbCwgXHJcbiAgICBMYXlvdXRTZXR0aW5ncywgXHJcbiAgICBkZWZhdWx0TGF5b3V0U2V0dGluZ3MsIFxyXG4gICAgUHJlc2V0TWFuYWdlciwgXHJcbiAgICBQcmVzZXQgXHJcbn0gZnJvbSAnLi9sYXlvdXQtbW9kYWwnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3BlblJvdXRlclRyYW5zbGF0b3JQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xyXG4gICAgc2V0dGluZ3M6IE9wZW5Sb3V0ZXJUcmFuc2xhdG9yU2V0dGluZ3M7XHJcbiAgICBsYXlvdXRTZXR0aW5nczogTGF5b3V0U2V0dGluZ3M7XHJcbiAgICBzdG9yYWdlOiBUcmFuc2xhdGlvblN0b3JhZ2U7XHJcbiAgICBvdmVybGF5OiBPdmVybGF5UmVuZGVyZXI7XHJcbiAgICB0cmFuc2xhdGlvbjogVHJhbnNsYXRpb25FbmdpbmU7XHJcbiAgICBwcm9jZXNzb3I6IFRleHRQcm9jZXNzb3I7XHJcblxyXG4gICAgLy8gRmFzdCBsb29rdXA6IFBERiBwYXRoIFx1MjE5MiAudHJhbnNsYXRpb25zLm1kIGZpbGUgcGF0aFxyXG4gICAgcHVibGljIHBkZlRvTWRNYXA6IE1hcDxzdHJpbmcsIHN0cmluZz4gPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgcHJpdmF0ZSBvdmVybGF5Q2xlYW51cEZ1bmN0aW9ucyA9IG5ldyBTZXQ8KCkgPT4gdm9pZD4oKTtcclxuICAgIFxyXG4gICAgLy8gRGVib3VuY2VkIGZ1bmN0aW9uIHRvIHByZXZlbnQgbWFwIHNwYW1taW5nXHJcbiAgICBwcml2YXRlIGRlYm91bmNlZEJ1aWxkTWFwOiAoKSA9PiB2b2lkO1xyXG5cclxuICAgIC8vIFJlYWRpbmVzcyBnYXRlIGZvciBmaWxlLW9wZW4gaGFuZGxlciBhZnRlciBpbml0aWFsIG1hcCBidWlsZFxyXG4gICAgcHJpdmF0ZSByZXNvbHZlUmVhZHkhOiAoKSA9PiB2b2lkO1xyXG4gICAgcHVibGljIGlzUmVhZHk6IFByb21pc2U8dm9pZD47XHJcblxyXG4gICAgYXN5bmMgb25sb2FkKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdcdUQ4M0VcdURERTkgT3BlblJvdXRlciBQREYgVHJhbnNsYXRvciBwbHVnaW4gbG9hZGVkJyk7XHJcblxyXG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgRGVib3VuY2VyICh3YWl0IDUwMG1zIGFmdGVyIGxhc3QgY2FsbCB0byBydW4pXHJcbiAgICAgICAgdGhpcy5kZWJvdW5jZWRCdWlsZE1hcCA9IGRlYm91bmNlKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhcIkRlYm91bmNlZDogUmVidWlsZGluZyBQREYgbWFwLi4uXCIpO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmJ1aWxkUGRmVHJhbnNsYXRpb25NYXAoKTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoQWZmZWN0ZWRPdmVybGF5cygpO1xyXG4gICAgICAgIH0sIDUwMCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIFJlYWR5IHByb21pc2VcclxuICAgICAgICB0aGlzLmlzUmVhZHkgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlUmVhZHkgPSByZXNvbHZlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIHNlcnZpY2VzXHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGlvbiA9IG5ldyBUcmFuc2xhdGlvbkVuZ2luZSh0aGlzKTtcclxuICAgICAgICB0aGlzLm92ZXJsYXkgPSBuZXcgT3ZlcmxheVJlbmRlcmVyKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gbmV3IFRleHRQcm9jZXNzb3IodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gbmV3IFRyYW5zbGF0aW9uU3RvcmFnZSh0aGlzKTtcclxuXHJcbiAgICAgICAgLy8gPT09PT09PSBJbml0aWFsaXphdGlvbiBmb3IgQ29sZCBhbmQgV2FybSBTdGFydHMgPT09PT09PVxyXG5cclxuICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2Uub25MYXlvdXRSZWFkeShhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEZJWDogQnVpbGQgbWFwIE9OTFkgd2hlbiBsYXlvdXQgKGFuZCBjYWNoZSkgaXMgcmVhZHlcclxuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhcIkxheW91dCByZWFkeS4gQnVpbGRpbmcgaW5pdGlhbCB0cmFuc2xhdGlvbiBtYXAuLi5cIik7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYnVpbGRQZGZUcmFuc2xhdGlvbk1hcCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVSZWFkeSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5pc1JlYWR5O1xyXG4gICAgICAgICAgICBjb25zdCBhY3RpdmVMZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmFjdGl2ZUxlYWY7XHJcbiAgICAgICAgICAgIGlmIChhY3RpdmVMZWFmICYmIGFjdGl2ZUxlYWYudmlldy5nZXRWaWV3VHlwZSgpID09PSAncGRmJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vdmVybGF5LnNldHVwUERGTW9uaXRvcmluZyhhY3RpdmVMZWFmKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVmcmVzaEFmZmVjdGVkT3ZlcmxheXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyA9PT09PT09IENBQ0hFIEVWRU5UUyAoVGhlIEZpeCkgPT09PT09PVxyXG5cclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQodGhpcy5hcHAubWV0YWRhdGFDYWNoZS5vbignY2hhbmdlZCcsIChmaWxlKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIE9ubHkgcmVidWlsZCBpZiBhIHRyYW5zbGF0aW9uIGZpbGUgY2hhbmdlZCBpdHMgbWV0YWRhdGEvY29udGVudFxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1RyYW5zbGF0aW9uRmlsZShmaWxlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgVHJhbnNsYXRpb24gZmlsZSBjaGFuZ2VkOiAke2ZpbGUucGF0aH0uIFJlYnVpbGRpbmcgbWFwLmApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJvdW5jZWRCdWlsZE1hcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAvLyA9PT09PT09IEZpbGUgU3lzdGVtIEV2ZW50cyAoUmVuYW1lcy9EZWxldGVzKSA9PT09PT09XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KHRoaXMuYXBwLnZhdWx0Lm9uKCdyZW5hbWUnLCBhc3luYyAoZmlsZSwgb2xkUGF0aCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyAxLiBJZiBhIFBERiB3YXMgcmVuYW1lZCwgd2UgbWlnaHQgbmVlZCB0byB1cGRhdGUgdGhlIHRyYW5zbGF0aW9uIGZpbGUgbmFtZVxyXG4gICAgICAgICAgICBpZiAoZmlsZS5leHRlbnNpb24gPT09ICdwZGYnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZFBhdGggPSB0aGlzLnBkZlRvTWRNYXAuZ2V0KG9sZFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1kUGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWRGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG1kUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWRGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdNZFBhdGggPSB0aGlzLnN0b3JhZ2UuZ2V0VHJhbnNsYXRpb25GaWxlUGF0aChmaWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplUGF0aChtZEZpbGUucGF0aCkgIT09IG5vcm1hbGl6ZVBhdGgobmV3TWRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQucmVuYW1lKG1kRmlsZSwgbmV3TWRQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgY29uc29sZS5lcnJvcihlKTsgfSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYm91bmNlZEJ1aWxkTWFwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCAyMDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAvLyAyLiBJZiBhIFRyYW5zbGF0aW9uIGZpbGUgd2FzIHJlbmFtZWQsIGp1c3QgcmVidWlsZCB0aGUgbWFwXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNUcmFuc2xhdGlvbkZpbGUoZmlsZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFBkZlBhdGggPSBbLi4udGhpcy5wZGZUb01kTWFwLmVudHJpZXMoKV0uZmluZCgoW18sIG1kXSkgPT4gbWQgPT09IG9sZFBhdGgpPy5bMF07XHJcbiAgICAgICAgICAgICAgICBpZiAob2xkUGRmUGF0aCkgdGhpcy5wZGZUb01kTWFwLmRlbGV0ZShvbGRQZGZQYXRoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVib3VuY2VkQnVpbGRNYXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KHRoaXMuYXBwLnZhdWx0Lm9uKCdkZWxldGUnLCBhc3luYyAoZmlsZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlICYmIHRoaXMuaXNUcmFuc2xhdGlvbkZpbGUoZmlsZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFBkZlBhdGggPSBbLi4udGhpcy5wZGZUb01kTWFwLmVudHJpZXMoKV0uZmluZCgoW18sIG1kUGF0aF0pID0+IG1kUGF0aCA9PT0gZmlsZS5wYXRoKT8uWzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9sZFBkZlBhdGgpIHRoaXMucGRmVG9NZE1hcC5kZWxldGUob2xkUGRmUGF0aCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYm91bmNlZEJ1aWxkTWFwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIC8vID09PT09PT0gU3RhbmRhcmQgQ29tbWFuZHMgPT09PT09PVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgICAgICAgIGlkOiAncmVidWlsZC1wZGYtdHJhbnNsYXRpb24tbWFwJyxcclxuICAgICAgICAgICAgbmFtZTogJ1JlYnVpbGQgUERGLXRvLXRyYW5zbGF0aW9uIGZpbGUgbWFwJyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1JlYnVpbGRpbmcgbWFwLi4uJyk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJ1aWxkUGRmVHJhbnNsYXRpb25NYXAoKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVmcmVzaEFmZmVjdGVkT3ZlcmxheXMoKTtcclxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ01hcCByZWJ1aWx0LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgICAgICAgIGlkOiAndHJhbnNsYXRlLW11bHRpcGxlLXBhZ2VzJyxcclxuICAgICAgICAgICAgbmFtZTogJ1RyYW5zbGF0ZSBtdWx0aXBsZSBwYWdlcy4uLicsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChmaWxlICYmIGZpbGUuZXh0ZW5zaW9uID09PSAncGRmJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUcmFuc2xhdGVNdWx0aXBsZVBhZ2VzTW9kYWwodGhpcywgZmlsZSkub3BlbigpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdQbGVhc2Ugb3BlbiBhIFBERiBmaXJzdC4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyA9PT09PT09IExheW91dCAmIFByZXNldCBDb21tYW5kcyA9PT09PT09XHJcblxyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgICAgICAgIGlkOiAnYWRqdXN0LWxheW91dC1zZXR0aW5ncycsXHJcbiAgICAgICAgICAgIG5hbWU6ICdBZGp1c3QgTGF5b3V0IERldGVjdG9yIFNldHRpbmdzLi4uJyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNob3dMYXlvdXRTZXR0aW5nc01vZGFsKHRoaXMubGF5b3V0U2V0dGluZ3MsIChuZXdTZXR0aW5ncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVMYXlvdXRTZXR0aW5ncyhuZXdTZXR0aW5ncywgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICAgICAgICBpZDogJ3F1aWNrLXN3aXRjaC1sYXlvdXQtcHJlc2V0JyxcclxuICAgICAgICAgICAgbmFtZTogJ0xheW91dDogUXVpY2sgc3dpdGNoIHByZXNldC4uLicsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBuZXcgUHJlc2V0RnV6enlNb2RhbCh0aGlzLmFwcCwgdGhpcykub3BlbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNhdmVkUHJlc2V0cyA9IFByZXNldE1hbmFnZXIuZ2V0QWxsUHJlc2V0cygpO1xyXG4gICAgICAgIHNhdmVkUHJlc2V0cy5mb3JFYWNoKHByZXNldCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgICAgICAgICAgICBpZDogYGxvYWQtbGF5b3V0LXByZXNldC0ke3ByZXNldC5pZH1gLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogYExheW91dCBQcmVzZXQ6IExvYWQgXCIke3ByZXNldC5uYW1lfVwiYCxcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB0aGlzLmFjdGl2YXRlTGF5b3V0U2V0dGluZ3MocHJlc2V0LnNldHRpbmdzLCBwcmVzZXQubmFtZSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vID09PT09PT0gT3ZlcmxheSBDb21tYW5kcyA9PT09PT09XHJcblxyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgICAgICAgIGlkOiAnYWRkLXBkZi10ZXh0LW92ZXJsYXknLFxyXG4gICAgICAgICAgICBuYW1lOiAnVHJhbnNsYXRlIGFuZCBhZGQgb3ZlcmxheSB0byBjdXJyZW50IFBERiBwYWdlJyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMucHJvY2Vzc29yLmFkZFRleHRPdmVybGF5KCksXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgICAgICAgIGlkOiAnc2F2ZS1wZGYtb3ZlcmxheScsXHJcbiAgICAgICAgICAgIG5hbWU6ICdTYXZlIGN1cnJlbnQgUERGIG92ZXJsYXknLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4gdGhpcy5zdG9yYWdlLnNhdmVDdXJyZW50T3ZlcmxheSgpLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICAgICAgICBpZDogJ3JlZnJlc2gtcGRmLW92ZXJsYXknLFxyXG4gICAgICAgICAgICBuYW1lOiAnUmVmcmVzaCBjdXJyZW50IFBERiBvdmVybGF5JyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMub3ZlcmxheS5yZWZyZXNoQ3VycmVudE92ZXJsYXkoKSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcclxuICAgICAgICAgICAgaWQ6ICdkZWxldGUtcGRmLW92ZXJsYXknLFxyXG4gICAgICAgICAgICBuYW1lOiAnRGVsZXRlIGN1cnJlbnQgUERGIG92ZXJsYXknLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4gdGhpcy5zdG9yYWdlLmRlbGV0ZUN1cnJlbnRPdmVybGF5KCksXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgICAgICAgIGlkOiAndG9nZ2xlLXBkZi1vdmVybGF5JyxcclxuICAgICAgICAgICAgbmFtZTogJ1RvZ2dsZSBQREYgb3ZlcmxheSB2aXNpYmlsaXR5JyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMub3ZlcmxheS50b2dnbGVPdmVybGF5VmlzaWJpbGl0eSgpLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICAgICAgICBpZDogJ3JldHJhbnNsYXRlLXVzaW5nLW92ZXJsYXlzJyxcclxuICAgICAgICAgICAgbmFtZTogJ1JlLXRyYW5zbGF0ZSB1c2luZyBzYXZlZCBvdmVybGF5IGJveGVzXHUyMDI2JyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpbGUgJiYgZmlsZS5leHRlbnNpb24gPT09ICdwZGYnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IFJldHJhbnNsYXRlVXNpbmdPdmVybGF5c01vZGFsKHRoaXMuYXBwLCB0aGlzLCBmaWxlKS5vcGVuKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1BsZWFzZSBvcGVuIGEgUERGIGZpcnN0LicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgICAgICAgIGlkOiAncmV0cmFuc2xhdGUtcmVnaW9uLWZhc3QnLFxyXG4gICAgICAgICAgICBuYW1lOiAnUmUtdHJhbnNsYXRlIHJlZ2lvbiBieSBkcmFnZ2luZyAoZmFzdCknLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4gbmV3IFJlZ2lvblJlcHJvY2Vzc29yKHRoaXMpLnN0YXJ0KCksXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vID09PT09PT0gUERGIE1vbml0b3JpbmcgPT09PT09PVxyXG5cclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQodGhpcy5hcHAud29ya3NwYWNlLm9uKCdhY3RpdmUtbGVhZi1jaGFuZ2UnLCAobGVhZikgPT4ge1xyXG4gICAgICAgICAgICBpZiAobGVhZiAmJiBsZWFmLnZpZXcuZ2V0Vmlld1R5cGUoKSA9PT0gJ3BkZicpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5vdmVybGF5LnNldHVwUERGTW9uaXRvcmluZyhsZWFmKSwgMzAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KFxyXG4gICAgICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2Uub24oJ2ZpbGUtbWVudScsIChtZW51LCBmaWxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlICYmIGZpbGUuZXh0ZW5zaW9uID09PSAncGRmJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3ZlcmxheS5hZGRPdmVybGF5VG9nZ2xlVG9QREZNZW51KG1lbnUsIGZpbGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgT3BlblJvdXRlclNldHRpbmdzVGFiKHRoaXMuYXBwLCB0aGlzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpc1RyYW5zbGF0aW9uRmlsZShmaWxlOiBhbnkpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gZmlsZSBpbnN0YW5jZW9mIFRGaWxlICYmIFxyXG4gICAgICAgICAgICAgICBmaWxlLmV4dGVuc2lvbiA9PT0gJ21kJyAmJiBcclxuICAgICAgICAgICAgICAgZmlsZS5uYW1lLmVuZHNXaXRoKCcudHJhbnNsYXRpb25zLm1kJyk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgYWN0aXZhdGVMYXlvdXRTZXR0aW5ncyhuZXdTZXR0aW5nczogTGF5b3V0U2V0dGluZ3MsIHByZXNldE5hbWU6IHN0cmluZyB8IG51bGwpIHtcclxuICAgICAgICB0aGlzLmxheW91dFNldHRpbmdzID0gbmV3U2V0dGluZ3M7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzb3IudXBkYXRlTGF5b3V0RGV0ZWN0b3JTZXR0aW5ncyhuZXdTZXR0aW5ncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmVzZXROYW1lKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYExheW91dCBwcmVzZXQgbG9hZGVkOiBcIiR7cHJlc2V0TmFtZX1cImApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocHJlc2V0TmFtZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBuZXcgTm90aWNlKCdMYXlvdXQgc2V0dGluZ3Mgc2F2ZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vID09PSBIZWxwZXI6IEJ1aWxkIE1hcCA9PT1cclxuICAgIGFzeW5jIGJ1aWxkUGRmVHJhbnNsYXRpb25NYXAoKSB7XHJcbiAgICAgICAgdGhpcy5wZGZUb01kTWFwLmNsZWFyKCk7XHJcbiAgICAgICAgbGV0IG1kRmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0b3JhZ2VMb2NhdGlvbikge1xyXG4gICAgICAgICAgICBtZEZpbGVzID0gbWRGaWxlcy5maWx0ZXIoZmlsZSA9PiBmaWxlLnBhdGguc3RhcnRzV2l0aCh0aGlzLnNldHRpbmdzLnN0b3JhZ2VMb2NhdGlvbikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IG1kRmlsZSBvZiBtZEZpbGVzKSB7XHJcbiAgICAgICAgICAgIGlmICghbWRGaWxlLm5hbWUuZW5kc1dpdGgoJy50cmFuc2xhdGlvbnMubWQnKSkgY29udGludWU7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKG1kRmlsZSk7XHJcbiAgICAgICAgICAgIGlmICghY2FjaGU/LmZyb250bWF0dGVyKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJhdyA9IGNhY2hlLmZyb250bWF0dGVyWydwZGYtc291cmNlJ107XHJcbiAgICAgICAgICAgIGlmICghcmF3IHx8IHR5cGVvZiByYXcgIT09ICdzdHJpbmcnKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZJWDogU2ltcGxpZmllZCBjbGVhbmluZyBsb2dpYyB0aGF0IGhhbmRsZXMgV2lraUxpbmtzLCBRdW90ZXMsIG9yIFBsYWluIFBhdGhzIHJvYnVzdGx5XHJcbiAgICAgICAgICAgIC8vIDEuIFJlbW92ZSB3cmFwcGluZyBxdW90ZXMvYnJhY2tldHMgaWYgcHJlc2VudFxyXG4gICAgICAgICAgICAvLyAyLiBSZW1vdmUgYWxpYXMgKGNvbnRlbnQgYWZ0ZXIgfClcclxuICAgICAgICAgICAgbGV0IGxpbmtQYXRoID0gcmF3LnRyaW0oKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN0cmlwIFtbIF1dIGlmIHByZXNlbnRcclxuICAgICAgICAgICAgaWYgKGxpbmtQYXRoLnN0YXJ0c1dpdGgoJ1tbJykgJiYgbGlua1BhdGguZW5kc1dpdGgoJ11dJykpIHtcclxuICAgICAgICAgICAgICAgIGxpbmtQYXRoID0gbGlua1BhdGguc2xpY2UoMiwgLTIpO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAvLyBTdHJpcCBxdW90ZXMgaWYgdGhleSBzb21laG93IHN1cnZpdmVkIGZyb250bWF0dGVyIHBhcnNpbmcgKHJhcmUgYnV0IHBvc3NpYmxlKVxyXG4gICAgICAgICAgICBlbHNlIGlmICgobGlua1BhdGguc3RhcnRzV2l0aCgnXCInKSAmJiBsaW5rUGF0aC5lbmRzV2l0aCgnXCInKSkgfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgIChsaW5rUGF0aC5zdGFydHNXaXRoKFwiJ1wiKSAmJiBsaW5rUGF0aC5lbmRzV2l0aChcIidcIikpKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5rUGF0aCA9IGxpbmtQYXRoLnNsaWNlKDEsIC0xKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHBpcGUgYWxpYXNcclxuICAgICAgICAgICAgaWYgKGxpbmtQYXRoLmluY2x1ZGVzKCd8JykpIHtcclxuICAgICAgICAgICAgICAgIGxpbmtQYXRoID0gbGlua1BhdGguc3BsaXQoJ3wnKVswXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGlua1BhdGggPSBsaW5rUGF0aC50cmltKCk7XHJcbiAgICAgICAgICAgIGlmICghbGlua1BhdGgpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgbGV0IHJlc29sdmVkOiBURmlsZSB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RyYXRlZ3kgMTogVHJ5IHJlc29sdmluZyBhcyBhIGxpbmsgKGhhbmRsZXMgcmVsYXRpdmUgcGF0aHMsIHdpa2lsaW5rcylcclxuICAgICAgICAgICAgcmVzb2x2ZWQgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KGxpbmtQYXRoLCBtZEZpbGUucGF0aCkgYXMgVEZpbGU7XHJcblxyXG4gICAgICAgICAgICAvLyBTdHJhdGVneSAyOiBGYWxsYmFjayAtIFRyeSByZXNvbHZpbmcgYXMgYW4gYWJzb2x1dGUgcGF0aCBpbiB0aGUgdmF1bHRcclxuICAgICAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWJzdHJhY3RGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGxpbmtQYXRoKTtcclxuICAgICAgICAgICAgICAgIGlmIChhYnN0cmFjdEZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkID0gYWJzdHJhY3RGaWxlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdHJhdGVneSAzOiBUcnkgbm9ybWFsaXppbmcgcGF0aCBpZiBwcmV2aW91cyBhdHRlbXB0cyBmYWlsZWRcclxuICAgICAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVBhdGgobGlua1BhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWJzdHJhY3RGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG5vcm1hbGl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFic3RyYWN0RmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBhYnN0cmFjdEZpbGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCAmJiByZXNvbHZlZC5leHRlbnNpb24gPT09ICdwZGYnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBkZlRvTWRNYXAuc2V0KHJlc29sdmVkLnBhdGgsIG1kRmlsZS5wYXRoKTtcclxuICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgUmVidWlsdCBtYXAuIEZvdW5kICR7Y291bnR9IHRyYW5zbGF0aW9uIGZpbGVzLmApO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgcmVmcmVzaEFmZmVjdGVkT3ZlcmxheXMoKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5pc1JlYWR5O1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xyXG4gICAgICAgIGlmICghYWN0aXZlRmlsZSB8fCBhY3RpdmVGaWxlLmV4dGVuc2lvbiAhPT0gJ3BkZicpIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgbWRQYXRoID0gdGhpcy5wZGZUb01kTWFwLmdldChhY3RpdmVGaWxlLnBhdGgpO1xyXG4gICAgICAgIGlmIChtZFBhdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgRm91bmQgdHJhbnNsYXRpb24gZm9yIGN1cnJlbnQgUERGOiAke21kUGF0aH1gKTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5vdmVybGF5LmxvYWRTYXZlZE92ZXJsYXlGb3JDdXJyZW50UGFnZSh0cnVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKGBObyB0cmFuc2xhdGlvbiBmb3VuZCBmb3IgY3VycmVudCBQREY6ICR7YWN0aXZlRmlsZS5wYXRofWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyAuLi4gKFJlc3Qgb2YgdGhlIGNsYXNzIG1ldGhvZHMgcmVtYWluIHVuY2hhbmdlZCkgLi4uXHJcbiAgICBcclxuICAgIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5sb2FkRGF0YSgpIHx8IHt9O1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7IC4uLkRFRkFVTFRfU0VUVElOR1MsIC4uLmRhdGEuc2V0dGluZ3MgfHwge30gfTtcclxuICAgICAgICB0aGlzLmxheW91dFNldHRpbmdzID0geyAuLi5kZWZhdWx0TGF5b3V0U2V0dGluZ3MsIC4uLmRhdGEubGF5b3V0U2V0dGluZ3MgfHwge30gfTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3RvcmFnZUxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGxldCB0cmltbWVkID0gdGhpcy5zZXR0aW5ncy5zdG9yYWdlTG9jYXRpb24udHJpbSgpO1xyXG4gICAgICAgICAgICBpZiAoWycvJywgJy4nLCAnLi4nLCAnJ10uaW5jbHVkZXModHJpbW1lZCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc3RvcmFnZUxvY2F0aW9uID0gJyc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cmltbWVkID0gbm9ybWFsaXplUGF0aCh0cmltbWVkKTtcclxuICAgICAgICAgICAgICAgIGlmICghdHJpbW1lZC5lbmRzV2l0aCgnLycpKSB0cmltbWVkICs9ICcvJztcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc3RvcmFnZUxvY2F0aW9uID0gdHJpbW1lZC5yZXBsYWNlKC9cXC8rL2csICcvJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEoe1xyXG4gICAgICAgICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcclxuICAgICAgICAgICAgbGF5b3V0U2V0dGluZ3M6IHRoaXMubGF5b3V0U2V0dGluZ3NcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRDdXJyZW50UGFnZU51bWJlcigpOiBudW1iZXIgfCBudWxsIHtcclxuICAgICAgICBjb25zdCBhY3RpdmVMZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmFjdGl2ZUxlYWY7XHJcbiAgICAgICAgaWYgKCFhY3RpdmVMZWFmIHx8IGFjdGl2ZUxlYWYudmlldy5nZXRWaWV3VHlwZSgpICE9PSAncGRmJykgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIGNvbnN0IHBkZlZpZXc6IGFueSA9IGFjdGl2ZUxlYWYudmlldztcclxuICAgICAgICBjb25zdCBjb250YWluZXJFbCA9IHBkZlZpZXcuY29udGFpbmVyRWw7XHJcbiAgICAgICAgY29uc3Qgdmlld2VyQ29udGFpbmVyID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcignLnBkZlZpZXdlciwgI3ZpZXdlcicpO1xyXG4gICAgICAgIGlmICghdmlld2VyQ29udGFpbmVyKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgY29uc3QgcGFnZXMgPSB2aWV3ZXJDb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLnBhZ2VbZGF0YS1wYWdlLW51bWJlcl0nKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50UGFnZUVsID0gdGhpcy5vdmVybGF5LmdldEN1cnJlbnRWaXNpYmxlUGFnZShwYWdlcyk7XHJcbiAgICAgICAgaWYgKCFjdXJyZW50UGFnZUVsKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgY29uc3QgcGFnZU51bWJlclN0ciA9IGN1cnJlbnRQYWdlRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXBhZ2UtbnVtYmVyJyk7XHJcbiAgICAgICAgY29uc3QgcGFnZU51bWJlciA9IHBhZ2VOdW1iZXJTdHIgPyBwYXJzZUludChwYWdlTnVtYmVyU3RyLCAxMCkgOiAwO1xyXG4gICAgICAgIHJldHVybiBwYWdlTnVtYmVyID4gMCA/IHBhZ2VOdW1iZXIgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIG9udW5sb2FkKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdcdUQ4M0VcdURERTkgT3BlblJvdXRlciBQREYgVHJhbnNsYXRvciBwbHVnaW4gdW5sb2FkZWQnKTtcclxuICAgICAgICB0aGlzLm92ZXJsYXkuY2xlYW51cCgpO1xyXG4gICAgICAgIHRoaXMuY2xlYXJBbGxPdmVybGF5cygpO1xyXG4gICAgICAgIHRoaXMucGRmVG9NZE1hcC5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyQWxsT3ZlcmxheXMoKSB7XHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnBkZi10ZXh0LW92ZXJsYXktY29udGFpbmVyJykuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmUoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Q3VycmVudFBhZ2VFbGVtZW50KCk6IEhUTUxFbGVtZW50IHwgbnVsbCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3ZlcmxheS5nZXRDdXJyZW50UGFnZUVsZW1lbnQoKTtcclxuICAgIH1cclxuXHJcbiAgICBsb2dEZWJ1ZyhtZXNzYWdlOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZGVidWdNb2RlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUERGIFRyYW5zbGF0b3JdICR7bWVzc2FnZX1gLCAuLi5hcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBQcmVzZXRGdXp6eU1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8UHJlc2V0PiB7XHJcbiAgICBwbHVnaW46IE9wZW5Sb3V0ZXJUcmFuc2xhdG9yUGx1Z2luO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IE9wZW5Sb3V0ZXJUcmFuc2xhdG9yUGx1Z2luKSB7XHJcbiAgICAgICAgc3VwZXIoYXBwKTtcclxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICAgICAgICB0aGlzLnNldFBsYWNlaG9sZGVyKFwiU2VsZWN0IGEgcHJlc2V0IHRvIGxvYWQuLi5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0SXRlbXMoKTogUHJlc2V0W10ge1xyXG4gICAgICAgIHJldHVybiBQcmVzZXRNYW5hZ2VyLmdldEFsbFByZXNldHMoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRJdGVtVGV4dChwcmVzZXQ6IFByZXNldCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHByZXNldC5uYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIG9uQ2hvb3NlSXRlbShwcmVzZXQ6IFByZXNldCwgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucGx1Z2luLmFjdGl2YXRlTGF5b3V0U2V0dGluZ3MocHJlc2V0LnNldHRpbmdzLCBwcmVzZXQubmFtZSk7XHJcbiAgICB9XHJcbn0iLCAiLy8gc2V0dGluZ3MudHNcclxuaW1wb3J0IHtcclxuICAgIFBsdWdpblNldHRpbmdUYWIsXHJcbiAgICBBcHAsXHJcbiAgICBTZXR0aW5nLFxyXG4gICAgVGV4dENvbXBvbmVudCxcclxuICAgIG5vcm1hbGl6ZVBhdGgsXHJcbiAgICBEcm9wZG93bkNvbXBvbmVudCxcclxuICAgIFRvZ2dsZUNvbXBvbmVudCxcclxuICAgIFNsaWRlckNvbXBvbmVudCxcclxuICAgIFRleHRBcmVhQ29tcG9uZW50LFxyXG4gICAgQnV0dG9uQ29tcG9uZW50LFxyXG4gICAgTm90aWNlLFxyXG4gICAgcmVxdWVzdFVybCxcclxuICAgIFRGb2xkZXJcclxufSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCBPcGVuUm91dGVyVHJhbnNsYXRvclBsdWdpbiBmcm9tICcuL21haW4nO1xyXG5pbXBvcnQgeyBBVkFJTEFCTEVfTEFOR1VBR0VTLCBERUZBVUxUX1NFVFRJTkdTIH0gZnJvbSAnLi90eXBlcyc7XHJcblxyXG4vLyA9PT0gRm9sZGVyIFN1Z2dlc3RlciBDb21wb25lbnQgKE5vIGNoYW5nZXMgbmVlZGVkKSA9PT1cclxuZXhwb3J0IGNsYXNzIEZvbGRlclN1Z2dlc3QgZXh0ZW5kcyBUZXh0Q29tcG9uZW50IHtcclxuICAgIGFwcDogQXBwO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBjb250YWluZXJFbDogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBzdXBlcihjb250YWluZXJFbCk7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgdGhpcy5zZXRQbGFjZWhvbGRlcignZS5nLiBNeSBUcmFuc2xhdGlvbnMvJyk7XHJcbiAgICAgICAgdGhpcy5pbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5vbklucHV0LmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMuaW5wdXRFbC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5vbkJsdXIuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgb25JbnB1dCgpIHtcclxuICAgICAgICBjb25zdCBxdWVyeSA9IHRoaXMuZ2V0VmFsdWUoKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGNvbnN0IGFic3RyYWN0RmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRBbGxMb2FkZWRGaWxlcygpO1xyXG4gICAgICAgIGNvbnN0IGZvbGRlcnMgPSBhYnN0cmFjdEZpbGVzLmZpbHRlcihmID0+IGYgaW5zdGFuY2VvZiBURm9sZGVyKS5tYXAoZiA9PiBmLnBhdGgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gZm9sZGVycy5maWx0ZXIocCA9PiBwLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnkpKTtcclxuICAgICAgICB0aGlzLnNldFN1Z2dlc3Rpb25zKHN1Z2dlc3Rpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRTdWdnZXN0aW9ucyhzdWdnZXN0aW9uczogc3RyaW5nW10pIHtcclxuICAgICAgICBjb25zdCBkcm9wZG93biA9IHRoaXMuaW5wdXRFbC5wYXJlbnRFbGVtZW50Py5xdWVyeVNlbGVjdG9yKCcuc3VnZ2VzdGlvbi1kcm9wZG93bicpO1xyXG4gICAgICAgIGlmIChkcm9wZG93bikgZHJvcGRvd24ucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIGlmIChzdWdnZXN0aW9ucy5sZW5ndGggPiAwICYmIHRoaXMuZ2V0VmFsdWUoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkcm9wID0gY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnc3VnZ2VzdGlvbi1kcm9wZG93bicgfSk7XHJcbiAgICAgICAgICAgIC8vIFN0eWxlIHRoZSBkcm9wZG93biB0byBhcHBlYXIgY29ycmVjdGx5XHJcbiAgICAgICAgICAgIGRyb3Auc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgICAgICBkcm9wLnN0eWxlLnRvcCA9IHRoaXMuaW5wdXRFbC5vZmZzZXRUb3AgKyB0aGlzLmlucHV0RWwub2Zmc2V0SGVpZ2h0ICsgJ3B4JztcclxuICAgICAgICAgICAgZHJvcC5zdHlsZS5sZWZ0ID0gdGhpcy5pbnB1dEVsLm9mZnNldExlZnQgKyAncHgnO1xyXG4gICAgICAgICAgICBkcm9wLnN0eWxlLndpZHRoID0gdGhpcy5pbnB1dEVsLm9mZnNldFdpZHRoICsgJ3B4JztcclxuICAgICAgICAgICAgZHJvcC5zdHlsZS56SW5kZXggPSAnMTAwMCc7XHJcbiAgICAgICAgICAgIGRyb3Auc3R5bGUuYmFja2dyb3VuZCA9ICd2YXIoLS1iYWNrZ3JvdW5kLXNlY29uZGFyeSknO1xyXG4gICAgICAgICAgICBkcm9wLnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpJztcclxuICAgICAgICAgICAgZHJvcC5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnNHB4JztcclxuICAgICAgICAgICAgZHJvcC5zdHlsZS5tYXhIZWlnaHQgPSAnMjAwcHgnO1xyXG4gICAgICAgICAgICBkcm9wLnN0eWxlLm92ZXJmbG93WSA9ICdhdXRvJztcclxuICAgICAgICAgICAgZHJvcC5zdHlsZS5ib3hTaGFkb3cgPSAnMCA0cHggOHB4IHJnYmEoMCwgMCwgMCwgMC4yKSc7XHJcblxyXG4gICAgICAgICAgICBzdWdnZXN0aW9ucy5mb3JFYWNoKHN1ZyA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gY3JlYXRlRWwoJ2RpdicsIHsgdGV4dDogc3VnLCBjbHM6ICdzdWdnZXN0aW9uLWl0ZW0nIH0pO1xyXG4gICAgICAgICAgICAgICAgaXRlbS5zdHlsZS5wYWRkaW5nID0gJzZweCAxMHB4JztcclxuICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCAoKSA9PiBpdGVtLnN0eWxlLmJhY2tncm91bmQgPSAndmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ob3ZlciknKTtcclxuICAgICAgICAgICAgICAgIGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsICgpID0+IGl0ZW0uc3R5bGUuYmFja2dyb3VuZCA9ICcnKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaXRlbS5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoc3VnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0RWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2JsdXInKSk7IC8vIFRyaWdnZXIgc2F2ZVxyXG4gICAgICAgICAgICAgICAgICAgIGRyb3AucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgZHJvcC5hcHBlbmRDaGlsZChpdGVtKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmlucHV0RWwucGFyZW50RWxlbWVudD8uYXBwZW5kQ2hpbGQoZHJvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uQmx1cigpIHtcclxuICAgICAgICAvLyBEZWxheSBoaWRpbmcgdG8gYWxsb3cgY2xpY2sgZXZlbnQgdG8gcmVnaXN0ZXJcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZHJvcGRvd24gPSB0aGlzLmlucHV0RWwucGFyZW50RWxlbWVudD8ucXVlcnlTZWxlY3RvcignLnN1Z2dlc3Rpb24tZHJvcGRvd24nKTtcclxuICAgICAgICAgICAgaWYgKGRyb3Bkb3duKSBkcm9wZG93bi5yZW1vdmUoKTtcclxuICAgICAgICB9LCAyMDApO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyA9PT0gU2V0dGluZ3MgVGFiIEltcGxlbWVudGF0aW9uID09PVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcGVuUm91dGVyU2V0dGluZ3NUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcclxuICAgIHBsdWdpbjogT3BlblJvdXRlclRyYW5zbGF0b3JQbHVnaW47XHJcblxyXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogT3BlblJvdXRlclRyYW5zbGF0b3JQbHVnaW4pIHtcclxuICAgICAgICBzdXBlcihhcHAsIHBsdWdpbik7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICB9XHJcblxyXG4gICAgZGlzcGxheSgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnUERGIFRleHQgVHJhbnNsYXRvcicgfSk7XHJcblxyXG4gICAgICAgIC8vIC0tLSBBUEkgUFJPVklERVIgU0VMRUNUSU9OIC0tLVxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnQVBJIFByb3ZpZGVyJylcclxuICAgICAgICAgICAgLnNldERlc2MoJ0Nob29zZSB5b3VyIHByZWZlcnJlZCB0cmFuc2xhdGlvbiBzZXJ2aWNlLicpXHJcbiAgICAgICAgICAgIC5hZGREcm9wZG93bihkZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBkZC5hZGRPcHRpb24oJ29wZW5yb3V0ZXInLCAnT3BlblJvdXRlcicpXHJcbiAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oJ29sbGFtYScsICdPbGxhbWEgKExvY2FsKScpXHJcbiAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oJ2N1c3RvbScsICdDdXN0b20gRW5kcG9pbnQnKVxyXG4gICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYXBpUHJvdmlkZXIpXHJcbiAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6ICdvcGVucm91dGVyJyB8ICdvbGxhbWEnIHwgJ2N1c3RvbScpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmFwaVByb3ZpZGVyID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIFJlLXJlbmRlciB0aGUgc2V0dGluZ3MgdGFiIHRvIHNob3cgcHJvdmlkZXItc3BlY2lmaWMgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaHInKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmFwaVByb3ZpZGVyO1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyU2V0dGluZ3MgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlclNldHRpbmdzW3Byb3ZpZGVyXTtcclxuXHJcbiAgICAgICAgLy8gLS0tIFBST1ZJREVSLVNQRUNJRklDIFNFVFRJTkdTIC0tLVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChwcm92aWRlciA9PT0gJ29wZW5yb3V0ZXInKSB7XHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXROYW1lKCdPcGVuUm91dGVyIFNldHRpbmdzJykuc2V0SGVhZGluZygpO1xyXG5cclxuICAgICAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgICAgICAuc2V0TmFtZSgnT3BlblJvdXRlciBBUEkgS2V5JylcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKCdHZXQgeW91ciBrZXkgZnJvbSBodHRwczovL29wZW5yb3V0ZXIuYWkva2V5cycpXHJcbiAgICAgICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCdzay1vci12MS0uLi4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUocHJvdmlkZXJTZXR0aW5ncy5hcGlLZXkgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyU2V0dGluZ3MuYXBpS2V5ID0gdmFsdWUudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQuaW5wdXRFbC50eXBlID0gJ3Bhc3N3b3JkJztcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgICAgICAuc2V0TmFtZSgnTW9kZWwnKVxyXG4gICAgICAgICAgICAgICAgLnNldERlc2MoJ0Nob29zZSBhIG1vZGVsIChlLmcuLCBnb29nbGUvZ2VtaW5pLWZsYXNoLTEuNSBpcyByZWNvbW1lbmRlZCknKVxyXG4gICAgICAgICAgICAgICAgLmFkZERyb3Bkb3duKGFzeW5jIGRkID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBkZC5zZXREaXNhYmxlZCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBkZC5hZGRPcHRpb24oJycsICdMb2FkaW5nIG1vZGVscy4uLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCByZXF1ZXN0VXJsKCdodHRwczovL29wZW5yb3V0ZXIuYWkvYXBpL3YxL21vZGVscycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcC5qc29uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RlbHMgPSAoQXJyYXkuaXNBcnJheShkYXRhLmRhdGEpID8gZGF0YS5kYXRhIDogW10pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgoYTogYW55LCBiOiBhbnkpID0+IGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGQuc2VsZWN0RWwuZW1wdHkoKTsgLy8gQ2xlYXIgXCJMb2FkaW5nLi4uXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxzLmZvckVhY2goKG06IGFueSkgPT4gZGQuYWRkT3B0aW9uKG0uaWQsIGAke20ubmFtZX0gKCR7bS5pZH0pYCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGQuc2V0VmFsdWUocHJvdmlkZXJTZXR0aW5ncy5tb2RlbCB8fCAnZ29vZ2xlL2dlbWluaS1mbGFzaC0xLjUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGQuc2V0RGlzYWJsZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBtb2RlbHMgZnJvbSBPcGVuUm91dGVyOicsIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRkLnNlbGVjdEVsLmVtcHR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRkLmFkZE9wdGlvbihwcm92aWRlclNldHRpbmdzLm1vZGVsIHx8ICdnb29nbGUvZ2VtaW5pLWZsYXNoLTEuNScsIGBEZWZhdWx0ICgke3Byb3ZpZGVyU2V0dGluZ3MubW9kZWwgfHwgJ2dvb2dsZS9nZW1pbmktZmxhc2gtMS41J30pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRkLnNldFZhbHVlKHByb3ZpZGVyU2V0dGluZ3MubW9kZWwgfHwgJ2dvb2dsZS9nZW1pbmktZmxhc2gtMS41Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1x1MjZBMFx1RkUwRiBDb3VsZCBub3QgbG9hZCBtb2RlbHMuIFVzaW5nIGN1cnJlbnQgc2V0dGluZy4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGQuc2V0RGlzYWJsZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGQub25DaGFuZ2UoYXN5bmMgdiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyU2V0dGluZ3MubW9kZWwgPSB2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKHByb3ZpZGVyID09PSAnb2xsYW1hJykge1xyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZSgnT2xsYW1hIChMb2NhbCkgU2V0dGluZ3MnKS5zZXRIZWFkaW5nKCk7XHJcblxyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgICAgIC5zZXROYW1lKCdPbGxhbWEgQVBJIEVuZHBvaW50JylcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgbG9jYWwgVVJMIGZvciB5b3VyIE9sbGFtYSBzZXJ2ZXIuJylcclxuICAgICAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignaHR0cDovL2xvY2FsaG9zdDoxMTQzNCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHByb3ZpZGVyU2V0dGluZ3MuYXBpRW5kcG9pbnQgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlclNldHRpbmdzLmFwaUVuZHBvaW50ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWZyZXNoIHRoZSBzZXR0aW5ncyB0byByZS1mZXRjaCBtb2RlbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7IFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoJ01vZGVsJylcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKCdDaG9vc2UgYSBsb2NhbCBtb2RlbCB0byB1c2UuJylcclxuICAgICAgICAgICAgICAgIC5hZGREcm9wZG93bihhc3luYyBkZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGQuc2V0RGlzYWJsZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGQuYWRkT3B0aW9uKCcnLCAnRmV0Y2hpbmcgbG9jYWwgbW9kZWxzLi4uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBwcm92aWRlclNldHRpbmdzLmFwaUVuZHBvaW50IHx8ICdodHRwOi8vbG9jYWxob3N0OjExNDM0JztcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgcmVxdWVzdFVybCh7IHVybDogYCR7ZW5kcG9pbnR9L2FwaS90YWdzYCB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3AuanNvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRkLnNlbGVjdEVsLmVtcHR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLm1vZGVscyAmJiBkYXRhLm1vZGVscy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5tb2RlbHMuZm9yRWFjaCgobTogYW55KSA9PiBkZC5hZGRPcHRpb24obS5uYW1lLCBtLm5hbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZC5zZXRWYWx1ZShwcm92aWRlclNldHRpbmdzLm1vZGVsIHx8IGRhdGEubW9kZWxzWzBdLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGQuYWRkT3B0aW9uKCcnLCAnTm8gbW9kZWxzIGZvdW5kJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIE9sbGFtYSBtb2RlbHM6XCIsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBcdTI2QTBcdUZFMEYgQ291bGQgbm90IGNvbm5lY3QgdG8gT2xsYW1hIGF0ICR7ZW5kcG9pbnR9LmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZC5zZWxlY3RFbC5lbXB0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZC5hZGRPcHRpb24ocHJvdmlkZXJTZXR0aW5ncy5tb2RlbCB8fCAnbGxhbWEzJywgYChFbnRlciBtb2RlbCBuYW1lIG1hbnVhbGx5KWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZC5zZXRWYWx1ZShwcm92aWRlclNldHRpbmdzLm1vZGVsIHx8ICdsbGFtYTMnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZGQuc2V0RGlzYWJsZWQoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkZC5vbkNoYW5nZShhc3luYyB2ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJTZXR0aW5ncy5tb2RlbCA9IHY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAocHJvdmlkZXIgPT09ICdjdXN0b20nKSB7XHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXROYW1lKCdDdXN0b20gRW5kcG9pbnQgU2V0dGluZ3MnKS5zZXRIZWFkaW5nKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgICAgIC5zZXROYW1lKCdBUEkgRW5kcG9pbnQgVVJMJylcclxuICAgICAgICAgICAgICAgIC5hZGRUZXh0KHQgPT4gdC5zZXRWYWx1ZShwcm92aWRlclNldHRpbmdzLmFwaUVuZHBvaW50IHx8ICcnKS5vbkNoYW5nZShhc3luYyB2ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlclNldHRpbmdzLmFwaUVuZHBvaW50ID0gdjsgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgICAgIC5zZXROYW1lKCdBUEkgS2V5IChPcHRpb25hbCknKVxyXG4gICAgICAgICAgICAgICAgLnNldERlc2MoJ1lvdXIgQVBJIGtleS4gVXNlIHthcGlLZXl9IGluIEhlYWRlcnMgaWYgbmVlZGVkLicpXHJcbiAgICAgICAgICAgICAgICAuYWRkVGV4dCh0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0LnNldFZhbHVlKHByb3ZpZGVyU2V0dGluZ3MuYXBpS2V5IHx8ICcnKS5vbkNoYW5nZShhc3luYyB2ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJTZXR0aW5ncy5hcGlLZXkgPSB2LnRyaW0oKTsgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5pbnB1dEVsLnR5cGUgPSAncGFzc3dvcmQnO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgICAgIC5zZXROYW1lKCdNb2RlbCBOYW1lJylcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgbW9kZWwgaWRlbnRpZmllciB0byBpbmNsdWRlIGluIHRoZSByZXF1ZXN0IGJvZHkuJylcclxuICAgICAgICAgICAgICAgIC5hZGRUZXh0KHQgPT4gdC5zZXRWYWx1ZShwcm92aWRlclNldHRpbmdzLm1vZGVsIHx8ICcnKS5vbkNoYW5nZShhc3luYyB2ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlclNldHRpbmdzLm1vZGVsID0gdjsgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgICAgIC5zZXROYW1lKCdSZXF1ZXN0IEhlYWRlcnMgKEpTT04pJylcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKCdKU09OIG9iamVjdCBmb3IgcmVxdWVzdCBoZWFkZXJzLiBVc2Uge2FwaUtleX0gZm9yIHlvdXIga2V5LicpXHJcbiAgICAgICAgICAgICAgICAuYWRkVGV4dEFyZWEodGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhLnNldFZhbHVlKHByb3ZpZGVyU2V0dGluZ3MuaGVhZGVycyB8fCBERUZBVUxUX1NFVFRJTkdTLnByb3ZpZGVyU2V0dGluZ3MuY3VzdG9tLmhlYWRlcnMpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jIHYgPT4geyBwcm92aWRlclNldHRpbmdzLmhlYWRlcnMgPSB2OyBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGEuaW5wdXRFbC5yb3dzID0gNDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgICAgICAuc2V0TmFtZSgnUmVxdWVzdCBCb2R5IChKU09OIFRlbXBsYXRlKScpXHJcbiAgICAgICAgICAgICAgICAuc2V0RGVzYygnSlNPTiB0ZW1wbGF0ZSB3aXRoIHBsYWNlaG9sZGVyczoge21vZGVsfSwge3N5c3RlbVByb21wdH0sIHt1c2VyUHJvbXB0fS4nKVxyXG4gICAgICAgICAgICAgICAgLmFkZFRleHRBcmVhKHRhID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0YS5zZXRWYWx1ZShwcm92aWRlclNldHRpbmdzLnJlcXVlc3RCb2R5IHx8IERFRkFVTFRfU0VUVElOR1MucHJvdmlkZXJTZXR0aW5ncy5jdXN0b20ucmVxdWVzdEJvZHkpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jIHYgPT4geyBwcm92aWRlclNldHRpbmdzLnJlcXVlc3RCb2R5ID0gdjsgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhLmlucHV0RWwucm93cyA9IDEwO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgICAgIC5zZXROYW1lKCdSZXNwb25zZSBQYXRoJylcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKCdEb3Qgbm90YXRpb24gcGF0aCB0byB0aGUgdHJhbnNsYXRlZCB0ZXh0IGluIHRoZSByZXNwb25zZSBKU09OLicpXHJcbiAgICAgICAgICAgICAgICAuYWRkVGV4dCh0ID0+IHRcclxuICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ2UuZy4sIGNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50JylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUocHJvdmlkZXJTZXR0aW5ncy5yZXNwb25zZVBhdGggfHwgREVGQVVMVF9TRVRUSU5HUy5wcm92aWRlclNldHRpbmdzLmN1c3RvbS5yZXNwb25zZVBhdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jIHYgPT4geyBwcm92aWRlclNldHRpbmdzLnJlc3BvbnNlUGF0aCA9IHY7IGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpOyB9KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaHInKTtcclxuXHJcbiAgICAgICAgLy8gLS0tIEdFTkVSQUwgU0VUVElOR1MgLS0tXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldE5hbWUoJ0dlbmVyYWwgU2V0dGluZ3MnKS5zZXRIZWFkaW5nKCk7XHJcblxyXG4gICAgICAgIC8vIFN0b3JhZ2UgTG9jYXRpb25cclxuICAgICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnVHJhbnNsYXRpb24gU3RvcmFnZSBMb2NhdGlvbicpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdDaG9vc2Ugd2hlcmUgdG8gc2F2ZSB0cmFuc2xhdGlvbiBmaWxlcy4gTGVhdmUgZW1wdHkgdG8gc2F2ZSBuZXh0IHRvIGVhY2ggUERGLicpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZm9sZGVyU3VnZ2VzdCA9IG5ldyBGb2xkZXJTdWdnZXN0KHRoaXMuYXBwLCB0ZXh0LmlucHV0RWwucGFyZW50RWxlbWVudCEpO1xyXG4gICAgICAgICAgICAgICAgZm9sZGVyU3VnZ2VzdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zdG9yYWdlTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdGV4dC5pbnB1dEVsLnJlcGxhY2VXaXRoKGZvbGRlclN1Z2dlc3QuaW5wdXRFbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9sZGVyU3VnZ2VzdC5pbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZm9sZGVyU3VnZ2VzdC5nZXRWYWx1ZSgpLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09ICcvJyB8fCB2YWx1ZSA9PT0gJy4nIHx8IHZhbHVlID09PSAnLi4nKSB2YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB2YWx1ZSA/IG5vcm1hbGl6ZVBhdGgodmFsdWUgKyAodmFsdWUuZW5kc1dpdGgoJy8nKSA/ICcnIDogJy8nKSkgOiAnJztcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zdG9yYWdlTG9jYXRpb24gPSBub3JtYWxpemVkOyBcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBcdUQ4M0RcdURDQzEgVHJhbnNsYXRpb24gbG9jYXRpb24gc2V0IHRvOiAke25vcm1hbGl6ZWQgfHwgJ05leHQgdG8gUERGJ31gKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gVHJhbnNsYXRpb24gQmVoYXZpb3JcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ0VuYWJsZSBUcmFuc2xhdGlvbicpXHJcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodCA9PiB0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmVuYWJsZVRyYW5zbGF0aW9uKS5vbkNoYW5nZShhc3luYyB2ID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmVuYWJsZVRyYW5zbGF0aW9uID0gdjsgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdVc2UgQmF0Y2ggVHJhbnNsYXRpb24nKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnU2VuZCBhbGwgdGV4dCBpbiBvbmUgcmVxdWVzdCAocmVjb21tZW5kZWQpLicpXHJcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodCA9PiB0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnVzZUJhdGNoVHJhbnNsYXRpb24pLm9uQ2hhbmdlKGFzeW5jIHYgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudXNlQmF0Y2hUcmFuc2xhdGlvbiA9IHY7IGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ0F1dG8tc2F2ZSBPdmVybGF5JylcclxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0ID0+IHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYXV0b1NhdmVPdmVybGF5KS5vbkNoYW5nZShhc3luYyB2ID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmF1dG9TYXZlT3ZlcmxheSA9IHY7IGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ0F1dG8tcmVmcmVzaCBUcmFuc2xhdGlvbnMnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnQXV0b21hdGljYWxseSByZS10cmFuc2xhdGUgd2hlbiBhIFBERiBpcyBvcGVuZWQuJylcclxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0ID0+IHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYXV0b1JlZnJlc2hPdmVybGF5KS5vbkNoYW5nZShhc3luYyB2ID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmF1dG9SZWZyZXNoT3ZlcmxheSA9IHY7IGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIC8vIExhbmd1YWdlIFNldHRpbmdzXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdTb3VyY2UgTGFuZ3VhZ2UnKVxyXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBBVkFJTEFCTEVfTEFOR1VBR0VTLmZvckVhY2gobCA9PiBkLmFkZE9wdGlvbihsLmNvZGUsIGwubmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgZC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zb3VyY2VMYW5ndWFnZSkub25DaGFuZ2UoYXN5bmMgdiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc291cmNlTGFuZ3VhZ2UgPSB2OyBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdUYXJnZXQgTGFuZ3VhZ2UnKVxyXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBBVkFJTEFCTEVfTEFOR1VBR0VTLmZpbHRlcihsID0+IGwuY29kZSAhPT0gJ2F1dG8nKS5mb3JFYWNoKGwgPT4gZC5hZGRPcHRpb24obC5jb2RlLCBsLm5hbWUpKTtcclxuICAgICAgICAgICAgICAgIGQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudGFyZ2V0TGFuZ3VhZ2UpLm9uQ2hhbmdlKGFzeW5jIHYgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnRhcmdldExhbmd1YWdlID0gdjsgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdocicpO1xyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXROYW1lKCdBZHZhbmNlZCBTZXR0aW5ncycpLnNldEhlYWRpbmcoKTtcclxuXHJcbiAgICAgICAgLy8gUHJvbXB0c1xyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnQmF0Y2ggVHJhbnNsYXRpb24gUHJvbXB0JylcclxuICAgICAgICAgICAgLnNldERlc2MoJ1N5c3RlbSBwcm9tcHQgZm9yIGJhdGNoIHRyYW5zbGF0aW9ucy4gUGxhY2Vob2xkZXJzOiB7c291cmNlTGFuZ30sIHt0YXJnZXRMYW5nfSwge2xpbmVDb3VudH0sIHtpbnB1dFRleHR9JylcclxuICAgICAgICAgICAgLnRoZW4oc2V0dGluZyA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nLmNvbnRyb2xFbC5zdHlsZS5mbGV4RGlyZWN0aW9uID0gJ2NvbHVtbic7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nLmNvbnRyb2xFbC5zdHlsZS5hbGlnbkl0ZW1zID0gJ2ZsZXgtZW5kJztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dGFyZWEgPSBuZXcgVGV4dEFyZWFDb21wb25lbnQoc2V0dGluZy5jb250cm9sRWwpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmJhdGNoUHJvbXB0KS5vbkNoYW5nZShhc3luYyB2ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuYmF0Y2hQcm9tcHQgPSB2OyBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRleHRhcmVhLmlucHV0RWwuc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcbiAgICAgICAgICAgICAgICB0ZXh0YXJlYS5pbnB1dEVsLnJvd3MgPSA4O1xyXG5cclxuICAgICAgICAgICAgICAgIG5ldyBCdXR0b25Db21wb25lbnQoc2V0dGluZy5jb250cm9sRWwpLnNldEJ1dHRvblRleHQoJ1Jlc3RvcmUgRGVmYXVsdCcpLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmJhdGNoUHJvbXB0ID0gREVGQVVMVF9TRVRUSU5HUy5iYXRjaFByb21wdDtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYS5zZXRWYWx1ZShERUZBVUxUX1NFVFRJTkdTLmJhdGNoUHJvbXB0KTtcclxuICAgICAgICAgICAgICAgIH0pLmJ1dHRvbkVsLnN0eWxlLm1hcmdpblRvcCA9ICc4cHgnO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdTaW5nbGUgU2VudGVuY2UgUHJvbXB0JylcclxuICAgICAgICAgICAgLnNldERlc2MoJ1N5c3RlbSBwcm9tcHQgZm9yIHNpbmdsZSB0cmFuc2xhdGlvbnMuIFBsYWNlaG9sZGVyczoge3NvdXJjZUxhbmd9LCB7dGFyZ2V0TGFuZ30nKVxyXG4gICAgICAgICAgICAudGhlbihzZXR0aW5nID0+IHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmcuY29udHJvbEVsLnN0eWxlLmZsZXhEaXJlY3Rpb24gPSAnY29sdW1uJztcclxuICAgICAgICAgICAgICAgIHNldHRpbmcuY29udHJvbEVsLnN0eWxlLmFsaWduSXRlbXMgPSAnZmxleC1lbmQnO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0YXJlYSA9IG5ldyBUZXh0QXJlYUNvbXBvbmVudChzZXR0aW5nLmNvbnRyb2xFbClcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Muc2luZ2xlUHJvbXB0KS5vbkNoYW5nZShhc3luYyB2ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2luZ2xlUHJvbXB0ID0gdjsgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0YXJlYS5pbnB1dEVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG4gICAgICAgICAgICAgICAgdGV4dGFyZWEuaW5wdXRFbC5yb3dzID0gNDtcclxuXHJcbiAgICAgICAgICAgICAgICBuZXcgQnV0dG9uQ29tcG9uZW50KHNldHRpbmcuY29udHJvbEVsKS5zZXRCdXR0b25UZXh0KCdSZXN0b3JlIERlZmF1bHQnKS5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zaW5nbGVQcm9tcHQgPSBERUZBVUxUX1NFVFRJTkdTLnNpbmdsZVByb21wdDtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYS5zZXRWYWx1ZShERUZBVUxUX1NFVFRJTkdTLnNpbmdsZVByb21wdCk7XHJcbiAgICAgICAgICAgICAgICB9KS5idXR0b25FbC5zdHlsZS5tYXJnaW5Ub3AgPSAnOHB4JztcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIC0tLSBORVc6IENVU1RPTSBDT1BZIEZPUk1BVFMgLS0tXHJcbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2hyJyk7XHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldE5hbWUoJ0N1c3RvbSBDb3B5IEZvcm1hdHMnKS5zZXRIZWFkaW5nKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyRGVzYyA9IGNyZWF0ZUZyYWdtZW50KGRvYyA9PiB7XHJcbiAgICAgICAgICAgIGRvYy5jcmVhdGVTcGFuKHsgdGV4dDogJ1BsYWNlaG9sZGVyczogJyB9KTtcclxuICAgICAgICAgICAgZG9jLmNyZWF0ZUVsKCdjb2RlJywgeyB0ZXh0OiAne3RleHR9JyB9KTtcclxuICAgICAgICAgICAgZG9jLmNyZWF0ZVNwYW4oeyB0ZXh0OiAnLCAnIH0pO1xyXG4gICAgICAgICAgICBkb2MuY3JlYXRlRWwoJ2NvZGUnLCB7IHRleHQ6ICd7YmxvY2txdW90ZV90ZXh0fScgfSk7XHJcbiAgICAgICAgICAgIGRvYy5jcmVhdGVTcGFuKHsgdGV4dDogJywgJyB9KTtcclxuICAgICAgICAgICAgZG9jLmNyZWF0ZUVsKCdjb2RlJywgeyB0ZXh0OiAne2ZpbGVuYW1lfScgfSk7XHJcbiAgICAgICAgICAgIGRvYy5jcmVhdGVTcGFuKHsgdGV4dDogJywgJyB9KTtcclxuICAgICAgICAgICAgZG9jLmNyZWF0ZUVsKCdjb2RlJywgeyB0ZXh0OiAne3BhZ2VsaW5rfScgfSk7XHJcbiAgICAgICAgICAgIGRvYy5jcmVhdGVTcGFuKHsgdGV4dDogJywgJyB9KTtcclxuICAgICAgICAgICAgZG9jLmNyZWF0ZUVsKCdjb2RlJywgeyB0ZXh0OiAne3BhZ2VudW1iZXJ9JyB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgY3JlYXRlRm9ybWF0U2V0dGluZyA9IChuYW1lOiBzdHJpbmcsIHNldHRpbmdLZXk6ICdjYWxsb3V0Rm9ybWF0JyB8ICdjaXRhdGlvbkZvcm1hdCcgfCAnZm9vdG5vdGVGb3JtYXQnKSA9PiB7XHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUobmFtZSlcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKHBsYWNlaG9sZGVyRGVzYylcclxuICAgICAgICAgICAgICAgIC50aGVuKHNldHRpbmcgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmcuY29udHJvbEVsLnN0eWxlLmZsZXhEaXJlY3Rpb24gPSAnY29sdW1uJztcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nLmNvbnRyb2xFbC5zdHlsZS5hbGlnbkl0ZW1zID0gJ2ZsZXgtZW5kJztcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0YXJlYSA9IG5ldyBUZXh0QXJlYUNvbXBvbmVudChzZXR0aW5nLmNvbnRyb2xFbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzW3NldHRpbmdLZXldKS5vbkNoYW5nZShhc3luYyB2ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzW3NldHRpbmdLZXldID0gdjsgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRhcmVhLmlucHV0RWwuc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWEuaW5wdXRFbC5yb3dzID0gNTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IEJ1dHRvbkNvbXBvbmVudChzZXR0aW5nLmNvbnRyb2xFbCkuc2V0QnV0dG9uVGV4dCgnUmVzdG9yZSBEZWZhdWx0Jykub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzW3NldHRpbmdLZXldID0gREVGQVVMVF9TRVRUSU5HU1tzZXR0aW5nS2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRhcmVhLnNldFZhbHVlKERFRkFVTFRfU0VUVElOR1Nbc2V0dGluZ0tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmJ1dHRvbkVsLnN0eWxlLm1hcmdpblRvcCA9ICc4cHgnO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY3JlYXRlRm9ybWF0U2V0dGluZygnQ2FsbG91dCBGb3JtYXQnLCAnY2FsbG91dEZvcm1hdCcpO1xyXG4gICAgICAgIGNyZWF0ZUZvcm1hdFNldHRpbmcoJ0NpdGF0aW9uIEZvcm1hdCcsICdjaXRhdGlvbkZvcm1hdCcpO1xyXG4gICAgICAgIGNyZWF0ZUZvcm1hdFNldHRpbmcoJ0Zvb3Rub3RlIEZvcm1hdCcsICdmb290bm90ZUZvcm1hdCcpO1xyXG5cclxuICAgICAgICAvLyBWaXN1YWxzIGFuZCBQcm9jZXNzaW5nXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdPdXRwdXQgRm9udCBTaXplIFNjYWxlJylcclxuICAgICAgICAgICAgLmFkZFNsaWRlcihzID0+IHMuc2V0TGltaXRzKDAuNCwgMS4yLCAwLjA1KS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5vdXRwdXRGb250U2l6ZVNjYWxlKS5zZXREeW5hbWljVG9vbHRpcCgpLm9uQ2hhbmdlKGFzeW5jIHYgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3V0cHV0Rm9udFNpemVTY2FsZSA9IHY7IGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnT3V0cHV0IExpbmUgSGVpZ2h0JylcclxuICAgICAgICAgICAgLmFkZFNsaWRlcihzID0+IHMuc2V0TGltaXRzKDAuNSwgMi4wLCAwLjA1KS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5vdXRwdXRMaW5lSGVpZ2h0KS5zZXREeW5hbWljVG9vbHRpcCgpLm9uQ2hhbmdlKGFzeW5jIHYgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3V0cHV0TGluZUhlaWdodCA9IHY7IGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnTWF4IEJhdGNoIElucHV0IExlbmd0aCcpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdNYXhpbXVtIGNoYXJhY3RlcnMgc2VudCBhdCBvbmNlIHRvIHByZXZlbnQgQVBJIGVycm9ycy4nKVxyXG4gICAgICAgICAgICAuYWRkU2xpZGVyKHMgPT4gcy5zZXRMaW1pdHMoNTAsIDE1MDAwLCA1MCkuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubWF4QmF0Y2hDaGFycykuc2V0RHluYW1pY1Rvb2x0aXAoKS5vbkNoYW5nZShhc3luYyB2ID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm1heEJhdGNoQ2hhcnMgPSB2OyBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ01hbnVhbCBQYXJhZ3JhcGggUmVmaW5lbWVudCcpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdFbmFibGUgU2hpZnQrY2xpY2sgYW5kIEN0cmwrTSB0byBtZXJnZSB0cmFuc2xhdGlvbiBibG9ja3MuJylcclxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0ID0+IHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubWFudWFsUmVmaW5lbWVudE1vZGUpLm9uQ2hhbmdlKGFzeW5jIHYgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MubWFudWFsUmVmaW5lbWVudE1vZGUgPSB2OyBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ0RlYnVnIE1vZGUnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnTG9nIGRldGFpbGVkIGluZm9ybWF0aW9uIHRvIHRoZSBkZXZlbG9wZXIgY29uc29sZS4nKVxyXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKHQgPT4gdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWJ1Z01vZGUpLm9uQ2hhbmdlKGFzeW5jIHYgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVidWdNb2RlID0gdjsgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgIH1cclxufSIsICIvLyB0eXBlcy50c1xyXG5pbXBvcnQgdHlwZSB7IFBsdWdpbiB9IGZyb20gJ29ic2lkaWFuJztcclxuXHJcbi8vID09PSBJbnRlcmZhY2VzID09PVxyXG5cclxuLyoqXHJcbiAqIFNldHRpbmdzIGZvciBhbiBpbmRpdmlkdWFsIEFQSSBwcm92aWRlci5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJvdmlkZXJTZXR0aW5ncyB7XHJcbiAgICBhcGlLZXk/OiBzdHJpbmc7XHJcbiAgICBtb2RlbD86IHN0cmluZztcclxuICAgIGFwaUVuZHBvaW50Pzogc3RyaW5nO1xyXG4gICAgLy8gRm9yIGN1c3RvbSBwcm92aWRlcnNcclxuICAgIGhlYWRlcnM/OiBzdHJpbmc7XHJcbiAgICByZXF1ZXN0Qm9keT86IHN0cmluZztcclxuICAgIHJlc3BvbnNlUGF0aD86IHN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIE1haW4gc2V0dGluZ3MgZm9yIHRoZSBPcGVuUm91dGVyIFRyYW5zbGF0b3IgcGx1Z2luLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBPcGVuUm91dGVyVHJhbnNsYXRvclNldHRpbmdzIHtcclxuICAgIC8vIC0tLSBQcm92aWRlciBNYW5hZ2VtZW50IC0tLVxyXG4gICAgYXBpUHJvdmlkZXI6ICdvcGVucm91dGVyJyB8ICdvbGxhbWEnIHwgJ2N1c3RvbSc7XHJcbiAgICBwcm92aWRlclNldHRpbmdzOiB7XHJcbiAgICAgICAgb3BlbnJvdXRlcjogUHJvdmlkZXJTZXR0aW5ncztcclxuICAgICAgICBvbGxhbWE6IFByb3ZpZGVyU2V0dGluZ3M7XHJcbiAgICAgICAgY3VzdG9tOiBQcm92aWRlclNldHRpbmdzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUcmFuc2xhdGlvbiBCZWhhdmlvclxyXG4gICAgZW5hYmxlVHJhbnNsYXRpb246IGJvb2xlYW47XHJcbiAgICB1c2VCYXRjaFRyYW5zbGF0aW9uOiBib29sZWFuO1xyXG4gICAgZGVidWdNb2RlOiBib29sZWFuO1xyXG5cclxuICAgIC8vIExhbmd1YWdlIFNldHRpbmdzXHJcbiAgICBzb3VyY2VMYW5ndWFnZTogc3RyaW5nO1xyXG4gICAgdGFyZ2V0TGFuZ3VhZ2U6IHN0cmluZztcclxuXHJcbiAgICAvLyBWaXN1YWwgU2V0dGluZ3NcclxuICAgIG91dHB1dEZvbnRTaXplU2NhbGU6IG51bWJlcjtcclxuICAgIG91dHB1dExpbmVIZWlnaHQ6IG51bWJlcjtcclxuICAgIG92ZXJsYXlPcGFjaXR5OiBudW1iZXI7XHJcblxyXG4gICAgLy8gUHJvY2Vzc2luZyBTZXR0aW5nc1xyXG4gICAgbWF4QmF0Y2hDaGFyczogbnVtYmVyO1xyXG4gICAgbWVyZ2VPblN0eWxlQ2hhbmdlOiBib29sZWFuO1xyXG5cclxuICAgIC8vIFN0b3JhZ2UgU2V0dGluZ3NcclxuICAgIGF1dG9TYXZlT3ZlcmxheTogYm9vbGVhbjtcclxuICAgIGF1dG9SZWZyZXNoT3ZlcmxheTogYm9vbGVhbjtcclxuICAgIHN0b3JhZ2VMb2NhdGlvbjogc3RyaW5nO1xyXG4gICAgdXNlSW5kaXZpZHVhbE1hcmtkb3duU3RvcmFnZTogYm9vbGVhbjtcclxuICAgIGluZGV4RmlsZVBhdGg6IHN0cmluZztcclxuXHJcbiAgICAvLyBVSSBTZXR0aW5nc1xyXG4gICAgbWFudWFsUmVmaW5lbWVudE1vZGU6IGJvb2xlYW47XHJcbiAgICBzaG93T3ZlcmxheUJ5RGVmYXVsdDogYm9vbGVhbjtcclxuICAgIGNsaWNrVG9TaG93TW9kZTogYm9vbGVhbjtcclxuXHJcbiAgICAvLyBDdXN0b20gUHJvbXB0c1xyXG4gICAgYmF0Y2hQcm9tcHQ6IHN0cmluZztcclxuICAgIHNpbmdsZVByb21wdDogc3RyaW5nO1xyXG5cclxuICAgIC8vIC0tLSBORVc6IEN1c3RvbSBDb3B5IEZvcm1hdHMgLS0tXHJcbiAgICBjYWxsb3V0Rm9ybWF0OiBzdHJpbmc7XHJcbiAgICBjaXRhdGlvbkZvcm1hdDogc3RyaW5nO1xyXG4gICAgZm9vdG5vdGVGb3JtYXQ6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xhdGlvblVuaXQge1xyXG4gICAgb3JpZ2luYWxTcGFuczogSFRNTFNwYW5FbGVtZW50W107XHJcbiAgICB0ZXh0OiBzdHJpbmc7XHJcbiAgICBpZDogc3RyaW5nOyAvLyBVbmlxdWUgSUQgZm9yIHRoZSBjaHVuayAoc2VudGVuY2Ugb3IgcGFyYWdyYXBoKVxyXG4gICAgcGFyYWdyYXBoSWQ6IHN0cmluZzsgLy8gSUQgdG8gZ3JvdXAgY2h1bmtzIGJ5IG9yaWdpbmFsIHBhcmFncmFwaFxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE92ZXJsYXlQb3NpdGlvbkRhdGEge1xyXG4gICAgc2VsZWN0b3I6IHN0cmluZztcclxuICAgIHRleHRDb250ZW50OiBzdHJpbmc7XHJcbiAgICByZWxhdGl2ZVJlY3Q6IHtcclxuICAgICAgICBsZWZ0OiBudW1iZXI7XHJcbiAgICAgICAgdG9wOiBudW1iZXI7XHJcbiAgICAgICAgd2lkdGg6IG51bWJlcjtcclxuICAgICAgICBoZWlnaHQ6IG51bWJlcjtcclxuICAgIH07XHJcbiAgICBwYWdlOiBudW1iZXI7XHJcbiAgICB0cmFuc2xhdGVkVGV4dDogc3RyaW5nO1xyXG4gICAgZm9udERhdGE/OiB7XHJcbiAgICAgICAgc2l6ZXM6IG51bWJlcltdO1xyXG4gICAgICAgIHJlbGF0aXZlU2l6ZXM6IG51bWJlcltdO1xyXG4gICAgICAgIHJlZmVyZW5jZUhlaWdodDogbnVtYmVyO1xyXG4gICAgfTtcclxuICAgIGZvbnRTaXplPzogbnVtYmVyO1xyXG4gICAgZm9udEZhbWlseT86IHN0cmluZztcclxuICAgIG9yaWdpbmFsRm9udFNpemVzPzogbnVtYmVyW107XHJcbiAgICBmb250V2VpZ2h0Pzogc3RyaW5nO1xyXG4gICAgZm9udFN0eWxlPzogc3RyaW5nO1xyXG4gICAgdGV4dERlY29yYXRpb24/OiBzdHJpbmc7XHJcbiAgICB0ZXh0QWxpZ24/OiBzdHJpbmc7XHJcbiAgICBjb2xvcj86IHN0cmluZztcclxuICAgIG9yaWdpbmFsU3R5bGVkVGV4dD86IFN0eWxlZFRleHRTZWdtZW50W107XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3R5bGVkVGV4dFNlZ21lbnQge1xyXG4gICAgdGV4dDogc3RyaW5nO1xyXG4gICAgZm9udFNpemU6IG51bWJlcjtcclxuICAgIGZvbnRGYW1pbHk6IHN0cmluZztcclxuICAgIGlzQm9sZDogYm9vbGVhbjtcclxuICAgIGlzSXRhbGljOiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNhdmVkT3ZlcmxheSB7XHJcbiAgICBmaWxlTmFtZTogc3RyaW5nO1xyXG4gICAgZmlsZVBhdGg6IHN0cmluZztcclxuICAgIHRpbWVzdGFtcDogbnVtYmVyO1xyXG4gICAgcGFnZU92ZXJsYXlzOiBSZWNvcmQ8c3RyaW5nLCBPdmVybGF5UG9zaXRpb25EYXRhW10+O1xyXG4gICAgaW5kZXhMaW5lPzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE92ZXJsYXlFbGVtZW50RGF0YSB7XHJcbiAgICBkYXRhOiBPdmVybGF5UG9zaXRpb25EYXRhO1xyXG4gICAgZWxlbWVudDogSFRNTEVsZW1lbnQ7XHJcbiAgICBiYm94OiBET01SZWN0O1xyXG59XHJcblxyXG4vLyA9PT0gU3VwcG9ydGVkIExhbmd1YWdlcyA9PT1cclxuZXhwb3J0IGNvbnN0IEFWQUlMQUJMRV9MQU5HVUFHRVMgPSBbXHJcbiAgICB7IGNvZGU6ICdhdXRvJywgbmFtZTogJ0F1dG8gRGV0ZWN0JyB9LFxyXG4gICAgeyBjb2RlOiAnZW4nLCBuYW1lOiAnRW5nbGlzaCcgfSxcclxuICAgIHsgY29kZTogJ2VzJywgbmFtZTogJ1NwYW5pc2gnIH0sXHJcbiAgICB7IGNvZGU6ICdmcicsIG5hbWU6ICdGcmVuY2gnIH0sXHJcbiAgICB7IGNvZGU6ICdkZScsIG5hbWU6ICdHZXJtYW4nIH0sXHJcbiAgICB7IGNvZGU6ICdpdCcsIG5hbWU6ICdJdGFsaWFuJyB9LFxyXG4gICAgeyBjb2RlOiAncHQnLCBuYW1lOiAnUG9ydHVndWVzZScgfSxcclxuICAgIHsgY29kZTogJ3J1JywgbmFtZTogJ1J1c3NpYW4nIH0sXHJcbiAgICB7IGNvZGU6ICdqYScsIG5hbWU6ICdKYXBhbmVzZScgfSxcclxuICAgIHsgY29kZTogJ2tvJywgbmFtZTogJ0tvcmVhbicgfSxcclxuICAgIHsgY29kZTogJ3poJywgbmFtZTogJ0NoaW5lc2UnIH0sXHJcbiAgICB7IGNvZGU6ICdhcicsIG5hbWU6ICdBcmFiaWMnIH0sXHJcbiAgICB7IGNvZGU6ICdoaScsIG5hbWU6ICdIaW5kaScgfSxcclxuICAgIHsgY29kZTogJ25sJywgbmFtZTogJ0R1dGNoJyB9LFxyXG4gICAgeyBjb2RlOiAncGwnLCBuYW1lOiAnUG9saXNoJyB9LFxyXG4gICAgeyBjb2RlOiAnc3YnLCBuYW1lOiAnU3dlZGlzaCcgfSxcclxuICAgIHsgY29kZTogJ3RyJywgbmFtZTogJ1R1cmtpc2gnIH0sXHJcbiAgICB7IGNvZGU6ICd1aycsIG5hbWU6ICdVa3JhaW5pYW4nIH0sXHJcbiAgICB7IGNvZGU6ICdubycsIG5hbWU6ICdOb3J3ZWdpYW4nIH0sXHJcbiAgICB7IGNvZGU6ICdkYScsIG5hbWU6ICdEYW5pc2gnIH0sXHJcbiAgICB7IGNvZGU6ICdmaScsIG5hbWU6ICdGaW5uaXNoJyB9LFxyXG4gICAgeyBjb2RlOiAnY3MnLCBuYW1lOiAnQ3plY2gnIH0sXHJcbiAgICB7IGNvZGU6ICdodScsIG5hbWU6ICdIdW5nYXJpYW4nIH0sXHJcbiAgICB7IGNvZGU6ICdybycsIG5hbWU6ICdSb21hbmlhbicgfSxcclxuICAgIHsgY29kZTogJ2JnJywgbmFtZTogJ0J1bGdhcmlhbicgfSxcclxuICAgIHsgY29kZTogJ2hyJywgbmFtZTogJ0Nyb2F0aWFuJyB9LFxyXG4gICAgeyBjb2RlOiAnc2snLCBuYW1lOiAnU2xvdmFrJyB9LFxyXG4gICAgeyBjb2RlOiAnc2wnLCBuYW1lOiAnU2xvdmVuaWFuJyB9LFxyXG4gICAgeyBjb2RlOiAnZXQnLCBuYW1lOiAnRXN0b25pYW4nIH0sXHJcbiAgICB7IGNvZGU6ICdsdicsIG5hbWU6ICdMYXR2aWFuJyB9LFxyXG4gICAgeyBjb2RlOiAnbHQnLCBuYW1lOiAnTGl0aHVhbmlhbicgfSxcclxuICAgIHsgY29kZTogJ210JywgbmFtZTogJ01hbHRlc2UnIH0sXHJcbiAgICB7IGNvZGU6ICdnYScsIG5hbWU6ICdJcmlzaCcgfSxcclxuICAgIHsgY29kZTogJ2N5JywgbmFtZTogJ1dlbHNoJyB9LFxyXG4gICAgeyBjb2RlOiAnZXUnLCBuYW1lOiAnQmFzcXVlJyB9LFxyXG4gICAgeyBjb2RlOiAnY2EnLCBuYW1lOiAnQ2F0YWxhbicgfSxcclxuICAgIHsgY29kZTogJ2dsJywgbmFtZTogJ0dhbGljaWFuJyB9LFxyXG4gICAgeyBjb2RlOiAnaXMnLCBuYW1lOiAnSWNlbGFuZGljJyB9LFxyXG5dO1xyXG5cclxuLy8gPT09IERlZmF1bHQgU2V0dGluZ3MgPT09XHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBPcGVuUm91dGVyVHJhbnNsYXRvclNldHRpbmdzID0ge1xyXG4gICAgLy8gLS0tIFBST1ZJREVSLUFXQVJFIERFRkFVTFRTIC0tLVxyXG4gICAgYXBpUHJvdmlkZXI6ICdvcGVucm91dGVyJyxcclxuICAgIHByb3ZpZGVyU2V0dGluZ3M6IHtcclxuICAgICAgICBvcGVucm91dGVyOiB7XHJcbiAgICAgICAgICAgIGFwaUtleTogJycsXHJcbiAgICAgICAgICAgIG1vZGVsOiAnZ29vZ2xlL2dlbWluaS1mbGFzaC0xLjUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbGxhbWE6IHtcclxuICAgICAgICAgICAgYXBpRW5kcG9pbnQ6ICdodHRwOi8vbG9jYWxob3N0OjExNDM0JyxcclxuICAgICAgICAgICAgbW9kZWw6ICdsbGFtYTMnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjdXN0b206IHtcclxuICAgICAgICAgICAgYXBpRW5kcG9pbnQ6ICcnLFxyXG4gICAgICAgICAgICBhcGlLZXk6ICcnLFxyXG4gICAgICAgICAgICBtb2RlbDogJycsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6ICd7XFxuICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcXG4gIFwiQXV0aG9yaXphdGlvblwiOiBcIkJlYXJlciB7YXBpS2V5fVwiXFxufScsXHJcbiAgICAgICAgICAgIHJlcXVlc3RCb2R5OiAne1xcbiAgXCJtb2RlbFwiOiBcInttb2RlbH1cIixcXG4gIFwibWVzc2FnZXNcIjogW1xcbiAgICB7XFxuICAgICAgXCJyb2xlXCI6IFwic3lzdGVtXCIsXFxuICAgICAgXCJjb250ZW50XCI6IFwie3N5c3RlbVByb21wdH1cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgXCJyb2xlXCI6IFwidXNlclwiLFxcbiAgICAgIFwiY29udGVudFwiOiBcInt1c2VyUHJvbXB0fVwiXFxuICAgIH1cXG4gIF1cXG59JyxcclxuICAgICAgICAgICAgcmVzcG9uc2VQYXRoOiAnY2hvaWNlc1swXS5tZXNzYWdlLmNvbnRlbnQnXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBUcmFuc2xhdGlvbiBCZWhhdmlvclxyXG4gICAgZW5hYmxlVHJhbnNsYXRpb246IHRydWUsXHJcbiAgICB1c2VCYXRjaFRyYW5zbGF0aW9uOiB0cnVlLFxyXG4gICAgZGVidWdNb2RlOiBmYWxzZSxcclxuXHJcbiAgICAvLyBMYW5ndWFnZSBTZXR0aW5nc1xyXG4gICAgc291cmNlTGFuZ3VhZ2U6ICdhdXRvJyxcclxuICAgIHRhcmdldExhbmd1YWdlOiAnZW4nLFxyXG5cclxuICAgIC8vIFZpc3VhbCBTZXR0aW5nc1xyXG4gICAgb3V0cHV0Rm9udFNpemVTY2FsZTogMC45NSxcclxuICAgIG91dHB1dExpbmVIZWlnaHQ6IDEuNDUsXHJcbiAgICBvdmVybGF5T3BhY2l0eTogOTksXHJcblxyXG4gICAgLy8gUHJvY2Vzc2luZyBTZXR0aW5nc1xyXG4gICAgbWF4QmF0Y2hDaGFyczogNzUwMCxcclxuICAgIG1lcmdlT25TdHlsZUNoYW5nZTogZmFsc2UsXHJcblxyXG4gICAgLy8gU3RvcmFnZSBTZXR0aW5nc1xyXG4gICAgYXV0b1NhdmVPdmVybGF5OiBmYWxzZSxcclxuICAgIGF1dG9SZWZyZXNoT3ZlcmxheTogZmFsc2UsXHJcbiAgICBzdG9yYWdlTG9jYXRpb246ICcnLFxyXG4gICAgdXNlSW5kaXZpZHVhbE1hcmtkb3duU3RvcmFnZTogdHJ1ZSxcclxuICAgIGluZGV4RmlsZVBhdGg6ICdJbmRleC5tZCcsXHJcblxyXG4gICAgLy8gVUkgU2V0dGluZ3NcclxuICAgIG1hbnVhbFJlZmluZW1lbnRNb2RlOiBmYWxzZSxcclxuICAgIHNob3dPdmVybGF5QnlEZWZhdWx0OiB0cnVlLFxyXG4gICAgY2xpY2tUb1Nob3dNb2RlOiBmYWxzZSxcclxuXHJcbiAgICAvLyBDdXN0b20gUHJvbXB0c1xyXG4gICAgYmF0Y2hQcm9tcHQ6IGBZb3UgYXJlIGEgcHJlY2lzZSBkb2N1bWVudCB0cmFuc2xhdG9yLiBUcmFuc2xhdGUgZWFjaCBvZiB0aGUgZm9sbG93aW5nIG51bWJlcmVkIGxpbmVzIGZyb20ge3NvdXJjZUxhbmd9IHRvIHt0YXJnZXRMYW5nfSwgYW5kIG9ubHkgdGhpcyBsYW5ndWFnZS5cclxuXHJcbkV4YW1wbGU6XHJcbklucHV0OlxyXG4xLiBIZWxsbyB3b3JsZFxyXG4yLiBUaGFuayB5b3UgdmVyeSBtdWNoXHJcbk91dHB1dDpcclxuMS4gSG9sYSBtdW5kb1xyXG4yLiBNdWNoYXMgZ3JhY2lhc1xyXG5cclxuTm93IHRyYW5zbGF0ZTpcclxue2lucHV0VGV4dH1cclxuXHJcblJldHVybiBleGFjdGx5IHtsaW5lQ291bnR9IGxpbmVzIGluIHRoaXMgZm9ybWF0OlxyXG4xLiBUcmFuc2xhdGVkIGxpbmUgb25lXHJcbjIuIFRyYW5zbGF0ZWQgbGluZSB0d29cclxuLi4uXHJcbk5vIGV4dHJhIHRleHQuIE5ldmVyIHNraXAgbnVtYmVyaW5nLiBPbmx5IHJldHVybiB0aGUgbnVtYmVyZWQgbGlzdC5gLFxyXG5cclxuICAgIHNpbmdsZVByb21wdDogYFRyYW5zbGF0ZSBmcm9tIHtzb3VyY2VMYW5nfSB0byB7dGFyZ2V0TGFuZ30uIE9ubHkgb3V0cHV0IHRoZSB0cmFuc2xhdGlvbi4gUHJlc2VydmUgZm9ybWF0dGluZyBhbmQgdG9uZS5gLFxyXG5cclxuICAgIC8vIC0tLSBORVc6IEN1c3RvbSBDb3B5IEZvcm1hdHMgLS0tXHJcbiAgICBjYWxsb3V0Rm9ybWF0OiAnPiBbIXF1b3RlXSBUcmFuc2xhdGlvblxcbj4ge2Jsb2NrcXVvdGVfdGV4dH1cXG4+XFxuPiB7cGFnZWxpbmt9JyxcclxuICAgIGNpdGF0aW9uRm9ybWF0OiAne2Jsb2NrcXVvdGVfdGV4dH1cXG4+IFx1MjAxNCAqe2ZpbGVuYW1lfSwgcGFnZSB7cGFnZW51bWJlcn0qJyxcclxuICAgIGZvb3Rub3RlRm9ybWF0OiAnXnt0ZXh0fSBbW3tmaWxlbmFtZX0jcGFnZT17cGFnZW51bWJlcn18c291cmNlXV0nXHJcbn07IiwgIi8vIHN0b3JhZ2UudHNcclxuaW1wb3J0IHsgVEZpbGUsIFRGb2xkZXIsIG5vcm1hbGl6ZVBhdGgsIE5vdGljZSwgcGFyc2VZYW1sLCBBcHAgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCBPcGVuUm91dGVyVHJhbnNsYXRvclBsdWdpbiBmcm9tICcuL21haW4nO1xyXG5pbXBvcnQgeyBTYXZlZE92ZXJsYXksIE92ZXJsYXlQb3NpdGlvbkRhdGEgfSBmcm9tICcuL3R5cGVzJztcclxuXHJcbi8qKlxyXG4gKiBWRVJTSU9OIEhJU1RPUlk6XHJcbiAqIHYxOiBPcmlnaW5hbCBmb3JtYXQgKGNvbW1lbnRzIHdpdGggcmF3IEpTT04gaW4gYSB0YWJsZSlcclxuICogdjI6IEJhc2U2NCBtZXRhZGF0YSBpbiBhIHRhYmxlXHJcbiAqIHYzOiBDdXJyZW50IGltcHJvdmVkIGZvcm1hdCAoSlNPTiBpbiAlJSBjb21tZW50cywgbm8gdGFibGUpXHJcbiAqL1xyXG5jb25zdCBTVE9SQUdFX0ZPUk1BVF9WRVJTSU9OID0gMztcclxuXHJcbi8qKlxyXG4gKiBNYW5hZ2VzIHN0b3JhZ2UgYW5kIHJldHJpZXZhbCBvZiB0cmFuc2xhdGlvbiBvdmVybGF5cyBpbiBpbmRpdmlkdWFsIC50cmFuc2xhdGlvbnMubWQgZmlsZXMuXHJcbiAqIFVzZXMgZnJvbnRtYXR0ZXIgbGlua2FnZSAoYHBkZi1zb3VyY2U6ICdbW2ZpbGUucGRmXV0nYCkgZm9yIGZhc3QsIHJlbmFtaW5nLXJlc2lsaWVudCBsb29rdXAuXHJcbiAqXHJcbiAqIEtleSBpbXByb3ZlbWVudHMgaW4gdjM6XHJcbiAqIC0gSHVtYW4tcmVhZGFibGUgSlNPTiBtZXRhZGF0YSBpbnNpZGUgT2JzaWRpYW4gY29tbWVudHMgKGAlJS4uLiUlYCkuXHJcbiAqIC0gT3JpZ2luYWwgdGV4dCBpcyBzdG9yZWQgaW5zaWRlIHRoZSBtZXRhZGF0YSwgbm90IGluIHRoZSBtYXJrZG93biBib2R5LlxyXG4gKiAtIE5vIG1vcmUgbWFya2Rvd24gdGFibGVzLCBtYWtpbmcgZWRpdHMgYW5kIGNvcHktcGFzdGluZyBzaW1wbGVyLlxyXG4gKiAtIFRyYW5zbGF0ZWQgdGV4dCBhcHBlYXJzIGRpcmVjdGx5IHVuZGVyIGl0cyBtZXRhZGF0YSwgd2l0aCBgPGJyPmAgZm9yIG5ld2xpbmVzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRyYW5zbGF0aW9uU3RvcmFnZSB7XHJcbiAgICBwcml2YXRlIHBsdWdpbjogT3BlblJvdXRlclRyYW5zbGF0b3JQbHVnaW47XHJcbiAgICBwcml2YXRlIGFwcDogQXBwO1xyXG4gICAgcHJpdmF0ZSBsb2FkaW5nUHJvbWlzZXM6IE1hcDxzdHJpbmcsIFByb21pc2U8dm9pZD4+ID0gbmV3IE1hcCgpOyAgLy8gUGVyLWZpbGUgY29uY3VycmVuY3kgZ3VhcmRcclxuICAgIHByaXZhdGUgd3JpdGluZ1Byb21pc2VzOiBNYXA8c3RyaW5nLCBQcm9taXNlPHZvaWQ+PiA9IG5ldyBNYXAoKTsgLy8gQ29uY3VycmVuY3kgZ3VhcmQgZm9yIHdyaXRpbmdcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwbHVnaW46IE9wZW5Sb3V0ZXJUcmFuc2xhdG9yUGx1Z2luKSB7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy5hcHAgPSBwbHVnaW4uYXBwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdXNlci1kZWZpbmVkIHN0b3JhZ2UgbG9jYXRpb24gZm9yIHRyYW5zbGF0aW9uIGZpbGVzLlxyXG4gICAgICogRGVmYXVsdHMgdG8gc2FtZSBmb2xkZXIgYXMgUERGIGlmIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBnZXQgc3RvcmFnZUxvY2F0aW9uKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGx1Z2luLnNldHRpbmdzLnN0b3JhZ2VMb2NhdGlvbiB8fCAnJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIHN0b3JhZ2UgZm9sZGVyIGV4aXN0cy5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZW5zdXJlU3RvcmFnZUZvbGRlcigpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5zdG9yYWdlTG9jYXRpb247XHJcbiAgICAgICAgaWYgKCFwYXRoIHx8IHBhdGggPT09ICcvJyB8fCBwYXRoID09PSAnLicgfHwgcGF0aCA9PT0gJy4uJykgcmV0dXJuO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBmb2xkZXIgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGF0aCk7XHJcbiAgICAgICAgICAgIGlmIChmb2xkZXIgaW5zdGFuY2VvZiBURm9sZGVyKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAoZm9sZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdGggY29uZmxpY3Q6IGEgZmlsZSBleGlzdHMgYXQgJyR7cGF0aH0nYCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihwYXRoKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoIVN0cmluZyhlcnJvcikuaW5jbHVkZXMoJ0ZvbGRlciBhbHJlYWR5IGV4aXN0cycpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBQREYgVHJhbnNsYXRvcjogRmFpbGVkIHRvIGNyZWF0ZSBmb2xkZXIgJyR7cGF0aH0nYCwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShgRXJyb3I6IENvdWxkIG5vdCBjcmVhdGUgZm9sZGVyIFwiJHtwYXRofVwiYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kcyB0aGUgdHJhbnNsYXRpb24gZmlsZSBmb3IgYSBQREYgdXNpbmcgdGhlIGNhY2hlZCBtYXAuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGZpbmRUcmFuc2xhdGlvbkZpbGVGb3JQZGYocGRmRmlsZTogVEZpbGUpOiBQcm9taXNlPFRGaWxlIHwgbnVsbD4ge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uUGF0aCA9IHRoaXMucGx1Z2luLnBkZlRvTWRNYXAuZ2V0KHBkZkZpbGUucGF0aCk7XHJcbiAgICAgICAgaWYgKHRyYW5zbGF0aW9uUGF0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRyYW5zbGF0aW9uUGF0aCk7XHJcbiAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHJldHVybiBmaWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgdGhlIHRyYW5zbGF0aW9uIGZpbGUgcGF0aCBiYXNlZCBvbiBzZXR0aW5ncy5cclxuICAgICAqL1xyXG4gICAgZ2V0VHJhbnNsYXRpb25GaWxlUGF0aChwZGZGaWxlOiBURmlsZSk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgYmFzZU5hbWUgPSBwZGZGaWxlLmJhc2VuYW1lO1xyXG4gICAgICAgIGNvbnN0IGRpciA9IHRoaXMuc3RvcmFnZUxvY2F0aW9uIHx8IHBkZkZpbGUucGFyZW50Py5wYXRoIHx8ICcnO1xyXG4gICAgICAgIGNvbnN0IGNsZWFuRGlyID0gZGlyICYmIGRpciAhPT0gJy8nID8gZGlyLnJlcGxhY2UoL1xcLyskLywgJycpIDogJyc7ICAvLyBSZW1vdmUgdHJhaWxpbmcgc2xhc2hlcywgaGFuZGxlIHJvb3RcclxuICAgICAgICByZXR1cm4gbm9ybWFsaXplUGF0aChgJHtjbGVhbkRpciA/IGNsZWFuRGlyICsgJy8nIDogJyd9JHtiYXNlTmFtZX0udHJhbnNsYXRpb25zLm1kYCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIG1hcmtkb3duIGNvbnRlbnQgZm9yIGEgdHJhbnNsYXRpb24gZmlsZSBpbiB0aGUgdjMgZm9ybWF0LlxyXG4gICAgICovXHJcbiAgICBnZW5lcmF0ZU1hcmtkb3duRm9yT3ZlcmxheShzYXZlZE92ZXJsYXk6IFNhdmVkT3ZlcmxheSwgcGRmRmlsZTogVEZpbGUpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IGZyb250bWF0dGVyID0gYC0tLVxyXG5wZGYtc291cmNlOiAnW1ske3BkZkZpbGUucGF0aH1dXSdcclxudGltZXN0YW1wOiAke25ldyBEYXRlKHNhdmVkT3ZlcmxheS50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCl9XHJcbmZvcm1hdC12ZXJzaW9uOiAke1NUT1JBR0VfRk9STUFUX1ZFUlNJT059XHJcbi0tLVxyXG5gO1xyXG5cclxuICAgICAgICBsZXQgbWQgPSBmcm9udG1hdHRlciArIGBcclxuIyBUcmFuc2xhdGlvbnMgZm9yICR7cGRmRmlsZS5iYXNlbmFtZX1cclxuPiBMYXN0IHVwZGF0ZWQ6ICR7bmV3IERhdGUoc2F2ZWRPdmVybGF5LnRpbWVzdGFtcCkudG9Mb2NhbGVTdHJpbmcoKX1cclxuXHJcbmA7XHJcblxyXG4gICAgICAgIGNvbnN0IHBhZ2VOdW1iZXJzID0gT2JqZWN0LmtleXMoc2F2ZWRPdmVybGF5LnBhZ2VPdmVybGF5cylcclxuICAgICAgICAgICAgLm1hcChOdW1iZXIpXHJcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgcGFnZU51bWJlciBvZiBwYWdlTnVtYmVycykge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IHNhdmVkT3ZlcmxheS5wYWdlT3ZlcmxheXNbcGFnZU51bWJlcl07XHJcbiAgICAgICAgICAgIGlmICghaXRlbXM/Lmxlbmd0aCkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBtZCArPSBgXFxuIyMgUGFnZSAke3BhZ2VOdW1iZXJ9XFxuXFxuYDtcclxuICAgICAgICAgICAgbWQgKz0gYFtbJHtwZGZGaWxlLnBhdGh9I3BhZ2U9JHtwYWdlTnVtYmVyfXxcdTIxOTIgVmlldyBwYWdlXV1cXG5cXG5gO1xyXG5cclxuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsVGV4dCA9IChpdGVtLnRleHRDb250ZW50IHx8ICcnKS50cmltKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgbWV0YWRhdGEgd2l0aCBhYmJyZXZpYXRlZCBrZXlzIGZvciBjb21wYWN0bmVzc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGE6IGFueSA9IHtcclxuICAgICAgICAgICAgICAgICAgICByOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGw6IHBhcnNlRmxvYXQoaXRlbS5yZWxhdGl2ZVJlY3QubGVmdC50b0ZpeGVkKDQpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdDogcGFyc2VGbG9hdChpdGVtLnJlbGF0aXZlUmVjdC50b3AudG9GaXhlZCg0KSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHc6IHBhcnNlRmxvYXQoaXRlbS5yZWxhdGl2ZVJlY3Qud2lkdGgudG9GaXhlZCg0KSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGg6IHBhcnNlRmxvYXQoaXRlbS5yZWxhdGl2ZVJlY3QuaGVpZ2h0LnRvRml4ZWQoNCkpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZTogaXRlbS5wYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIG90OiBvcmlnaW5hbFRleHQsIC8vIE9yaWdpbmFsIFRleHRcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGZvbnQgaW5mbyBpZiBhdmFpbGFibGVcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmZvbnRTaXplICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YS5mcyA9IHBhcnNlRmxvYXQoaXRlbS5mb250U2l6ZS50b0ZpeGVkKDIpKTsgLy8gZm9udFNpemVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmZvbnRGYW1pbHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YS5mZiA9IGl0ZW0uZm9udEZhbWlseTsgLy8gZm9udEZhbWlseVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3JpZ2luYWxGb250U2l6ZXMgJiYgaXRlbS5vcmlnaW5hbEZvbnRTaXplcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEub2ZzID0gaXRlbS5vcmlnaW5hbEZvbnRTaXplcy5tYXAoZnMgPT4gcGFyc2VGbG9hdChmcy50b0ZpeGVkKDIpKSk7IC8vIG9yaWdpbmFsRm9udFNpemVzXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFTdHIgPSBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tZW50ID0gYCUlICR7bWV0YWRhdGFTdHJ9ICUlYDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IG5ld2xpbmVzIGluIHRyYW5zbGF0ZWQgdGV4dCB0byA8YnI+IGZvciBtYXJrZG93biByZW5kZXJpbmdcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZWQgPSAoaXRlbS50cmFuc2xhdGVkVGV4dCB8fCAnJykudHJpbSgpLnJlcGxhY2UoL1xcbi9nLCAnPGJyPicpO1xyXG5cclxuICAgICAgICAgICAgICAgIG1kICs9IGAke2NvbW1lbnR9XFxuXFxuYDtcclxuICAgICAgICAgICAgICAgIG1kICs9IGAke3RyYW5zbGF0ZWR9XFxuXFxuYDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZXMgbWV0YWRhdGEgc3RydWN0dXJlIGFnYWluc3Qgc2NoZW1hXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdmFsaWRhdGVNZXRhZGF0YShtZXRhZGF0YTogYW55KTogYm9vbGVhbiB7XHJcbiAgICAgICAgLy8gQ2hlY2sgcmVxdWlyZWQgdG9wLWxldmVsIHByb3BlcnRpZXNcclxuICAgICAgICBpZiAodHlwZW9mIG1ldGFkYXRhICE9PSAnb2JqZWN0JyB8fCAhbWV0YWRhdGEuciB8fCB0eXBlb2YgbWV0YWRhdGEucGFnZSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVmFsaWRhdGUgcmVjdGFuZ2xlIHByb3BlcnRpZXNcclxuICAgICAgICBjb25zdCByZWN0ID0gbWV0YWRhdGEucjtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHR5cGVvZiByZWN0LmwgIT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgICAgIHR5cGVvZiByZWN0LnQgIT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgICAgIHR5cGVvZiByZWN0LncgIT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgICAgIHR5cGVvZiByZWN0LmggIT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgICAgIHJlY3QudyA8PSAwIHx8XHJcbiAgICAgICAgICAgIHJlY3QuaCA8PSAwXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYSBtYXJrZG93biBmaWxlIGludG8gYSBTYXZlZE92ZXJsYXkgb2JqZWN0LlxyXG4gICAgICogU3VwcG9ydHMgdjEsIHYyICh0YWJsZS1iYXNlZCksIGFuZCB2MyAoY29tbWVudC1iYXNlZCkgZm9ybWF0cy5cclxuICAgICAqL1xyXG4gICAgcGFyc2VNYXJrZG93bk92ZXJsYXkoY29udGVudDogc3RyaW5nLCBwZGZGaWxlOiBURmlsZSk6IFNhdmVkT3ZlcmxheSB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IGZyb250bWF0dGVyTWF0Y2ggPSBjb250ZW50Lm1hdGNoKC8tLS1cXG4oW1xcc1xcU10rPylcXG4tLS0vKTtcclxuICAgICAgICBsZXQgZm9ybWF0VmVyc2lvbiA9IDE7XHJcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XHJcblxyXG4gICAgICAgIGlmIChmcm9udG1hdHRlck1hdGNoKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmbURhdGEgPSBwYXJzZVlhbWwoZnJvbnRtYXR0ZXJNYXRjaFsxXSk7XHJcbiAgICAgICAgICAgICAgICAvLyBSZWFkIHZlcnNpb24gZnJvbSBmcm9udG1hdHRlciwgZGVmYXVsdCB0byAxIGlmIG5vdCBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICBmb3JtYXRWZXJzaW9uID0gZm1EYXRhWydmb3JtYXQtdmVyc2lvbiddIHx8IGZtRGF0YS52ZXJzaW9uIHx8IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm1EYXRhLnRpbWVzdGFtcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBuZXcgRGF0ZShmbURhdGEudGltZXN0YW1wKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHQuZ2V0VGltZSgpKSkgdGltZXN0YW1wID0gdC5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQREYgVHJhbnNsYXRvcjogRmFpbGVkIHRvIHBhcnNlIGZyb250bWF0dGVyIFlBTUwnLCBlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBib2R5ID0gY29udGVudC5zdWJzdHJpbmcoZnJvbnRtYXR0ZXJNYXRjaD8uWzBdLmxlbmd0aCB8fCAwKTtcclxuICAgICAgICBjb25zdCBsaW5lcyA9IGJvZHkuc3BsaXQoJ1xcbicpO1xyXG4gICAgICAgIGNvbnN0IHBhZ2VPdmVybGF5czogUmVjb3JkPHN0cmluZywgT3ZlcmxheVBvc2l0aW9uRGF0YVtdPiA9IHt9O1xyXG4gICAgICAgIGxldCBjdXJyZW50UGFnZTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVXNlIGRpZmZlcmVudCBwYXJzaW5nIGxvZ2ljIGJhc2VkIG9uIGZvcm1hdCB2ZXJzaW9uXHJcbiAgICAgICAgaWYgKGZvcm1hdFZlcnNpb24gPj0gMykge1xyXG4gICAgICAgICAgICAvLyBOZXcgVjMgcGFyc2luZyBsb2dpYyAoJSUgY29tbWVudHMpXHJcbiAgICAgICAgICAgIGNvbnN0IFYzX01FVEFfUkVHRVggPSAvXiUlXFxzKihcXHsuKlxcfSlcXHMqJSUvO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gbGluZXNbaV0udHJpbSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VNYXRjaCA9IGxpbmUubWF0Y2goL14jI1xccytQYWdlXFxzKyhcXGQrKS9pKTtcclxuICAgICAgICAgICAgICAgIGlmIChwYWdlTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFnZSA9IHBhZ2VNYXRjaFsxXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhZ2VPdmVybGF5c1tjdXJyZW50UGFnZV0pIHBhZ2VPdmVybGF5c1tjdXJyZW50UGFnZV0gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQYWdlKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YU1hdGNoID0gbGluZS5tYXRjaChWM19NRVRBX1JFR0VYKTtcclxuICAgICAgICAgICAgICAgIGlmIChtZXRhTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IEpTT04ucGFyc2UobWV0YU1hdGNoWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlTWV0YWRhdGEobWV0YWRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVidWdNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQREYgVHJhbnNsYXRvcjogSW52YWxpZCBWMyBtZXRhZGF0YSBzdHJ1Y3R1cmUnLCBtZXRhZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRyYW5zbGF0ZWQgdGV4dCBpcyBvbiB0aGUgbmV4dCBub24tZW1wdHkgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJhbnNsYXRlZFRleHQgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbGluZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lc1tqXS50cmltKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVkVGV4dCA9IGxpbmVzW2pdLnRyaW0oKS5yZXBsYWNlKC88YnI+L2csICdcXG4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gajsgLy8gQWR2YW5jZSBvdXRlciBsb29wIHBhc3QgdGhlIHRyYW5zbGF0ZWQgdGV4dCBsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlEYXRhOiBPdmVybGF5UG9zaXRpb25EYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICcnLCAvLyBTZWxlY3RvciBpcyBkZXByZWNhdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Q29udGVudDogbWV0YWRhdGEub3QgfHwgJycsIC8vIE9yaWdpbmFsIFRleHQgZnJvbSBtZXRhZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVSZWN0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbWV0YWRhdGEuci5sLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogbWV0YWRhdGEuci50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBtZXRhZGF0YS5yLncsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBtZXRhZGF0YS5yLmgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZTogbWV0YWRhdGEucGFnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRUZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IG1ldGFkYXRhLmZzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udEZhbWlseTogbWV0YWRhdGEuZmYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEZvbnRTaXplczogbWV0YWRhdGEub2ZzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlT3ZlcmxheXNbY3VycmVudFBhZ2VdLnB1c2gob3ZlcmxheURhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWJ1Z01vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1BERiBUcmFuc2xhdG9yOiBJbnZhbGlkIFYzIG1ldGFkYXRhIEpTT04nLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciBWMS9WMiAodGFibGUtYmFzZWQpXHJcbiAgICAgICAgICAgIGNvbnN0IE5FV19NRVRBX1JFR0VYID0gLzwhLS1cXHMqUERGX1RSQU5TTEFUT1JfTUVUQURBVEE6KFthLXpBLVowLTkrLz1dKylcXHMqLS0+LztcclxuICAgICAgICAgICAgY29uc3QgT0xEX01FVEFfUkVHRVggPSAvPCEtLVxccyooXFx7Lio/XFx9KVxccyotLT4vO1xyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkID0gbGluZS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlTWF0Y2ggPSB0cmltbWVkLm1hdGNoKC9eIyNcXHMrUGFnZVxccysoXFxkKykvaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFnZU1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhZ2UgPSBwYWdlTWF0Y2hbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZU92ZXJsYXlzW2N1cnJlbnRQYWdlXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UGFnZSB8fCAhdHJpbW1lZC5zdGFydHNXaXRoKCd8JykgfHwgdHJpbW1lZC5pbmNsdWRlcygnfC18JykpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxzID0gdGhpcy5wYXJzZU1hcmtkb3duVGFibGVDZWxscyh0cmltbWVkKTtcclxuICAgICAgICAgICAgICAgIGlmIChjZWxscy5sZW5ndGggIT09IDIpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IFtvcmlnaW5hbENlbGwsIHRyYW5zbGF0ZWRDZWxsXSA9IGNlbGxzO1xyXG4gICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhOiBhbnkgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TWV0YU1hdGNoID0gb3JpZ2luYWxDZWxsLm1hdGNoKE5FV19NRVRBX1JFR0VYKTsgLy8gVjJcclxuICAgICAgICAgICAgICAgIGlmIChuZXdNZXRhTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IEpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShhdG9iKG5ld01ldGFNYXRjaFsxXSkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyAvKiBpZ25vcmUgKi8gfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRNZXRhTWF0Y2ggPSBvcmlnaW5hbENlbGwubWF0Y2goT0xEX01FVEFfUkVHRVgpOyAvLyBWMVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRNZXRhTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gSlNPTi5wYXJzZShvbGRNZXRhTWF0Y2hbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7IC8qIGlnbm9yZSAqLyB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghbWV0YWRhdGEgfHwgIXRoaXMudmFsaWRhdGVNZXRhZGF0YShtZXRhZGF0YSkpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gb3JpZ2luYWxDZWxsLnJlcGxhY2UoTkVXX01FVEFfUkVHRVgsICcnKS5yZXBsYWNlKE9MRF9NRVRBX1JFR0VYLCAnJykucmVwbGFjZSgvXFxcXFxcfC9nLCAnfCcpLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZWRUZXh0ID0gdHJhbnNsYXRlZENlbGwucmVwbGFjZSgvXFxcXFxcfC9nLCAnfCcpLnJlcGxhY2UoL1xcXFxuL2csICdcXG4nKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxheURhdGE6IE92ZXJsYXlQb3NpdGlvbkRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IG1ldGFkYXRhLnNlbCB8fCAnJyxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0Q29udGVudCxcclxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVJlY3Q6IHsgbGVmdDogbWV0YWRhdGEuci5sLCB0b3A6IG1ldGFkYXRhLnIudCwgd2lkdGg6IG1ldGFkYXRhLnIudywgaGVpZ2h0OiBtZXRhZGF0YS5yLmggfSxcclxuICAgICAgICAgICAgICAgICAgICBwYWdlOiBtZXRhZGF0YS5wYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRUZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBtZXRhZGF0YS5mb250U2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBtZXRhZGF0YS5mb250RmFtaWx5LFxyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRm9udFNpemVzOiBtZXRhZGF0YS5vcmlnaW5hbEZvbnRTaXplcyxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBwYWdlT3ZlcmxheXNbY3VycmVudFBhZ2VdLnB1c2gob3ZlcmxheURhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoT2JqZWN0LmtleXMocGFnZU92ZXJsYXlzKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWxlTmFtZTogcGRmRmlsZS5iYXNlbmFtZS5yZXBsYWNlKC9cXC5wZGYkL2ksICcnKSxcclxuICAgICAgICAgICAgZmlsZVBhdGg6IHBkZkZpbGUucGF0aCxcclxuICAgICAgICAgICAgdGltZXN0YW1wLFxyXG4gICAgICAgICAgICBwYWdlT3ZlcmxheXMsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciB0byBwYXJzZSBNYXJrZG93biB0YWJsZSBjZWxscywgaGFuZGxpbmcgZXNjYXBlZCBwaXBlcy4gKEZvciBWMS9WMilcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwYXJzZU1hcmtkb3duVGFibGVDZWxscyhsaW5lOiBzdHJpbmcpOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgY29uc3QgY2VsbHM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSAnJztcclxuICAgICAgICBsZXQgaSA9IDE7IC8vIFN0YXJ0IGFmdGVyIGZpcnN0ICd8J1xyXG4gICAgICAgIHdoaWxlIChpIDwgbGluZS5sZW5ndGggLSAxKSB7IC8vIEVuZCBiZWZvcmUgbGFzdCAnfCdcclxuICAgICAgICAgICAgY29uc3QgY2hhciA9IGxpbmVbaV07XHJcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnXFxcXCcgJiYgbGluZVtpICsgMV0gPT09ICd8Jykge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCArPSAnfCc7XHJcbiAgICAgICAgICAgICAgICBpICs9IDI7IC8vIFNraXAgZXNjYXBlIGFuZCBwaXBlXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gJ3wnKSB7XHJcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKGN1cnJlbnQudHJpbSgpKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSAnJztcclxuICAgICAgICAgICAgICAgIGkrKzsgLy8gU2tpcCB0aGUgcGlwZVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudCArPSBjaGFyO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNlbGxzLnB1c2goY3VycmVudC50cmltKCkpOyAvLyBMYXN0IGNlbGxcclxuICAgICAgICByZXR1cm4gY2VsbHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gLi4uIChUaGUgcmVzdCBvZiB0aGUgY2xhc3MgbWV0aG9kczogc2F2ZUN1cnJlbnRPdmVybGF5LCBsb2FkU2F2ZWRPdmVybGF5Rm9yQ3VycmVudFBhZ2UsIGV0Yy4sIGRvIG5vdCBuZWVkIHRvIGJlIGNoYW5nZWQgYXMgdGhleSByZWx5IG9uIHRoZSBhYnN0cmFjdGlvbiBwcm92aWRlZCBieSB0aGUgZ2VuZXJhdGlvbiBhbmQgcGFyc2luZyBtZXRob2RzLilcclxuICAgIC8qKlxyXG4gICAgICogU2F2ZXMgdGhlIGN1cnJlbnQgb3ZlcmxheSBmb3IgdGhlIGFjdGl2ZSBwYWdlLlxyXG4gICAgICogTWVyZ2VzIHdpdGggZXhpc3RpbmcgZGF0YSBmcm9tIGZpbGUuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHNhdmVDdXJyZW50T3ZlcmxheSgpIHtcclxuICAgICAgICBjb25zdCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcclxuICAgICAgICBpZiAoIWFjdGl2ZUZpbGUgfHwgYWN0aXZlRmlsZS5leHRlbnNpb24gIT09ICdwZGYnKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1BsZWFzZSBvcGVuIGEgUERGIGZpcnN0LicpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50UGFnZU51bWJlciA9IHRoaXMucGx1Z2luLmdldEN1cnJlbnRQYWdlTnVtYmVyKCk7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRQYWdlTnVtYmVyID09PSBudWxsKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IHRleHRMYXllciA9IHRoaXMucGx1Z2luLm92ZXJsYXkuZ2V0Q3VycmVudFBhZ2VUZXh0TGF5ZXIoKTtcclxuICAgICAgICBjb25zdCBvdmVybGF5Q29udGFpbmVyID0gdGV4dExheWVyPy5jbG9zZXN0KCcucGFnZScpPy5xdWVyeVNlbGVjdG9yKCcucGRmLXRleHQtb3ZlcmxheS1jb250YWluZXInKTtcclxuICAgICAgICBpZiAoIXRleHRMYXllciB8fCAhb3ZlcmxheUNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICBuZXcgTm90aWNlKCdObyBvdmVybGF5IHRvIHNhdmUuJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uRGF0YSA9IHRoaXMuZXh0cmFjdFBvc2l0aW9uRGF0YSh0ZXh0TGF5ZXIsIG92ZXJsYXlDb250YWluZXIpO1xyXG4gICAgICAgIGlmIChwb3NpdGlvbkRhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0NvdWxkIG5vdCBleHRyYWN0IG92ZXJsYXkgZGF0YS4nKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBibGFuayBvciBleGlzdGluZyBkYXRhXHJcbiAgICAgICAgbGV0IHNhdmVkT3ZlcmxheTogU2F2ZWRPdmVybGF5ID0ge1xyXG4gICAgICAgICAgICBmaWxlTmFtZTogYWN0aXZlRmlsZS5iYXNlbmFtZS5yZXBsYWNlKC9cXC5wZGYkL2ksICcnKSxcclxuICAgICAgICAgICAgZmlsZVBhdGg6IGFjdGl2ZUZpbGUucGF0aCxcclxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICBwYWdlT3ZlcmxheXM6IHt9LFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uRmlsZSA9IGF3YWl0IHRoaXMuZmluZFRyYW5zbGF0aW9uRmlsZUZvclBkZihhY3RpdmVGaWxlKTtcclxuXHJcbiAgICAgICAgLy8gT25seSBvdmVyd3JpdGUgaWYgcGFyc2Ugc3VjY2VlZHNcclxuICAgICAgICBpZiAodHJhbnNsYXRpb25GaWxlKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZCh0cmFuc2xhdGlvbkZpbGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZU1hcmtkb3duT3ZlcmxheShjb250ZW50LCBhY3RpdmVGaWxlKTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHNhdmVkT3ZlcmxheSA9IHBhcnNlZDtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQREYgVHJhbnNsYXRvcjogRmFpbGVkIHRvIHJlYWQgZXhpc3RpbmcgdHJhbnNsYXRpb24gZmlsZScsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdGhpcyBwYWdlXHJcbiAgICAgICAgc2F2ZWRPdmVybGF5LnRpbWVzdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgc2F2ZWRPdmVybGF5LnBhZ2VPdmVybGF5c1tjdXJyZW50UGFnZU51bWJlcl0gPSBwb3NpdGlvbkRhdGE7XHJcblxyXG4gICAgICAgIGNvbnN0IG1hcmtkb3duQ29udGVudCA9IHRoaXMuZ2VuZXJhdGVNYXJrZG93bkZvck92ZXJsYXkoc2F2ZWRPdmVybGF5LCBhY3RpdmVGaWxlKTtcclxuXHJcbiAgICAgICAgaWYgKHRyYW5zbGF0aW9uRmlsZSkge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkodHJhbnNsYXRpb25GaWxlLCBtYXJrZG93bkNvbnRlbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uUGF0aCA9IHRoaXMuZ2V0VHJhbnNsYXRpb25GaWxlUGF0aChhY3RpdmVGaWxlKTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVTdG9yYWdlRm9sZGVyKCk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZSh0cmFuc2xhdGlvblBhdGgsIG1hcmtkb3duQ29udGVudCk7XHJcbiAgICAgICAgICAgIC8vIFN5bmMgbWFwXHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnBkZlRvTWRNYXAuc2V0KGFjdGl2ZUZpbGUucGF0aCwgdHJhbnNsYXRpb25QYXRoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLmRlYnVnTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFBERiBUcmFuc2xhdG9yOiBDcmVhdGVkIHRyYW5zbGF0aW9uIGZpbGUgYXQgJHt0cmFuc2xhdGlvblBhdGh9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5ldyBOb3RpY2UoYE92ZXJsYXkgc2F2ZWQgZm9yICR7YWN0aXZlRmlsZS5iYXNlbmFtZX0gcGFnZSAke2N1cnJlbnRQYWdlTnVtYmVyfWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgdGhlIHNhdmVkIG92ZXJsYXkgZm9yIHRoZSBjdXJyZW50IHBhZ2UuXHJcbiAgICAgKiBJZiBmb3JjZVJlbG9hZCBpcyB0cnVlLCByZW1vdmVzIGFueSBleGlzdGluZyBvdmVybGF5IGJlZm9yZSBsb2FkaW5nLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBsb2FkU2F2ZWRPdmVybGF5Rm9yQ3VycmVudFBhZ2UoZmlsZTogVEZpbGUsIGZvcmNlUmVsb2FkOiBib29sZWFuID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50UGFnZU51bWJlciA9IHRoaXMucGx1Z2luLmdldEN1cnJlbnRQYWdlTnVtYmVyKCk7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRQYWdlTnVtYmVyID09PSBudWxsKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IHBhZ2VFbGVtZW50ID0gdGhpcy5wbHVnaW4ub3ZlcmxheS5nZXRDdXJyZW50UGFnZUVsZW1lbnQoKTtcclxuICAgICAgICBpZiAoIXBhZ2VFbGVtZW50KSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIElmIGZvcmNlUmVsb2FkLCBjbGVhciBleGlzdGluZyBvdmVybGF5IHRvIGVuc3VyZSByZS1yZW5kZXIgYXQgY3VycmVudCB6b29tXHJcbiAgICAgICAgaWYgKGZvcmNlUmVsb2FkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nT3ZlcmxheSA9IHBhZ2VFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wZGYtdGV4dC1vdmVybGF5LWNvbnRhaW5lcicpO1xyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdPdmVybGF5KSB7XHJcbiAgICAgICAgICAgICAgICBleGlzdGluZ092ZXJsYXkucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFx1MjcwNSBJbnN0ZWFkIG9mIHVzaW5nIGNhY2hlZCBsYXN0TG9hZGVkLCBjaGVjayBhY3R1YWwgRE9NXHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdPdmVybGF5ID0gcGFnZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLnBkZi10ZXh0LW92ZXJsYXktY29udGFpbmVyJyk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nT3ZlcmxheSAmJiAhZm9yY2VSZWxvYWQpIHtcclxuICAgICAgICAgICAgLy8gT3ZlcmxheSBhbHJlYWR5IHJlbmRlcmVkIFx1MjAxNCBubyBuZWVkIHRvIGxvYWQgYWdhaW5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHJldmVudCBjb25jdXJyZW50IGxvYWRzIHBlciBmaWxlXHJcbiAgICAgICAgY29uc3QgZmlsZUtleSA9IGZpbGUucGF0aDtcclxuICAgICAgICBpZiAodGhpcy5sb2FkaW5nUHJvbWlzZXMuaGFzKGZpbGVLZXkpKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubG9hZGluZ1Byb21pc2VzLmdldChmaWxlS2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbG9hZGVyID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc2xhdGlvbkZpbGUgPSBhd2FpdCB0aGlzLmZpbmRUcmFuc2xhdGlvbkZpbGVGb3JQZGYoZmlsZSk7XHJcbiAgICAgICAgICAgIGlmICghdHJhbnNsYXRpb25GaWxlKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQodHJhbnNsYXRpb25GaWxlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNhdmVkT3ZlcmxheSA9IHRoaXMucGFyc2VNYXJrZG93bk92ZXJsYXkoY29udGVudCwgZmlsZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNhdmVkT3ZlcmxheSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VLZXkgPSBjdXJyZW50UGFnZU51bWJlci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFnZURhdGEgPSBzYXZlZE92ZXJsYXkucGFnZU92ZXJsYXlzW3BhZ2VLZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhZ2VEYXRhKSB8fCBwYWdlRGF0YS5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0TGF5ZXIgPSBhd2FpdCB0aGlzLnBsdWdpbi5vdmVybGF5LndhaXRGb3JQZGZUZXh0TGF5ZXIoY3VycmVudFBhZ2VOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0ZXh0TGF5ZXIpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5vdmVybGF5LnJlbmRlclNhdmVkT3ZlcmxheShwYWdlRGF0YSwgY3VycmVudFBhZ2VOdW1iZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWJ1Z01vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUERGIFRyYW5zbGF0b3I6IExvYWRlZCBvdmVybGF5IGZvciBwYWdlICR7Y3VycmVudFBhZ2VOdW1iZXJ9ICgke3BhZ2VEYXRhLmxlbmd0aH0gaXRlbXMpYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUERGIFRyYW5zbGF0b3I6IEZhaWxlZCB0byBsb2FkIHNhdmVkIG92ZXJsYXknLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBwcm9taXNlID0gbG9hZGVyKCk7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nUHJvbWlzZXMuc2V0KGZpbGVLZXksIHByb21pc2UpO1xyXG4gICAgICAgIGF3YWl0IHByb21pc2U7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nUHJvbWlzZXMuZGVsZXRlKGZpbGVLZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgb3ZlcmxheSBmb3IgdGhlIGN1cnJlbnQgcGFnZS5cclxuICAgICAqIElmIGl0J3MgdGhlIGxhc3QgcGFnZSwgZGVsZXRlcyB0aGUgd2hvbGUgZmlsZS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZGVsZXRlQ3VycmVudE92ZXJsYXkoKSB7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlRmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcbiAgICAgICAgaWYgKCFhY3RpdmVGaWxlIHx8IGFjdGl2ZUZpbGUuZXh0ZW5zaW9uICE9PSAncGRmJykge1xyXG4gICAgICAgICAgICBuZXcgTm90aWNlKCdQbGVhc2Ugb3BlbiBhIFBERiBmaWxlIGZpcnN0LicpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50UGFnZU51bWJlciA9IHRoaXMucGx1Z2luLmdldEN1cnJlbnRQYWdlTnVtYmVyKCk7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRQYWdlTnVtYmVyID09PSBudWxsKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uRmlsZSA9IGF3YWl0IHRoaXMuZmluZFRyYW5zbGF0aW9uRmlsZUZvclBkZihhY3RpdmVGaWxlKTtcclxuICAgICAgICBpZiAoIXRyYW5zbGF0aW9uRmlsZSkge1xyXG4gICAgICAgICAgICBuZXcgTm90aWNlKCdObyB0cmFuc2xhdGlvbiBmaWxlIGZvdW5kIGZvciB0aGlzIFBERi4nKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQodHJhbnNsYXRpb25GaWxlKTtcclxuICAgICAgICAgICAgY29uc3Qgc2F2ZWRPdmVybGF5ID0gdGhpcy5wYXJzZU1hcmtkb3duT3ZlcmxheShjb250ZW50LCBhY3RpdmVGaWxlKTtcclxuICAgICAgICAgICAgaWYgKCFzYXZlZE92ZXJsYXkpIHtcclxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0NvdWxkIG5vdCBwYXJzZSB0cmFuc2xhdGlvbiBkYXRhLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwYWdlS2V5ID0gY3VycmVudFBhZ2VOdW1iZXIudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYgKCFzYXZlZE92ZXJsYXkucGFnZU92ZXJsYXlzW3BhZ2VLZXldKSB7XHJcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBObyBvdmVybGF5IHNhdmVkIGZvciBwYWdlICR7Y3VycmVudFBhZ2VOdW1iZXJ9LmApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEZWxldGUgdGhpcyBwYWdlXHJcbiAgICAgICAgICAgIGRlbGV0ZSBzYXZlZE92ZXJsYXkucGFnZU92ZXJsYXlzW3BhZ2VLZXldO1xyXG5cclxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNhdmVkT3ZlcmxheS5wYWdlT3ZlcmxheXMpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQudHJhc2godHJhbnNsYXRpb25GaWxlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnBkZlRvTWRNYXAuZGVsZXRlKGFjdGl2ZUZpbGUucGF0aCk7XHJcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBUcmFuc2xhdGlvbiBmaWxlIGRlbGV0ZWQgZm9yICR7YWN0aXZlRmlsZS5iYXNlbmFtZX1gKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtkb3duQ29udGVudCA9IHRoaXMuZ2VuZXJhdGVNYXJrZG93bkZvck92ZXJsYXkoc2F2ZWRPdmVybGF5LCBhY3RpdmVGaWxlKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeSh0cmFuc2xhdGlvbkZpbGUsIG1hcmtkb3duQ29udGVudCk7XHJcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBPdmVybGF5IGRlbGV0ZWQgZm9yIHBhZ2UgJHtjdXJyZW50UGFnZU51bWJlcn1gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uY2xlYXJBbGxPdmVybGF5cygpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BERiBUcmFuc2xhdG9yOiBGYWlsZWQgdG8gZGVsZXRlIG92ZXJsYXknLCBlcnJvcik7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0Vycm9yIGRlbGV0aW5nIG92ZXJsYXkuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXh0cmFjdHMgcG9zaXRpb25pbmcgYW5kIGNvbnRlbnQgZGF0YSBmcm9tIHJlbmRlcmVkIG92ZXJsYXkgZWxlbWVudHMuXHJcbiAgICAgKiBVc2VzIHRoZSBjbG9zZXN0IC5wYWdlW2RhdGEtcGFnZS1udW1iZXJdIHRvIGRldGVybWluZSB0aGUgcGFnZSBudW1iZXIuXHJcbiAgICAgKi9cclxuICAgIGV4dHJhY3RQb3NpdGlvbkRhdGEodGV4dExheWVyOiBIVE1MRWxlbWVudCwgb3ZlcmxheUNvbnRhaW5lcjogRWxlbWVudCk6IE92ZXJsYXlQb3NpdGlvbkRhdGFbXSB7XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb25EYXRhOiBPdmVybGF5UG9zaXRpb25EYXRhW10gPSBbXTtcclxuICAgICAgICBjb25zdCBvdmVybGF5cyA9IG92ZXJsYXlDb250YWluZXIucXVlcnlTZWxlY3RvckFsbDxIVE1MRWxlbWVudD4oJy5wZGYtdGV4dC1vdmVybGF5LXJlZmxvdycpO1xyXG4gICAgICAgIGNvbnN0IHRleHRMYXllclJlY3QgPSB0ZXh0TGF5ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgICAgIC8vIEdldCBwYWdlIG51bWJlciBmcm9tIHRoZSBjbG9zZXN0IC5wYWdlIGVsZW1lbnRcclxuICAgICAgICBjb25zdCBwYWdlRWxlbWVudCA9IG92ZXJsYXlDb250YWluZXIuY2xvc2VzdCgnLnBhZ2VbZGF0YS1wYWdlLW51bWJlcl0nKSBhcyBIVE1MRWxlbWVudCB8IG51bGw7XHJcbiAgICAgICAgY29uc3QgcGFnZU51bWJlciA9IHBhZ2VFbGVtZW50ID8gcGFyc2VJbnQocGFnZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBhZ2UtbnVtYmVyJykgfHwgJzAnLCAxMCkgOiAwO1xyXG5cclxuICAgICAgICBpZiAodGV4dExheWVyUmVjdC53aWR0aCA9PT0gMCB8fCB0ZXh0TGF5ZXJSZWN0LmhlaWdodCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQREYgVHJhbnNsYXRvcjogVGV4dCBsYXllciBoYXMgemVybyBkaW1lbnNpb25zJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEdldCBzY2FsZSBmb3Igbm9ybWFsaXphdGlvbiAoem9vbS1pbmRlcGVuZGVudCByZWxhdGl2ZSBmb250cylcclxuICAgICAgICBjb25zdCBwZGZWaWV3ZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGRmVmlld2VyLCAjdmlld2VyJykgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgY29uc3Qgc2F2ZVNjYWxlID0gcGFyc2VGbG9hdChwZGZWaWV3ZXI/LnN0eWxlLmdldFByb3BlcnR5VmFsdWUoJy0tc2NhbGUtZmFjdG9yJykgfHwgJzEnKTtcclxuICAgICAgICBpZiAoaXNOYU4oc2F2ZVNjYWxlKSB8fCBzYXZlU2NhbGUgPD0gMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BERiBUcmFuc2xhdG9yOiBJbnZhbGlkIHNhdmVTY2FsZSwgdXNpbmcgMS4wJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvdmVybGF5cy5mb3JFYWNoKG92ZXJsYXkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFRleHQgPSBvdmVybGF5LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10ZXh0JykgfHwgJyc7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZWREaXYgPSBvdmVybGF5LnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVkVGV4dCA9IHRyYW5zbGF0ZWREaXYgPyB0cmFuc2xhdGVkRGl2LmlubmVySFRNTCA6IChvdmVybGF5LnRleHRDb250ZW50IHx8ICcnKTtcclxuICAgICAgICAgICAgY29uc3QgcmVjdCA9IG92ZXJsYXkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZVJlY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiAocmVjdC5sZWZ0IC0gdGV4dExheWVyUmVjdC5sZWZ0KSAvIHRleHRMYXllclJlY3Qud2lkdGgsXHJcbiAgICAgICAgICAgICAgICB0b3A6IChyZWN0LnRvcCAtIHRleHRMYXllclJlY3QudG9wKSAvIHRleHRMYXllclJlY3QuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGggLyB0ZXh0TGF5ZXJSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCAvIHRleHRMYXllclJlY3QuaGVpZ2h0LFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIGF0dHJpYnV0ZXMgKHNldCBpbiBvdmVybGF5LnRzIGNyZWF0ZVJlZmxvd092ZXJsYXkpXHJcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplc1N0ciA9IG92ZXJsYXkuZ2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLWZvbnQtc2l6ZXMnKSB8fCAnJztcclxuICAgICAgICAgICAgbGV0IGFic29sdXRlRm9udFNpemVzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoZm9udFNpemVzU3RyKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFic29sdXRlRm9udFNpemVzID0gSlNPTi5wYXJzZShmb250U2l6ZXNTdHIpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUERGIFRyYW5zbGF0b3I6IEZhaWxlZCB0byBwYXJzZSBmb250IHNpemVzIGZyb20gYXR0cmlidXRlJywgZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byByZWxhdGl2ZSAoZGl2aWRlIGJ5IHNhdmVTY2FsZSlcclxuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVGb250U2l6ZXMgPSBhYnNvbHV0ZUZvbnRTaXplcy5sZW5ndGggPiAwICYmIHNhdmVTY2FsZSA+IDBcclxuICAgICAgICAgICAgICAgID8gYWJzb2x1dGVGb250U2l6ZXMubWFwKGZzID0+IGZzIC8gc2F2ZVNjYWxlKVxyXG4gICAgICAgICAgICAgICAgOiBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgYXZnIHJlbGF0aXZlIGZvciBmb250U2l6ZVxyXG4gICAgICAgICAgICBjb25zdCBhdmdSZWxhdGl2ZSA9IHJlbGF0aXZlRm9udFNpemVzLmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgICAgID8gcmVsYXRpdmVGb250U2l6ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyByZWxhdGl2ZUZvbnRTaXplcy5sZW5ndGhcclxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZm9udEZhbWlseSA9IG92ZXJsYXkuZ2V0QXR0cmlidXRlKCdkYXRhLWZvbnQtZmFtaWx5JykgfHwgb3ZlcmxheS5zdHlsZS5mb250RmFtaWx5IHx8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlEYXRhOiBPdmVybGF5UG9zaXRpb25EYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICcnLFxyXG4gICAgICAgICAgICAgICAgdGV4dENvbnRlbnQ6IG9yaWdpbmFsVGV4dCxcclxuICAgICAgICAgICAgICAgIHJlbGF0aXZlUmVjdCxcclxuICAgICAgICAgICAgICAgIHBhZ2U6IHBhZ2VOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVkVGV4dCxcclxuICAgICAgICAgICAgICAgIC8vIFNldCByZWxhdGl2ZSBmb250IGRhdGFcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiBhdmdSZWxhdGl2ZSxcclxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHksXHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEZvbnRTaXplczogcmVsYXRpdmVGb250U2l6ZXMsXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBwb3NpdGlvbkRhdGEucHVzaChvdmVybGF5RGF0YSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBwb3NpdGlvbkRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBIZWxwZXJzIGZvciByZS10cmFuc2xhdGlvbiBtb2RhbCAocmVhZC93cml0ZSBjb252ZW5pZW5jZSlcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgdGhlIHNhdmVkIG92ZXJsYXkgc3RydWN0dXJlIGZvciBhIGdpdmVuIFBERiBmaWxlLlxyXG4gICAgICogUmV0dXJucyBudWxsIGlmIG5vIGZpbGUgb3Igbm8gb3ZlcmxheSBkYXRhLlxyXG4gICAgICovXHJcbiAgICBhc3luYyByZWFkU2F2ZWRPdmVybGF5Rm9yRmlsZShwZGZGaWxlOiBURmlsZSk6IFByb21pc2U8eyBtZEZpbGU6IFRGaWxlOyBvdmVybGF5OiBTYXZlZE92ZXJsYXkgfSB8IG51bGw+IHtcclxuICAgICAgICBjb25zdCBtZEZpbGUgPSBhd2FpdCB0aGlzLmZpbmRUcmFuc2xhdGlvbkZpbGVGb3JQZGYocGRmRmlsZSk7XHJcbiAgICAgICAgaWYgKCFtZEZpbGUpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChtZEZpbGUpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlTWFya2Rvd25PdmVybGF5KGNvbnRlbnQsIHBkZkZpbGUpO1xyXG4gICAgICAgICAgICBpZiAoIXBhcnNlZCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiB7IG1kRmlsZSwgb3ZlcmxheTogcGFyc2VkIH07XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BERiBUcmFuc2xhdG9yOiBGYWlsZWQgdG8gcmVhZCBzYXZlZCBvdmVybGF5IGZvciBmaWxlJywgcGRmRmlsZS5wYXRoLCBlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgU2F2ZWRPdmVybGF5IHN0cnVjdHVyZSBiYWNrIHRvIGl0cyAudHJhbnNsYXRpb25zLm1kLlxyXG4gICAgICogRW5zdXJlcyB0aW1lc3RhbXAgaXMgdXBkYXRlZCBhbmQgbWFwIHN0YXlzIGluIHN5bmMgaWYgZmlsZSBpcyBjcmVhdGVkLlxyXG4gICAgICovXHJcbiAgICBhc3luYyB3cml0ZVNhdmVkT3ZlcmxheUZvckZpbGUocGRmRmlsZTogVEZpbGUsIHNhdmVkT3ZlcmxheTogU2F2ZWRPdmVybGF5KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCB0aGlzLmZpbmRUcmFuc2xhdGlvbkZpbGVGb3JQZGYocGRmRmlsZSk7XHJcbiAgICAgICAgY29uc3QgbWFya2Rvd25Db250ZW50ID0gdGhpcy5nZW5lcmF0ZU1hcmtkb3duRm9yT3ZlcmxheShzYXZlZE92ZXJsYXksIHBkZkZpbGUpO1xyXG5cclxuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGV4aXN0aW5nLCBtYXJrZG93bkNvbnRlbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uUGF0aCA9IHRoaXMuZ2V0VHJhbnNsYXRpb25GaWxlUGF0aChwZGZGaWxlKTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVTdG9yYWdlRm9sZGVyKCk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZSh0cmFuc2xhdGlvblBhdGgsIG1hcmtkb3duQ29udGVudCk7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnBkZlRvTWRNYXAuc2V0KHBkZkZpbGUucGF0aCwgdHJhbnNsYXRpb25QYXRoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLmRlYnVnTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFBERiBUcmFuc2xhdG9yOiBDcmVhdGVkIHRyYW5zbGF0aW9uIGZpbGUgYXQgJHt0cmFuc2xhdGlvblBhdGh9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIG9uZSBvciBtb3JlIHBhZ2VzIGluIGEgU2F2ZWRPdmVybGF5IGFuZCB3cml0ZXMgdG8gZGlzay5cclxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbm93IGNvcnJlY3RlZCB0byBwcmV2ZW50IHJhY2UgY29uZGl0aW9ucy5cclxuICAgICAqIHBhZ2VzIGlzIGEgbWFwIHBhZ2VOdW1iZXIgLT4gYXJyYXkgb2YgT3ZlcmxheVBvc2l0aW9uRGF0YS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgdXBkYXRlUGFnZU92ZXJsYXlzQW5kV3JpdGUocGRmRmlsZTogVEZpbGUsIHBhZ2VzOiBSZWNvcmQ8bnVtYmVyLCBPdmVybGF5UG9zaXRpb25EYXRhW10+KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgbG9ja0tleSA9IHBkZkZpbGUucGF0aDtcclxuXHJcbiAgICAgICAgLy8gVGhlIGNvcmUgbG9naWMgb2YgcmVhZGluZywgdXBkYXRpbmcsIGFuZCB3cml0aW5nIHRoZSBmaWxlLlxyXG4gICAgICAgIGNvbnN0IHdyaXRlciA9IGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgICAgICAgICAgLy8gLS0tIFNUQVJUIE9GIENPUlJFQ1RFRCBMT0dJQyAtLS1cclxuXHJcbiAgICAgICAgICAgIC8vIE1vcmUgcm9idXN0OiBEaXJlY3RseSBjaGVjayB0aGUgZmlsZXN5c3RlbSBmb3IgdGhlIGZpbGUncyBleGlzdGVuY2VcclxuICAgICAgICAgICAgLy8gYXQgdGhlIHRpbWUgb2Ygd3JpdGluZy4gVGhpcyBpcyB0aGUga2V5IHRvIGZpeGluZyB0aGUgcmFjZSBjb25kaXRpb24uXHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uUGF0aCA9IHRoaXMuZ2V0VHJhbnNsYXRpb25GaWxlUGF0aChwZGZGaWxlKTtcclxuICAgICAgICAgICAgY29uc3QgYWJzdHJhY3RGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRyYW5zbGF0aW9uUGF0aCk7XHJcbiAgICAgICAgICAgIGxldCBtZEZpbGU6IFRGaWxlIHwgbnVsbCA9IChhYnN0cmFjdEZpbGUgaW5zdGFuY2VvZiBURmlsZSkgPyBhYnN0cmFjdEZpbGUgOiBudWxsO1xyXG5cclxuICAgICAgICAgICAgbGV0IHNhdmVkT3ZlcmxheTogU2F2ZWRPdmVybGF5IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBpZiAobWRGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNT0RJRlkgUEFUSDogRmlsZSBleGlzdHMsIHNvIHdlIHJlYWQgaXQuXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKG1kRmlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2F2ZWRPdmVybGF5ID0gdGhpcy5wYXJzZU1hcmtkb3duT3ZlcmxheShjb250ZW50LCBwZGZGaWxlKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5sb2dEZWJ1ZyhcIkZhaWxlZCB0byByZWFkIG9yIHBhcnNlIGV4aXN0aW5nIHRyYW5zbGF0aW9uIGZpbGUsIHdpbGwgb3ZlcndyaXRlLlwiLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIGEgYmxhbmsgb3ZlcmxheSBvYmplY3QgaWYgcGFyc2luZyBmYWlscy5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgZmlsZSBkaWRuJ3QgZXhpc3Qgb3IgZmFpbGVkIHRvIHBhcnNlLCBjcmVhdGUgYSBuZXcgb3ZlcmxheSBvYmplY3QuXHJcbiAgICAgICAgICAgIGlmICghc2F2ZWRPdmVybGF5KSB7XHJcbiAgICAgICAgICAgICAgICBzYXZlZE92ZXJsYXkgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IHBkZkZpbGUuYmFzZW5hbWUucmVwbGFjZSgvXFwucGRmJC9pLCAnJyksXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhdGg6IHBkZkZpbGUucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZU92ZXJsYXlzOiB7fSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE1lcmdlIHRoZSBuZXcgcGFnZSBkYXRhIGludG8gdGhlIG92ZXJsYXlcclxuICAgICAgICAgICAgZm9yIChjb25zdCBbcGFnZVN0ciwgaXRlbXNdIG9mIE9iamVjdC5lbnRyaWVzKHBhZ2VzKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IE51bWJlcihwYWdlU3RyKTtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2F2ZWRPdmVybGF5LnBhZ2VPdmVybGF5c1twXSA9IGl0ZW1zO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2F2ZWRPdmVybGF5LnBhZ2VPdmVybGF5c1twXTsgLy8gSGFuZGxlIGRlbGV0aW9uIG9mIGEgcGFnZSdzIG92ZXJsYXlzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2F2ZWRPdmVybGF5LnRpbWVzdGFtcCA9IERhdGUubm93KCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtZCA9IHRoaXMuZ2VuZXJhdGVNYXJrZG93bkZvck92ZXJsYXkoc2F2ZWRPdmVybGF5LCBwZGZGaWxlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtZEZpbGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIEZpbGUgZXhpc3RzLCBzbyBtb2RpZnkgaXQuXHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkobWRGaWxlLCBtZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDUkVBVEUgUEFUSDogRmlsZSBkb2VzIG5vdCBleGlzdCwgc28gY3JlYXRlIGl0LlxyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVTdG9yYWdlRm9sZGVyKCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUodHJhbnNsYXRpb25QYXRoLCBtZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1hcCB1cGRhdGUgaXMgbm93IHNhZmVseSBpbnNpZGUgdGhlIHNlcXVlbnRpYWwgcXVldWVcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnBkZlRvTWRNYXAuc2V0KHBkZkZpbGUucGF0aCwgdHJhbnNsYXRpb25QYXRoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gLS0tIEVORCBPRiBDT1JSRUNURUQgTE9HSUMgLS0tXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gUHJvbWlzZS1iYXNlZCBsb2NraW5nIG1lY2hhbmlzbSB0byBzZXJpYWxpemUgd3JpdGUgb3BlcmF0aW9ucyBmb3IgdGhlIHNhbWUgZmlsZVxyXG4gICAgICAgIGNvbnN0IHBlbmRpbmdQcm9taXNlID0gdGhpcy53cml0aW5nUHJvbWlzZXMuZ2V0KGxvY2tLZXkpIHx8IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIGNvbnN0IG5ld1Byb21pc2UgPSBwZW5kaW5nUHJvbWlzZS50aGVuKCgpID0+IHdyaXRlcigpKS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiBDbGVhbiB1cCB0aGUgbWFwIG9uY2UgdGhlIG9wZXJhdGlvbiBpcyBkb25lLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGNoZWNrIGVuc3VyZXMgd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IGRlbGV0ZSBhIG5ld2VyIHByb21pc2VcclxuICAgICAgICAgICAgLy8gaWYgb3BlcmF0aW9ucyB3ZXJlIGNoYWluZWQgdmVyeSBxdWlja2x5LlxyXG4gICAgICAgICAgICBpZiAodGhpcy53cml0aW5nUHJvbWlzZXMuZ2V0KGxvY2tLZXkpID09PSBuZXdQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRpbmdQcm9taXNlcy5kZWxldGUobG9ja0tleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy53cml0aW5nUHJvbWlzZXMuc2V0KGxvY2tLZXksIG5ld1Byb21pc2UpO1xyXG4gICAgICAgIGF3YWl0IG5ld1Byb21pc2U7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5zdXJlIGFuIGV4aXN0aW5nIHRyYW5zbGF0aW9uIG5vdGUncyBwZGYtc291cmNlIHdpa2lsaW5rIHBvaW50cyB0byB0aGUgZ2l2ZW4gUERGLlxyXG4gICAgICogUmVwYWlycyBzdGFsZSBsaW5rcyBhZnRlciByZW5hbWVzIG9yIG1vdmVzLiBLZWVwcyB0aGUgb3JpZ2luYWwgc2luZ2xlLXF1b3RlZCB3aWtpbGluayBmb3JtYXQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGVuc3VyZVBkZlNvdXJjZUxpbmtQb2ludHNUbyhmaWxlTWQ6IFRGaWxlLCBwZGZGaWxlOiBURmlsZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZU1kKTtcclxuICAgICAgICBjb25zdCBmbSA9IGNhY2hlPy5mcm9udG1hdHRlcjtcclxuICAgICAgICBpZiAoIWZtKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IHJhdyA9IGZtWydwZGYtc291cmNlJ107XHJcbiAgICAgICAgaWYgKHR5cGVvZiByYXcgIT09ICdzdHJpbmcnKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIEV4dHJhY3QgbGluayBwYXRoIGZyb20gJ1tbbGlua11dJyBvciBbW2xpbmtdXTsgaGFuZGxlIGFsaWFzZXMgW1twYXRofGFsaWFzXV1cclxuICAgICAgICBjb25zdCBzaW5nbGVRdW90ZWQgPSByYXcubWF0Y2goL14nXFxbXFxbKC4rPylcXF1cXF0nJC8pO1xyXG4gICAgICAgIGNvbnN0IGJhcmUgPSAhc2luZ2xlUXVvdGVkICYmIHJhdy5tYXRjaCgvXlxcW1xcWyguKz8pXFxdXFxdJC8pO1xyXG4gICAgICAgIGNvbnN0IGxpbmtSYXcgPSBzaW5nbGVRdW90ZWQgPyBzaW5nbGVRdW90ZWRbMV0gOiAoYmFyZSA/IGJhcmVbMV0gOiByYXcudHJpbSgpKTtcclxuICAgICAgICBjb25zdCBsaW5rUGF0aCA9IGxpbmtSYXcuc3BsaXQoJ3wnKVswXS50cmltKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChsaW5rUGF0aCwgZmlsZU1kLnBhdGgpO1xyXG4gICAgICAgIGlmIChyZXNvbHZlZCAmJiByZXNvbHZlZC5wYXRoID09PSBwZGZGaWxlLnBhdGgpIHtcclxuICAgICAgICAgICAgLy8gQWxyZWFkeSBjb3JyZWN0XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEJ1aWxkIHJlcGxhY2VtZW50IHN0cmluZyBrZWVwaW5nIHNpbmdsZS1xdW90ZWQgd2lraWxpbmtcclxuICAgICAgICBjb25zdCBuZXdUYXJnZXQgPSBgW1ske3BkZkZpbGUucGF0aH1dXWA7XHJcblxyXG4gICAgICAgIC8vIFJlYWQsIHJlcGxhY2UgZnJvbnRtYXR0ZXIgbGluZSwgd3JpdGUgYmFja1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGZpbGVNZCk7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZCA9IGNvbnRlbnQucmVwbGFjZShcclxuICAgICAgICAgICAgL14tLS1bXFxzXFxTXSo/LS0tLyxcclxuICAgICAgICAgICAgKGZtQmxvY2spID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICgvXnBkZi1zb3VyY2U6XFxzKi9tLnRlc3QoZm1CbG9jaykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm1CbG9jay5yZXBsYWNlKC9eKHBkZi1zb3VyY2U6XFxzKikuKi9tLCBgJDEnW1ske3BkZkZpbGUucGF0aH1dXSdgKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0IGlmIHNvbWVob3cgbWlzc2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gZm1CbG9jay5zcGxpdCgnXFxuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKDEsIDAsIGBwZGYtc291cmNlOiAnW1ske3BkZkZpbGUucGF0aH1dXSdgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydHMuam9pbignXFxuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAodXBkYXRlZCAhPT0gY29udGVudCkge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoZmlsZU1kLCB1cGRhdGVkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCAiLy8gb3ZlcmxheS50c1xyXG4vLyBNYWluIE92ZXJsYXkgTWFuYWdlbWVudCBhbmQgQ29vcmRpbmF0aW9uIExvZ2ljXHJcblxyXG5pbXBvcnQgeyBNZW51LCBOb3RpY2UsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgdHlwZSBPcGVuUm91dGVyVHJhbnNsYXRvclBsdWdpbiBmcm9tICcuL21haW4nO1xyXG5pbXBvcnQgdHlwZSB7IE92ZXJsYXlQb3NpdGlvbkRhdGEsIFRyYW5zbGF0aW9uVW5pdCwgU2F2ZWRPdmVybGF5IH0gZnJvbSAnLi90eXBlcyc7XHJcbmltcG9ydCB7IFJldHJhbnNsYXRlVXNpbmdPdmVybGF5c01vZGFsIH0gZnJvbSAnLi9tb2RhbC1yZXRyYW5zbGF0ZSc7XHJcbmltcG9ydCB7IE92ZXJsYXlVSVJlbmRlcmVyIH0gZnJvbSAnLi9vdmVybGF5LXVpJzsgLy8gSW1wb3J0IHRoZSBuZXcgVUkgcmVuZGVyZXJcclxuXHJcbi8vIENvbnN0YW50c1xyXG5jb25zdCBPVkVSTEFZX1dBSVRfVElNRU9VVCA9IDUwMDA7XHJcbmNvbnN0IE9WRVJMQVlfQ0hFQ0tfSU5URVJWQUwgPSAxMDA7XHJcbmNvbnN0IFJFVFJZX0RFTEFZID0gNTA7XHJcbmNvbnN0IE1BWF9ESU1FTlNJT05fUkVUUklFUyA9IDUwO1xyXG5jb25zdCBFWFRSQUNUX1JFVFJZX0lOVEVSVkFMID0gMTAwO1xyXG5jb25zdCBFWFRSQUNUX01BWF9SRVRSSUVTID0gMjA7XHJcbmNvbnN0IE9WRVJMQVlfUkVMT0FEX0RFTEFZID0gMTAwO1xyXG5jb25zdCBaT09NX0NIQU5HRV9ERUxBWSA9IDE1MDtcclxuY29uc3QgREVCT1VOQ0VfREVMQVkgPSA1MDtcclxuY29uc3QgQ0FDSEVfVFRMID0gMTAwOyAvLyBtcyBmb3IgbWVtb2l6YXRpb25cclxuLy8gY29uc3QgTElORV9IRUlHSFRfTUlOID0gMC44OyAvLyBNb3ZlZCB0byBvdmVybGF5LXVpLnRzXHJcbi8vIGNvbnN0IExJTkVfSEVJR0hUX01BWCA9IDIuMDsgLy8gTW92ZWQgdG8gb3ZlcmxheS11aS50c1xyXG4vLyBjb25zdCBMSU5FX0hFSUdIVF9TVEVQID0gMC4xOyAvLyBNb3ZlZCB0byBvdmVybGF5LXVpLnRzXHJcbmNvbnN0IFpPT01fUkVQT1NJVElPTl9ERUJPVU5DRSA9IDIwMDsgLy8gbXMgdG8gZGVib3VuY2UgY29udGludW91cyB6b29tXHJcbmNvbnN0IFpPT01fRElNX1NUQUJMRV9XQUlUID0gMzAwOyAvLyBtcyB0byB3YWl0IGZvciBQREYuanMgdG8gc2V0dGxlIHpvb21cclxuY29uc3QgU0NST0xMX1RIUk9UVExFX0RFTEFZID0gMTUwOyAvLyBtcyB0byB0aHJvdHRsZSBzY3JvbGwgY2hlY2tzXHJcbmNvbnN0IFNDUk9MTF9TRVRUTEVfREVMQVkgPSAyMDA7IC8vIG1zIHRvIHdhaXQgYWZ0ZXIgc2Nyb2xsaW5nIHN0b3BzXHJcbmNvbnN0IFFVSUNLX0NIRUNLX01JTl9JTlRFUlZBTCA9IDEwMDsgLy8gbXMgbWluaW11bSBiZXR3ZWVuIHF1aWNrIGNoZWNrc1xyXG5cclxuLyoqXHJcbiAqIE1hbmFnZXMgdGhlIHJlbmRlcmluZywgaW50ZXJhY3Rpb24sIGFuZCBkYXRhIGV4dHJhY3Rpb24gb2YgdHJhbnNsYXRpb24gb3ZlcmxheXMgb24gUERGIHBhZ2VzLlxyXG4gKiBJdCBpcyB0aGUgZXhwZXJ0IG9uIGFsbCB0aGluZ3MgcmVsYXRlZCB0byB0aGUgUERGIHZpZXdlcidzIERPTS5cclxuICogRGVsZWdhdGVzIFVJIHJlbmRlcmluZyBhbmQgc3R5bGluZyB0byBPdmVybGF5VUlSZW5kZXJlci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBPdmVybGF5UmVuZGVyZXIge1xyXG4gICAgcHJpdmF0ZSBwbHVnaW46IE9wZW5Sb3V0ZXJUcmFuc2xhdG9yUGx1Z2luO1xyXG4gICAgcHJpdmF0ZSB1aVJlbmRlcmVyOiBPdmVybGF5VUlSZW5kZXJlcjsgLy8gTmV3IGluc3RhbmNlIGZvciBVSSBsb2dpY1xyXG5cclxuICAgIHByaXZhdGUgaXNPdmVybGF5VmlzaWJsZTogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgcGFnZU9ic2VydmVyOiBNdXRhdGlvbk9ic2VydmVyIHwgbnVsbCA9IG51bGw7XHJcbiAgICBwcml2YXRlIHpvb21PYnNlcnZlcjogTXV0YXRpb25PYnNlcnZlciB8IG51bGwgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBsYXN0S25vd25TY2FsZTogbnVtYmVyID0gMS4wO1xyXG4gICAgLy8gTm90ZTogY3JlYXRlZE92ZXJsYXlzIGFuZCB0cmFja2VkT3ZlcmxheUVsZW1lbnRzIGFyZSBub3cgbWFuYWdlZCBieSB1aVJlbmRlcmVyXHJcbiAgICBwcml2YXRlIGlzUmVsb2FkaW5nT3ZlcmxheSA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBhY3RpdmVMZWF2ZXNDYWNoZTogU2V0PGFueT4gfCBudWxsID0gbnVsbDtcclxuICAgIHByaXZhdGUgbWVtb0NhY2hlOiBNYXA8c3RyaW5nLCB7IHZhbHVlOiBhbnksIHRpbWVzdGFtcDogbnVtYmVyIH0+ID0gbmV3IE1hcCgpO1xyXG4gICAgLy8gTm90ZTogdGVtcERpdiBpcyBub3cgbWFuYWdlZCBieSB1aVJlbmRlcmVyXHJcbiAgICBwcml2YXRlIHpvb21EZWJvdW5jZVRpbWVvdXQ6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgbnVsbCA9IG51bGw7XHJcbiAgICBwcml2YXRlIGluRmxpZ2h0UGFnZUxvYWRzOiBNYXA8bnVtYmVyLCBQcm9taXNlPHZvaWQ+PiA9IG5ldyBNYXAoKTtcclxuICAgIC8vIEdyYWR1YWwgbG9hZGluZyBwcm9wZXJ0aWVzXHJcbiAgICBwcml2YXRlIGNhY2hlZE92ZXJsYXlEYXRhOiBTYXZlZE92ZXJsYXkgfCBudWxsID0gbnVsbDtcclxuICAgIHByaXZhdGUgcGFnZXNXaXRoT3ZlcmxheXM6IFNldDxudW1iZXI+ID0gbmV3IFNldCgpO1xyXG4gICAgcHJpdmF0ZSBwYWdlSW50ZXJzZWN0aW9uT2JzZXJ2ZXI6IEludGVyc2VjdGlvbk9ic2VydmVyIHwgbnVsbCA9IG51bGw7XHJcbiAgICAvLyBFbmhhbmNlZCBzY3JvbGwgc2FmZWd1YXJkIHByb3BlcnRpZXNcclxuICAgIHByaXZhdGUgc2Nyb2xsVGhyb3R0bGVUaW1lb3V0OiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IG51bGwgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBzY3JvbGxIYW5kbGVyOiAoKCkgPT4gdm9pZCkgfCBudWxsID0gbnVsbDtcclxuICAgIHByaXZhdGUgc2Nyb2xsYWJsZUNvbnRhaW5lcjogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcclxuICAgIHByaXZhdGUgbG9hZGVkT3ZlcmxheVBhZ2VzOiBTZXQ8bnVtYmVyPiA9IG5ldyBTZXQoKTtcclxuICAgIHByaXZhdGUgbGFzdFNjcm9sbENoZWNrOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBpc1Njcm9sbFNhZmVndWFyZFJ1bm5pbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgbGFzdFF1aWNrQ2hlY2s6IG51bWJlciA9IDA7XHJcblxyXG4gICAgY29uc3RydWN0b3IocGx1Z2luOiBPcGVuUm91dGVyVHJhbnNsYXRvclBsdWdpbikge1xyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgICAgIHRoaXMudWlSZW5kZXJlciA9IG5ldyBPdmVybGF5VUlSZW5kZXJlcihwbHVnaW4pOyAvLyBJbml0aWFsaXplIHRoZSBVSSByZW5kZXJlclxyXG4gICAgICAgIHRoaXMuaXNPdmVybGF5VmlzaWJsZSA9IHBsdWdpbi5zZXR0aW5ncy5zaG93T3ZlcmxheUJ5RGVmYXVsdCA/PyB0cnVlO1xyXG4gICAgICAgIC8vIEVuc3VyZSBsaW5lIGhlaWdodCBpcyBhIG51bWJlciAoZGVmYXVsdCAxLjIpXHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vdXRwdXRMaW5lSGVpZ2h0ICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vdXRwdXRMaW5lSGVpZ2h0ID0gMS4yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFB1YmxpYyBBUEkgZm9yIFRleHRQcm9jZXNzb3JcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIHB1YmxpYyBwcmVwYXJlUGFnZUZvck92ZXJsYXkocGFnZUVsZW1lbnQ6IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnQge1xyXG4gICAgICAgIGlmICghcGFnZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZygncHJlcGFyZVBhZ2VGb3JPdmVybGF5OiBQYWdlIGVsZW1lbnQgaXMgbnVsbCcpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhZ2UgZWxlbWVudCBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNsZWFyT3ZlcmxheUZyb21QYWdlKHBhZ2VFbGVtZW50KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVPdmVybGF5Q29udGFpbmVyKHBhZ2VFbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyT3ZlcmxheXMoXHJcbiAgICAgICAgdW5pdHM6IFRyYW5zbGF0aW9uVW5pdFtdLFxyXG4gICAgICAgIHRyYW5zbGF0ZWRMaW5lczogc3RyaW5nW10sXHJcbiAgICAgICAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcclxuICAgICAgICBwYWdlRWxlbWVudDogSFRNTEVsZW1lbnRcclxuICAgICkge1xyXG4gICAgICAgIGlmICghdW5pdHM/Lmxlbmd0aCB8fCAhdHJhbnNsYXRlZExpbmVzPy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZygncmVuZGVyT3ZlcmxheXM6IE5vIHVuaXRzIG9yIHRyYW5zbGF0ZWQgbGluZXMgcHJvdmlkZWQnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0ZXh0TWVtbyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7IC8vIFBlci1yZW5kZXIgbWVtbyBmb3IgcGxhaW4gdGV4dFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VOdW1iZXIgPSBwYXJzZUludChwYWdlRWxlbWVudC5kYXRhc2V0LnBhZ2VOdW1iZXIgfHwgJzAnKTtcclxuICAgICAgICAgICAgdW5pdHMuZm9yRWFjaCgodW5pdCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVkVGV4dCA9IHRyYW5zbGF0ZWRMaW5lc1tpXSB8fCB1bml0LnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFuc2xhdGVkVGV4dC50cmltKCkpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlY3QsIGZvbnRTaXplcywgZm9udEZhbWlseSB9ID0gdGhpcy5wbHVnaW4ucHJvY2Vzc29yLmdldFNwYW5zQmJveCh1bml0Lm9yaWdpbmFsU3BhbnMsIHBhZ2VFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY3QpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFBsYWluVGV4dCA9IHRleHRNZW1vLmdldCh1bml0LnRleHQpIHx8IHRoaXMudWlSZW5kZXJlci5leHRyYWN0UGxhaW5UZXh0RnJvbUh0bWwodW5pdC50ZXh0KTsgLy8gVXNlIGhlbHBlciBmcm9tIHVpUmVuZGVyZXJcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0TWVtby5zZXQodW5pdC50ZXh0LCBvcmlnaW5hbFBsYWluVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBuZWNlc3Nhcnkgc2V0dGluZ3MgdG8gdWlSZW5kZXJlclxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlFbCA9IHRoaXMudWlSZW5kZXJlci5jcmVhdGVSZWZsb3dPdmVybGF5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LCB0cmFuc2xhdGVkVGV4dCwgdW5pdC5vcmlnaW5hbFNwYW5zWzBdLCBmb250U2l6ZXMsIHBhZ2VOdW1iZXIsIG9yaWdpbmFsUGxhaW5UZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vdmVybGF5T3BhY2l0eSwgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3V0cHV0Rm9udFNpemVTY2FsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3V0cHV0TGluZUhlaWdodCwgdGhpcy5sYXN0S25vd25TY2FsZSwgZm9udEZhbWlseVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG92ZXJsYXlFbCk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh1bml0RXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKGBFcnJvciByZW5kZXJpbmcgdW5pdCAke2l9OmAsIHVuaXRFcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBNYXJrIHBhZ2UgYXMgbG9hZGVkXHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVkT3ZlcmxheVBhZ2VzLmFkZChwYWdlTnVtYmVyKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgUmVuZGVyZWQgJHt1bml0cy5sZW5ndGh9IG92ZXJsYXkocykgZm9yIHBhZ2UgJHtwYWdlTnVtYmVyfWApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nRGVidWcoJ3JlbmRlck92ZXJsYXlzIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyByZWZyZXNoQ3VycmVudE92ZXJsYXkoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldEN1cnJlbnRQYWdlRWxlbWVudCgpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdObyBhY3RpdmUgUERGIHBhZ2UgZm91bmQgdG8gcmVmcmVzaC4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXcgTm90aWNlKCdSZWZyZXNoaW5nIG92ZXJsYXkuLi4nKTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4ucHJvY2Vzc29yLmFkZFRleHRPdmVybGF5KCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZygnRXJyb3IgcmVmcmVzaGluZyBvdmVybGF5OicsIGVycm9yKTtcclxuICAgICAgICAgICAgbmV3IE5vdGljZSgnRmFpbGVkIHRvIHJlZnJlc2ggb3ZlcmxheScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWRqdXN0TGluZUhlaWdodChkZWx0YTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IG5ld1ZhbHVlID0gKHRoaXMucGx1Z2luLnNldHRpbmdzLm91dHB1dExpbmVIZWlnaHQgfHwgMS4yKSArIGRlbHRhO1xyXG4gICAgICAgICAgICAvLyBVc2UgY29uc3RhbnRzIGZyb20gdWlSZW5kZXJlciBvciBkZWZpbmUgbG9jYWxseSBpZiBuZWVkZWQgZm9yIGdsb2JhbCBhZGp1c3RtZW50XHJcbiAgICAgICAgICAgIGNvbnN0IE1JTiA9IDAuODtcclxuICAgICAgICAgICAgY29uc3QgTUFYID0gMi4wO1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IE1hdGgubWF4KE1JTiwgTWF0aC5taW4oTUFYLCBuZXdWYWx1ZSkpO1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IE1hdGgucm91bmQobmV3VmFsdWUgKiAxMCkgLyAxMDsgLy8gUm91bmQgdG8gMC4xIHByZWNpc2lvblxyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vdXRwdXRMaW5lSGVpZ2h0ID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgIC8vIFJlYXBwbHkgdG8gYWxsIG92ZXJsYXlzIChpbm5lciBkaXYgZm9yIHJlZmxvdykgLSBkZWxlZ2F0ZSB0byB1aVJlbmRlcmVyXHJcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wZGYtdGV4dC1vdmVybGF5LXJlZmxvdyBkaXYnKS5mb3JFYWNoKGlubmVyID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMudWlSZW5kZXJlci5hcHBseUxpbmVIZWlnaHQoaW5uZXIgYXMgSFRNTERpdkVsZW1lbnQsIG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBuZXcgTm90aWNlKGBMaW5lIGhlaWdodCBzZXQgdG8gJHtuZXdWYWx1ZX1gKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgTGluZSBoZWlnaHQgYWRqdXN0ZWQgdG8gJHtuZXdWYWx1ZX1gKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKCdhZGp1c3RMaW5lSGVpZ2h0IGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0ZhaWxlZCB0byBhZGp1c3QgbGluZSBoZWlnaHQnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JjZSByZWZyZXNoIGFsbCB2aXNpYmxlIG92ZXJsYXlzIC0gdXNlZnVsIGZvciB0cm91Ymxlc2hvb3RpbmdcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGZvcmNlUmVmcmVzaFZpc2libGVPdmVybGF5cygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBhY3RpdmVMZWFmID0gdGhpcy5nZXRBY3RpdmVQREZMZWFmKCk7XHJcbiAgICAgICAgICAgIGlmICghYWN0aXZlTGVhZikge1xyXG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnTm8gYWN0aXZlIFBERiBmb3VuZCcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VzID0gdGhpcy5nZXRQREZQYWdlc0ZvckxlYWYoYWN0aXZlTGVhZik7XHJcbiAgICAgICAgICAgIGlmICghcGFnZXMpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubG9nRGVidWcoJ1N0YXJ0aW5nIGZvcmNlIHJlZnJlc2ggb2YgdmlzaWJsZSBvdmVybGF5cycpO1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgICAgICAgICAgbGV0IHJlZnJlc2hDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFnZUVsZW1lbnQgb2YgQXJyYXkuZnJvbShwYWdlcykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBwYWdlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZWN0LmJvdHRvbSA8PSAwIHx8IHJlY3QudG9wID49IHZpZXdwb3J0SGVpZ2h0KSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlTnVtYmVyU3RyID0gcGFnZUVsZW1lbnQuZGF0YXNldC5wYWdlTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhZ2VOdW1iZXJTdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWdlTnVtYmVyID0gcGFyc2VJbnQocGFnZU51bWJlclN0ciwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhZ2VzV2l0aE92ZXJsYXlzLmhhcyhwYWdlTnVtYmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyT3ZlcmxheUZyb21QYWdlKHBhZ2VFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkZWRPdmVybGF5UGFnZXMuZGVsZXRlKHBhZ2VOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmxvYWRTYXZlZE92ZXJsYXlGb3JQYWdlKHBhZ2VOdW1iZXIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV3IE5vdGljZShgUmVmcmVzaGVkICR7cmVmcmVzaENvdW50fSBvdmVybGF5KHMpYCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nRGVidWcoYEZvcmNlIHJlZnJlc2hlZCAke3JlZnJlc2hDb3VudH0gb3ZlcmxheXNgKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKCdmb3JjZVJlZnJlc2hWaXNpYmxlT3ZlcmxheXMgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICBuZXcgTm90aWNlKCdFcnJvciByZWZyZXNoaW5nIG92ZXJsYXlzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vdGU6IGFwcGx5TGluZUhlaWdodCBpcyBub3cgaGFuZGxlZCBieSB1aVJlbmRlcmVyIGFuZCBpcyBwcml2YXRlIHRoZXJlXHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBJbnRlcm5hbCBET00gTWFuYWdlbWVudCAmIFV0aWxpdGllc1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgcHJpdmF0ZSBjcmVhdGVPdmVybGF5Q29udGFpbmVyKHBhZ2VFbGVtZW50OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50IHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBjb250YWluZXIuY2xhc3NOYW1lID0gJ3BkZi10ZXh0LW92ZXJsYXktY29udGFpbmVyJztcclxuICAgICAgICBjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgcG9pbnRlci1ldmVudHM6IG5vbmU7IHotaW5kZXg6IDEwMDsgb3ZlcmZsb3c6IGhpZGRlbjtgO1xyXG4gICAgICAgIHBhZ2VFbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNsZWFyT3ZlcmxheUZyb21QYWdlKHBhZ2VFbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ29udGFpbmVyID0gcGFnZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLnBkZi10ZXh0LW92ZXJsYXktY29udGFpbmVyJyk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIGV4aXN0aW5nQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5wZGYtdGV4dC1vdmVybGF5LXJlZmxvdycpLmZvckVhY2gob3ZlcmxheSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVpUmVuZGVyZXIuY2xlYW51cE92ZXJsYXlFbGVtZW50KG92ZXJsYXkgYXMgSFRNTEVsZW1lbnQpOyAvLyBEZWxlZ2F0ZSBjbGVhbnVwIHRvIHVpUmVuZGVyZXJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGV4aXN0aW5nQ29udGFpbmVyLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDbGVhciBmcm9tIGxvYWRlZCBwYWdlcyB0cmFja2luZ1xyXG4gICAgICAgIGNvbnN0IHBhZ2VOdW1iZXJTdHIgPSBwYWdlRWxlbWVudC5kYXRhc2V0LnBhZ2VOdW1iZXI7XHJcbiAgICAgICAgaWYgKHBhZ2VOdW1iZXJTdHIpIHtcclxuICAgICAgICAgICAgY29uc3QgcGFnZU51bWJlciA9IHBhcnNlSW50KHBhZ2VOdW1iZXJTdHIsIDEwKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZWRPdmVybGF5UGFnZXMuZGVsZXRlKHBhZ2VOdW1iZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3RlOiBleHRyYWN0UGxhaW5UZXh0RnJvbUh0bWwgaXMgbm93IGhhbmRsZWQgYnkgdWlSZW5kZXJlciBhbmQgaXMgcHJpdmF0ZSB0aGVyZVxyXG4gICAgLy8gSWYgbmVlZGVkIGxvY2FsbHksIGl0IGNhbiBiZSBrZXB0IGhlcmUgb3IgZGVsZWdhdGVkIHZpYSB1aVJlbmRlcmVyLlxyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gU2V0dXAgJiBNb25pdG9yaW5nIChFTkhBTkNFRCB3aXRoIGJldHRlciBwZXJmb3JtYW5jZSlcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzZXR1cFBERk1vbml0b3JpbmcobGVhZjogYW55KSB7XHJcbiAgICAgICAgaWYgKCFsZWFmPy52aWV3Py5maWxlIHx8IGxlYWYudmlldy5nZXRWaWV3VHlwZSgpICE9PSAncGRmJykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKCdzZXR1cFBERk1vbml0b3Jpbmc6IEludmFsaWQgbGVhZiBvciBub3QgYSBQREYgdmlldy4nKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2xlYW51cCBwcmV2aW91cyBvYnNlcnZlcnNcclxuICAgICAgICB0aGlzLmNsZWFudXBNb25pdG9yaW5nKCk7XHJcblxyXG4gICAgICAgIC8vIExvYWQgdHJhbnNsYXRpb24gZGF0YSBhbmQgaWRlbnRpZnkgcGFnZXMgdGhhdCBuZWVkIG92ZXJsYXlzXHJcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplT3ZlcmxheVN0YXRlRm9yUGRmKGxlYWYudmlldy5maWxlKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBhZ2VzIHdpdGggc2F2ZWQgb3ZlcmxheXMsIHdlIGRvbid0IG5lZWQgdG8gbW9uaXRvciBhbnl0aGluZy5cclxuICAgICAgICBpZiAodGhpcy5wYWdlc1dpdGhPdmVybGF5cy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nRGVidWcoJ05vIHNhdmVkIG92ZXJsYXlzIGZvdW5kIGZvciB0aGlzIFBERi4gTm8gbW9uaXRvcmluZyB3aWxsIGJlIHN0YXJ0ZWQuJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBhdHRlbXB0cyA9IDA7XHJcbiAgICAgICAgY29uc3QgbWF4QXR0ZW1wdHMgPSA1MDsgLy8gNXMgdG90YWxcclxuICAgICAgICBjb25zdCBjaGVja1ZpZXdlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgYXR0ZW1wdHMrKztcclxuICAgICAgICAgICAgY29uc3Qgdmlld2VyQ29udGFpbmVyID0gbGVhZi52aWV3LmNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoJy5wZGZWaWV3ZXIsICN2aWV3ZXInKTtcclxuICAgICAgICAgICAgaWYgKHZpZXdlckNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgUERGIHZpZXdlciBmb3VuZC4gTW9uaXRvcmluZyBmb3IgJHt0aGlzLnBhZ2VzV2l0aE92ZXJsYXlzLnNpemV9IHBhZ2VzIHdpdGggc2F2ZWQgdHJhbnNsYXRpb25zLmApO1xyXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHNjcm9sbCBjb250YWluZXIgZmlyc3Qgc28gSU8gdXNlcyB0aGUgY29ycmVjdCByb290XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vbml0b3JTY3JvbGxpbmcodmlld2VyQ29udGFpbmVyIGFzIEhUTUxFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIC8vIE5vdyBJTyB1c2VzIHNjcm9sbGFibGVDb250YWluZXIgYXMgcm9vdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXR1cEludGVyc2VjdGlvbk9ic2VydmVyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vbml0b3JQYWdlQ29udGFpbmVyKHZpZXdlckNvbnRhaW5lciBhcyBIVE1MRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vbml0b3Jab29tKHZpZXdlckNvbnRhaW5lciBhcyBIVE1MRWxlbWVudCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXR0ZW1wdHMgPCBtYXhBdHRlbXB0cykge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjaGVja1ZpZXdlciwgMTAwKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nRGVidWcoJ1BERiB2aWV3ZXIgbm90IGZvdW5kIGFmdGVyIG1heGltdW0gYXR0ZW1wdHMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY2hlY2tWaWV3ZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGluaXRpYWxpemVPdmVybGF5U3RhdGVGb3JQZGYocGRmRmlsZTogVEZpbGUpIHtcclxuICAgICAgICAvLyBSZXNldCBzdGF0ZSBmb3IgdGhlIG5ldyBmaWxlXHJcbiAgICAgICAgdGhpcy5jYWNoZWRPdmVybGF5RGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wYWdlc1dpdGhPdmVybGF5cy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMubG9hZGVkT3ZlcmxheVBhZ2VzLmNsZWFyKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uRmlsZSA9IGF3YWl0IHRoaXMucGx1Z2luLnN0b3JhZ2UuZmluZFRyYW5zbGF0aW9uRmlsZUZvclBkZihwZGZGaWxlKTtcclxuICAgICAgICBpZiAoIXRyYW5zbGF0aW9uRmlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIE5vIHRyYW5zbGF0aW9uIGZpbGUgZXhpc3RzLlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5yZWFkKHRyYW5zbGF0aW9uRmlsZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE92ZXJsYXkgPSB0aGlzLnBsdWdpbi5zdG9yYWdlLnBhcnNlTWFya2Rvd25PdmVybGF5KGNvbnRlbnQsIHBkZkZpbGUpO1xyXG4gICAgICAgICAgICBpZiAocGFyc2VkT3ZlcmxheSAmJiBwYXJzZWRPdmVybGF5LnBhZ2VPdmVybGF5cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRPdmVybGF5RGF0YSA9IHBhcnNlZE92ZXJsYXk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlTnVtYmVycyA9IE9iamVjdC5rZXlzKHBhcnNlZE92ZXJsYXkucGFnZU92ZXJsYXlzKS5tYXAoTnVtYmVyKS5maWx0ZXIobiA9PiAhaXNOYU4obikgJiYgbiA+IDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlc1dpdGhPdmVybGF5cyA9IG5ldyBTZXQocGFnZU51bWJlcnMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgSW5pdGlhbGl6ZWQgb3ZlcmxheSBkYXRhIGZvciAke3BhZ2VOdW1iZXJzLmxlbmd0aH0gcGFnZXM6ICR7cGFnZU51bWJlcnMuam9pbignLCAnKX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BERiBUcmFuc2xhdG9yOiBGYWlsZWQgdG8gcmVhZCBvciBwYXJzZSB0cmFuc2xhdGlvbiBmaWxlLicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzZXR1cEludGVyc2VjdGlvbk9ic2VydmVyKCkge1xyXG4gICAgICAgIHRoaXMucGFnZUludGVyc2VjdGlvbk9ic2VydmVyPy5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgLy8gQmV0dGVyIHJvb3QgZGV0ZWN0aW9uXHJcbiAgICAgICAgbGV0IHJvb3Q6IEVsZW1lbnQgfCBudWxsID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5zY3JvbGxhYmxlQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHJvb3QgPSB0aGlzLnNjcm9sbGFibGVDb250YWluZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IEludGVyc2VjdGlvbk9ic2VydmVySW5pdCA9IHtcclxuICAgICAgICAgICAgcm9vdDogcm9vdCxcclxuICAgICAgICAgICAgcm9vdE1hcmdpbjogJzQwMHB4JywgLy8gUmVkdWNlZCBmcm9tIDgwMHB4IGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcclxuICAgICAgICAgICAgdGhyZXNob2xkOiBbMCwgMC4xLCAwLjNdIC8vIE11bHRpcGxlIHRocmVzaG9sZHMgZm9yIGJldHRlciBkZXRlY3Rpb25cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLnBhZ2VJbnRlcnNlY3Rpb25PYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcykgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZyAmJiBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWdlRWxlbWVudCA9IGVudHJ5LnRhcmdldCBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWdlTnVtYmVyU3RyID0gcGFnZUVsZW1lbnQuZGF0YXNldC5wYWdlTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWdlTnVtYmVyU3RyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VOdW1iZXIgPSBwYXJzZUludChwYWdlTnVtYmVyU3RyLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhZ2VzV2l0aE92ZXJsYXlzLmhhcyhwYWdlTnVtYmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBvcHRpbWl6ZWQgbG9hZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZVBhZ2VPdmVybGF5TG9hZGVkKHBhZ2VOdW1iZXIsIHBhZ2VFbGVtZW50KS5jYXRjaChlcnIgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKGBJTyBsb2FkIGVycm9yIHBhZ2UgJHtwYWdlTnVtYmVyfWAsIGVycilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgLy8gT2JzZXJ2ZSBleGlzdGluZyBwYWdlcyBpbW1lZGlhdGVseVxyXG4gICAgICAgIHRoaXMub2JzZXJ2ZUV4aXN0aW5nUGFnZXMoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG9ic2VydmVFeGlzdGluZ1BhZ2VzKCkge1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUxlYWYgPSB0aGlzLmdldEFjdGl2ZVBERkxlYWYoKTtcclxuICAgICAgICBpZiAoIWFjdGl2ZUxlYWYpIHJldHVybjtcclxuICAgICAgICBjb25zdCBwYWdlcyA9IHRoaXMuZ2V0UERGUGFnZXNGb3JMZWFmKGFjdGl2ZUxlYWYpO1xyXG4gICAgICAgIGlmICghcGFnZXMpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IG9ic2VydmVkQ291bnQgPSAwO1xyXG4gICAgICAgIHBhZ2VzLmZvckVhY2gocGFnZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VOdW1iZXJTdHIgPSBwYWdlLmRhdGFzZXQucGFnZU51bWJlcjtcclxuICAgICAgICAgICAgaWYgKHBhZ2VOdW1iZXJTdHIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VOdW1iZXIgPSBwYXJzZUludChwYWdlTnVtYmVyU3RyLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYWdlc1dpdGhPdmVybGF5cy5oYXMocGFnZU51bWJlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhZ2VJbnRlcnNlY3Rpb25PYnNlcnZlcj8ub2JzZXJ2ZShwYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlZENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmxvZ0RlYnVnKGBTdGFydGVkIG9ic2VydmluZyAke29ic2VydmVkQ291bnR9IHBhZ2VzIHdpdGggb3ZlcmxheXNgKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG1vbml0b3JQYWdlQ29udGFpbmVyKHBkZlZpZXdlcjogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLnBhZ2VPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZU11dGF0aW9ucyA9IChtdXRhdGlvbnM6IE11dGF0aW9uUmVjb3JkW10pID0+IHtcclxuICAgICAgICAgICAgbGV0IG5ld1BhZ2VzQWRkZWQgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG5ld2x5IGFkZGVkIHBhZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24uYWRkZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYWdlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VOdW1iZXJTdHIgPSBub2RlLmRhdGFzZXQucGFnZU51bWJlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWdlTnVtYmVyU3RyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFnZU51bWJlciA9IHBhcnNlSW50KHBhZ2VOdW1iZXJTdHIsIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHBhZ2UgaXMgc3VwcG9zZWQgdG8gaGF2ZSBhbiBvdmVybGF5LCBzdGFydCB3YXRjaGluZyBpdCBmb3IgdmlzaWJpbGl0eS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYWdlc1dpdGhPdmVybGF5cy5oYXMocGFnZU51bWJlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdlSW50ZXJzZWN0aW9uT2JzZXJ2ZXI/Lm9ic2VydmUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhZ2VzQWRkZWQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCBvYnNlcnZlciBmb3IgcmVtb3ZlZCBwYWdlc1xyXG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uLnJlbW92ZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYWdlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFnZUludGVyc2VjdGlvbk9ic2VydmVyPy51bm9ic2VydmUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciBmcm9tIGxvYWRlZCB0cmFja2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFnZU51bWJlclN0ciA9IG5vZGUuZGF0YXNldC5wYWdlTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2VOdW1iZXJTdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWdlTnVtYmVyID0gcGFyc2VJbnQocGFnZU51bWJlclN0ciwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkT3ZlcmxheVBhZ2VzLmRlbGV0ZShwYWdlTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXdQYWdlc0FkZGVkID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgU3RhcnRlZCBvYnNlcnZpbmcgJHtuZXdQYWdlc0FkZGVkfSBuZXcgcGFnZXNgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMucGFnZU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoaGFuZGxlTXV0YXRpb25zKTtcclxuICAgICAgICB0aGlzLnBhZ2VPYnNlcnZlci5vYnNlcnZlKHBkZlZpZXdlciwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBtb25pdG9yWm9vbShwZGZWaWV3ZXI6IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy56b29tT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICBjb25zdCBoYW5kbGVab29tQ2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzY2FsZUZhY3RvclN0ciA9IHBkZlZpZXdlci5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCctLXNjYWxlLWZhY3RvcicpO1xyXG4gICAgICAgICAgICBpZiAoIXNjYWxlRmFjdG9yU3RyKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1NjYWxlID0gcGFyc2VGbG9hdChzY2FsZUZhY3RvclN0cik7XHJcbiAgICAgICAgICAgIGlmICghaXNOYU4obmV3U2NhbGUpICYmIE1hdGguYWJzKG5ld1NjYWxlIC0gdGhpcy5sYXN0S25vd25TY2FsZSkgPiAwLjAwMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgWm9vbSBjaGFuZ2VkIGZyb20gJHt0aGlzLmxhc3RLbm93blNjYWxlfSB0byAke25ld1NjYWxlfS4gVHJpZ2dlcmluZyBvdmVybGF5IHVwZGF0ZS5gKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdEtub3duU2NhbGUgPSBuZXdTY2FsZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnpvb21EZWJvdW5jZVRpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy56b29tRGVib3VuY2VUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuem9vbURlYm91bmNlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVyZW5kZXJWaXNpYmxlT3ZlcmxheXMoKTtcclxuICAgICAgICAgICAgICAgIH0sIFpPT01fUkVQT1NJVElPTl9ERUJPVU5DRSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1lbW9DYWNoZS5jbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy56b29tT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVab29tQ2hhbmdlKTtcclxuICAgICAgICB0aGlzLnpvb21PYnNlcnZlci5vYnNlcnZlKHBkZlZpZXdlciwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBhdHRyaWJ1dGVGaWx0ZXI6IFsnc3R5bGUnXSB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgaW5pdGlhbFNjYWxlU3RyID0gcGRmVmlld2VyLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoJy0tc2NhbGUtZmFjdG9yJyk7XHJcbiAgICAgICAgaWYgKGluaXRpYWxTY2FsZVN0cikgdGhpcy5sYXN0S25vd25TY2FsZSA9IHBhcnNlRmxvYXQoaW5pdGlhbFNjYWxlU3RyKSB8fCAxLjA7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBtb25pdG9yU2Nyb2xsaW5nKHBkZlZpZXdlcjogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5zY3JvbGxhYmxlQ29udGFpbmVyICYmIHRoaXMuc2Nyb2xsSGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbGFibGVDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5zY3JvbGxIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQmV0dGVyIGNvbnRhaW5lciBkZXRlY3Rpb24gd2l0aCBmYWxsYmFja3NcclxuICAgICAgICB0aGlzLnNjcm9sbGFibGVDb250YWluZXIgPSBwZGZWaWV3ZXIuY2xvc2VzdCgnLm1vZC12ZXJ0aWNhbCcpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZGZWaWV3ZXIuY2xvc2VzdCgnLndvcmtzcGFjZS1sZWFmLWNvbnRlbnQnKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGRmVmlld2VyLnBhcmVudEVsZW1lbnQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBkZlZpZXdlcjtcclxuICAgICAgICB0aGlzLmxvZ0RlYnVnKGBTY3JvbGwgY29udGFpbmVyIGRldGVjdGVkOiAke3RoaXMuc2Nyb2xsYWJsZUNvbnRhaW5lci5jbGFzc05hbWUgfHwgJ25vIGNsYXNzJ31gKTtcclxuXHJcbiAgICAgICAgLy8gRW5oYW5jZWQgc2Nyb2xsIGhhbmRsZXIgd2l0aCB0d28tdGllciBjaGVja2luZ1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgLy8gSW1tZWRpYXRlIGxpZ2h0d2VpZ2h0IGNoZWNrIGZvciBjcml0aWNhbCB2aXNpYmlsaXR5XHJcbiAgICAgICAgICAgIGlmIChub3cgLSB0aGlzLmxhc3RRdWlja0NoZWNrID4gUVVJQ0tfQ0hFQ0tfTUlOX0lOVEVSVkFMKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RRdWlja0NoZWNrID0gbm93O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWlja1Zpc2liaWxpdHlDaGVjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRocm90dGxlZCBjb21wcmVoZW5zaXZlIGNoZWNrXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbFRocm90dGxlVGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2Nyb2xsVGhyb3R0bGVUaW1lb3V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRocm90dGxlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vdyAtIHRoaXMubGFzdFNjcm9sbENoZWNrID4gUVVJQ0tfQ0hFQ0tfTUlOX0lOVEVSVkFMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0U2Nyb2xsQ2hlY2sgPSBub3c7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVoZW5zaXZlT3ZlcmxheUNoZWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIFNDUk9MTF9USFJPVFRMRV9ERUxBWSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5zY3JvbGxhYmxlQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuc2Nyb2xsSGFuZGxlciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExpZ2h0IGNoZWNrIHRoYXQgcnVucyBpbW1lZGlhdGVseSBvbiBzY3JvbGxcclxuICAgIHByaXZhdGUgcXVpY2tWaXNpYmlsaXR5Q2hlY2soKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTY3JvbGxTYWZlZ3VhcmRSdW5uaW5nKSByZXR1cm47XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgYWN0aXZlTGVhZiA9IHRoaXMuZ2V0QWN0aXZlUERGTGVhZigpO1xyXG4gICAgICAgICAgICBpZiAoIWFjdGl2ZUxlYWYpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgcGFnZXMgPSB0aGlzLmdldFBERlBhZ2VzRm9yTGVhZihhY3RpdmVMZWFmKTtcclxuICAgICAgICAgICAgaWYgKCFwYWdlcykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0Q2VudGVyID0gdmlld3BvcnRIZWlnaHQgLyAyO1xyXG5cclxuICAgICAgICAgICAgLy8gRmluZCB0aGUgbW9zdCBjZW50cmFsIHZpc2libGUgcGFnZVxyXG4gICAgICAgICAgICBsZXQgY2VudHJhbFBhZ2U6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCBtaW5EaXN0YW5jZVRvQ2VudGVyID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFnZUVsZW1lbnQgb2YgQXJyYXkuZnJvbShwYWdlcykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBwYWdlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZWN0LmJvdHRvbSA8PSAwIHx8IHJlY3QudG9wID49IHZpZXdwb3J0SGVpZ2h0KSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlQ2VudGVyID0gcmVjdC50b3AgKyByZWN0LmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZVRvQ2VudGVyID0gTWF0aC5hYnMocGFnZUNlbnRlciAtIHZpZXdwb3J0Q2VudGVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZVRvQ2VudGVyIDwgbWluRGlzdGFuY2VUb0NlbnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlVG9DZW50ZXIgPSBkaXN0YW5jZVRvQ2VudGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbnRyYWxQYWdlID0gcGFnZUVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgY2VudHJhbCBwYWdlIGhhcyBpdHMgb3ZlcmxheSBpZiBpdCBzaG91bGRcclxuICAgICAgICAgICAgaWYgKGNlbnRyYWxQYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlTnVtYmVyU3RyID0gY2VudHJhbFBhZ2UuZGF0YXNldC5wYWdlTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhZ2VOdW1iZXJTdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWdlTnVtYmVyID0gcGFyc2VJbnQocGFnZU51bWJlclN0ciwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5zdXJlUGFnZU92ZXJsYXlMb2FkZWQocGFnZU51bWJlciwgY2VudHJhbFBhZ2UpLmNhdGNoKGVyciA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKGBRdWljayBjaGVjayBsb2FkIGVycm9yIHBhZ2UgJHtwYWdlTnVtYmVyfWAsIGVycilcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhcInF1aWNrVmlzaWJpbGl0eUNoZWNrIGVycm9yXCIsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29tcHJlaGVuc2l2ZSBjaGVjayB0aGF0IHJ1bnMgYWZ0ZXIgc2Nyb2xsIHNldHRsZXNcclxuICAgIHByaXZhdGUgYXN5bmMgY29tcHJlaGVuc2l2ZU92ZXJsYXlDaGVjaygpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1Njcm9sbFNhZmVndWFyZFJ1bm5pbmcpIHJldHVybjtcclxuICAgICAgICB0aGlzLmlzU2Nyb2xsU2FmZWd1YXJkUnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgYWN0aXZlTGVhZiA9IHRoaXMuZ2V0QWN0aXZlUERGTGVhZigpO1xyXG4gICAgICAgICAgICBpZiAoIWFjdGl2ZUxlYWYpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgcGFnZXMgPSB0aGlzLmdldFBERlBhZ2VzRm9yTGVhZihhY3RpdmVMZWFmKTtcclxuICAgICAgICAgICAgaWYgKCFwYWdlcykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGVQYWdlczogeyBlbGVtZW50OiBIVE1MRWxlbWVudCwgcGFnZU51bWJlcjogbnVtYmVyIH1bXSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29sbGVjdCBhbGwgdmlzaWJsZSBwYWdlcyB3aXRoIGdlbmVyb3VzIG1hcmdpbnNcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwYWdlRWxlbWVudCBvZiBBcnJheS5mcm9tKHBhZ2VzKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IHBhZ2VFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gTW9yZSBnZW5lcm91cyB2aXNpYmlsaXR5IGNoZWNrXHJcbiAgICAgICAgICAgICAgICBpZiAocmVjdC5ib3R0b20gPCAtMjAwIHx8IHJlY3QudG9wID4gdmlld3BvcnRIZWlnaHQgKyAyMDApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VOdW1iZXJTdHIgPSBwYWdlRWxlbWVudC5kYXRhc2V0LnBhZ2VOdW1iZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFnZU51bWJlclN0cikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VOdW1iZXIgPSBwYXJzZUludChwYWdlTnVtYmVyU3RyLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFnZXNXaXRoT3ZlcmxheXMuaGFzKHBhZ2VOdW1iZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGVQYWdlcy5wdXNoKHsgZWxlbWVudDogcGFnZUVsZW1lbnQsIHBhZ2VOdW1iZXIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMb2FkIG92ZXJsYXlzIGZvciB2aXNpYmxlIHBhZ2VzIGluIHBhcmFsbGVsIHdpdGggbGltaXRlZCBjb25jdXJyZW5jeVxyXG4gICAgICAgICAgICBjb25zdCBiYXRjaFNpemUgPSAzOyAvLyBMaW1pdCBjb25jdXJyZW50IGxvYWRzXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaWJsZVBhZ2VzLmxlbmd0aDsgaSArPSBiYXRjaFNpemUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gdmlzaWJsZVBhZ2VzLnNsaWNlKGksIGkgKyBiYXRjaFNpemUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbG9hZFByb21pc2VzID0gYmF0Y2gubWFwKCh7IGVsZW1lbnQsIHBhZ2VOdW1iZXIgfSkgPT5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZVBhZ2VPdmVybGF5TG9hZGVkKHBhZ2VOdW1iZXIsIGVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGxvYWRQcm9taXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgQ29tcHJlaGVuc2l2ZSBjaGVjayBjb21wbGV0ZWQgZm9yICR7dmlzaWJsZVBhZ2VzLmxlbmd0aH0gdmlzaWJsZSBwYWdlc2ApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nRGVidWcoXCJjb21wcmVoZW5zaXZlT3ZlcmxheUNoZWNrIGVycm9yXCIsIGVycm9yKTtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0aGlzLmlzU2Nyb2xsU2FmZWd1YXJkUnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJbXByb3ZlZCBzaW5nbGUgcGFnZSBvdmVybGF5IGxvYWRpbmcgd2l0aCBiZXR0ZXIgc3RhdGUgdHJhY2tpbmdcclxuICAgIHByaXZhdGUgYXN5bmMgZW5zdXJlUGFnZU92ZXJsYXlMb2FkZWQocGFnZU51bWJlcjogbnVtYmVyLCBwYWdlRWxlbWVudDogSFRNTEVsZW1lbnQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBpZiAoIXRoaXMucGFnZXNXaXRoT3ZlcmxheXMuaGFzKHBhZ2VOdW1iZXIpKSByZXR1cm47XHJcbiAgICAgICAgY29uc3QgaGFzT3ZlcmxheSA9IHBhZ2VFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wZGYtdGV4dC1vdmVybGF5LXJlZmxvdycpICE9PSBudWxsO1xyXG4gICAgICAgIGNvbnN0IGlzTG9hZGVkID0gdGhpcy5sb2FkZWRPdmVybGF5UGFnZXMuaGFzKHBhZ2VOdW1iZXIpO1xyXG5cclxuICAgICAgICAvLyBJZiBwcm9wZXJseSBsb2FkZWQsIHNraXBcclxuICAgICAgICBpZiAoaGFzT3ZlcmxheSAmJiBpc0xvYWRlZCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBJZiBvdmVybGF5IGV4aXN0cyBidXQgbm90IHRyYWNrZWQgYXMgbG9hZGVkLCBtYXJrIGl0XHJcbiAgICAgICAgaWYgKGhhc092ZXJsYXkgJiYgIWlzTG9hZGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVkT3ZlcmxheVBhZ2VzLmFkZChwYWdlTnVtYmVyKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2F2ZWRPdmVybGF5Rm9yUGFnZShwYWdlTnVtYmVyLCBmYWxzZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgRmFpbGVkIHRvIGVuc3VyZSBvdmVybGF5IGZvciBwYWdlICR7cGFnZU51bWJlcn06YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBsb2FkZWQgc2V0IHNvIHdlJ2xsIHJldHJ5IGxhdGVyXHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVkT3ZlcmxheVBhZ2VzLmRlbGV0ZShwYWdlTnVtYmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBbT3B0aW1pemVkXSBSZXJlbmRlciBhbGwgdmlzaWJsZSBvdmVybGF5cyBhZnRlciB6b29tIG9yIGxheW91dCBjaGFuZ2UuXHJcbiAgICAgKiBVc2VzIHN0YWdpbmcgKyBiYXRjaGluZyB0byBtaW5pbWl6ZSByZWZsb3dzIGFuZCBwYXJhbGxlbGl6ZSBhY3Jvc3MgcGFnZXMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgcmVyZW5kZXJWaXNpYmxlT3ZlcmxheXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNSZWxvYWRpbmdPdmVybGF5KSByZXR1cm47XHJcbiAgICAgICAgdGhpcy5pc1JlbG9hZGluZ092ZXJsYXkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubG9nRGVidWcoXCJSZXJlbmRlcmluZyB2aXNpYmxlIG92ZXJsYXlzIGR1ZSB0byB6b29tIG9yIGxheW91dCBjaGFuZ2UuXCIpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlYWYgPSB0aGlzLmdldEFjdGl2ZVBERkxlYWYoKTtcclxuICAgICAgICAgICAgaWYgKCFsZWFmKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdlckNvbnRhaW5lciA9IGxlYWYudmlldy5jb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKCcucGRmVmlld2VyLCAjdmlld2VyJyk7XHJcbiAgICAgICAgICAgIGlmICghdmlld2VyQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKFwiQ291bGQgbm90IGZpbmQgdmlld2VyIGNvbnRhaW5lciBkdXJpbmcgcmVyZW5kZXIuIEFib3J0aW5nLlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTGV0IHRoZSBET00gc2V0dGxlIGFmdGVyIHpvb21cclxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIFpPT01fRElNX1NUQUJMRV9XQUlUKSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwYWdlcyA9IHRoaXMuZ2V0UERGUGFnZXNGb3JMZWFmKGxlYWYpO1xyXG4gICAgICAgICAgICBpZiAoIXBhZ2VzKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgICAgICAgICAgY29uc3QgdmlzaWJsZVBhZ2VzOiBIVE1MRWxlbWVudFtdID0gQXJyYXkuZnJvbShwYWdlcykuZmlsdGVyKHAgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IHAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdC5ib3R0b20gPiAwICYmIHJlY3QudG9wIDwgdmlld3BvcnRIZWlnaHQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZpc2libGVQYWdlcy5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIENsZWFyIGxvYWRlZCBzdGF0ZSBmb3IgdmlzaWJsZSBwYWdlcyBzaW5jZSB3ZSdyZSByZXJlbmRlcmluZ1xyXG4gICAgICAgICAgICB2aXNpYmxlUGFnZXMuZm9yRWFjaChwYWdlRWxlbWVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlTnVtYmVyU3RyID0gcGFnZUVsZW1lbnQuZGF0YXNldC5wYWdlTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhZ2VOdW1iZXJTdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWdlTnVtYmVyID0gcGFyc2VJbnQocGFnZU51bWJlclN0ciwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkT3ZlcmxheVBhZ2VzLmRlbGV0ZShwYWdlTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyAtLS0gQmF0Y2hpbmcgb3B0aW1pemF0aW9uIC0tLVxyXG4gICAgICAgICAgICBjb25zdCBzdGFnaW5nQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIHN0YWdpbmdDb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGBcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICAgICAgICAgIHRvcDogLTk5OTk5cHg7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiAtOTk5OTlweDtcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcclxuICAgICAgICAgICAgYDtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGFnaW5nQ29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VPdmVybGF5U2V0czogeyBwYWdlRWxlbWVudDogSFRNTEVsZW1lbnQsIG92ZXJsYXlzOiBIVE1MRWxlbWVudFtdIH1bXSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RlcCAxOiBwcmVwYXJlIG92ZXJsYXlzIGZvciBhbGwgdmlzaWJsZSBwYWdlcyBpbiBwYXJhbGxlbFxyXG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh2aXNpYmxlUGFnZXMubWFwKGFzeW5jIHBhZ2VFbGVtZW50ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VOdW1iZXJTdHIgPSBwYWdlRWxlbWVudC5kYXRhc2V0LnBhZ2VOdW1iZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhZ2VOdW1iZXJTdHIpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VOdW1iZXIgPSBwYXJzZUludChwYWdlTnVtYmVyU3RyLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFnZXNXaXRoT3ZlcmxheXMuaGFzKHBhZ2VOdW1iZXIpKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlRGF0YSA9IHRoaXMuY2FjaGVkT3ZlcmxheURhdGE/LnBhZ2VPdmVybGF5c1twYWdlTnVtYmVyXTtcclxuICAgICAgICAgICAgICAgIGlmICghcGFnZURhdGEgfHwgcGFnZURhdGEubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dExheWVyID0gYXdhaXQgdGhpcy53YWl0Rm9yUGRmVGV4dExheWVyKHBhZ2VOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0ZXh0TGF5ZXIpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBndWFyYW50ZWUgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICBpZiAocGFnZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLnBkZi10ZXh0LW92ZXJsYXktY29udGFpbmVyJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyT3ZlcmxheUZyb21QYWdlKHBhZ2VFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlDb250YWluZXIgPSB0aGlzLnByZXBhcmVQYWdlRm9yT3ZlcmxheShwYWdlRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dExheWVyUmVjdCA9IHRleHRMYXllci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrUmVmID0gKHRleHRMYXllci5xdWVyeVNlbGVjdG9yKCdzcGFuJykgYXMgSFRNTFNwYW5FbGVtZW50KSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdmVybGF5czogSFRNTEVsZW1lbnRbXSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGF0YSBvZiBwYWdlRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFic1JlY3QgPSBuZXcgRE9NUmVjdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmVsYXRpdmVSZWN0LmxlZnQgKiB0ZXh0TGF5ZXJSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yZWxhdGl2ZVJlY3QudG9wICogdGV4dExheWVyUmVjdC5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJlbGF0aXZlUmVjdC53aWR0aCAqIHRleHRMYXllclJlY3Qud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJlbGF0aXZlUmVjdC5oZWlnaHQgKiB0ZXh0TGF5ZXJSZWN0LmhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIG5lY2Vzc2FyeSBzZXR0aW5ncyB0byB1aVJlbmRlcmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlFbCA9IHRoaXMudWlSZW5kZXJlci5jcmVhdGVSZWZsb3dPdmVybGF5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJzUmVjdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudHJhbnNsYXRlZFRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFja1JlZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEub3JpZ2luYWxGb250U2l6ZXMgfHwgW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50ZXh0Q29udGVudCB8fCAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm92ZXJsYXlPcGFjaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3V0cHV0Rm9udFNpemVTY2FsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm91dHB1dExpbmVIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RLbm93blNjYWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5mb250RmFtaWx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWdpbmdDb250YWluZXIuYXBwZW5kQ2hpbGQob3ZlcmxheUVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheXMucHVzaChvdmVybGF5RWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKGBFcnJvciBzdGFnaW5nIG92ZXJsYXkgZm9yIHBhZ2UgJHtwYWdlTnVtYmVyfWAsIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFnZU92ZXJsYXlTZXRzLnB1c2goeyBwYWdlRWxlbWVudDogb3ZlcmxheUNvbnRhaW5lciwgb3ZlcmxheXMgfSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN0ZXAgMjogYmF0Y2ggYWRqdXN0bWVudHMgaW4gb25lIFJBRlxyXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgb3ZlcmxheXMgfSBvZiBwYWdlT3ZlcmxheVNldHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIG92ZXJsYXlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgdGhlIGN1cnJlbnQgZ2xvYmFsIGxpbmUgaGVpZ2h0IHNldHRpbmcgdG8gdGhlIGFkanVzdG1lbnQgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51aVJlbmRlcmVyLmFkanVzdE92ZXJsYXlGb3JPdmVyZmxvdyhlbCwgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3V0cHV0TGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdGVwIDM6IG1vdmUgb3ZlcmxheXMgdG8gdGhlaXIgYWN0dWFsIGNvbnRhaW5lcnMgYW5kIG1hcmsgYXMgbG9hZGVkXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBwYWdlRWxlbWVudCwgb3ZlcmxheXMgfSBvZiBwYWdlT3ZlcmxheVNldHMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZWwgb2Ygb3ZlcmxheXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlRWxlbWVudC5hcHBlbmRDaGlsZChlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBNYXJrIHBhZ2UgYXMgbG9hZGVkXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlTnVtYmVyU3RyID0gcGFnZUVsZW1lbnQuZGF0YXNldD8uZGF0YXNldD8ucGFnZU51bWJlcjsgLy8gTm90ZTogbGlrZWx5IGEgdHlwbyBpbiBvcmlnaW5hbCwgc2hvdWxkIGJlIHBhZ2VFbGVtZW50LmRhdGFzZXQucGFnZU51bWJlclxyXG4gICAgICAgICAgICAgICAgaWYgKHBhZ2VOdW1iZXJTdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWdlTnVtYmVyID0gcGFyc2VJbnQocGFnZU51bWJlclN0ciwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkT3ZlcmxheVBhZ2VzLmFkZChwYWdlTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3RhZ2luZ0NvbnRhaW5lci5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgUmVyZW5kZXJlZCBvdmVybGF5cyBmb3IgJHtwYWdlT3ZlcmxheVNldHMubGVuZ3RofSB2aXNpYmxlIHBhZ2UocylgKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKFwiRXJyb3IgZHVyaW5nIHZpc2libGUgb3ZlcmxheSByZXJlbmRlcjpcIiwgZXJyb3IpO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNSZWxvYWRpbmdPdmVybGF5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY2xhbXBBbGxCYm94UG9zaXRpb25zKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYWdlRWwgPSB0aGlzLmdldEN1cnJlbnRQYWdlRWxlbWVudCgpO1xyXG4gICAgICAgIGlmICghY3VycmVudFBhZ2VFbCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBwYWdlUmVjdCA9IGN1cnJlbnRQYWdlRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgY3VycmVudFBhZ2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcucGRmLXRleHQtb3ZlcmxheS1yZWZsb3cnKS5mb3JFYWNoKGVsID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaHRtbEVsID0gZWwgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gcGFyc2VGbG9hdChodG1sRWwuc3R5bGUubGVmdCB8fCAnMCcpO1xyXG4gICAgICAgICAgICBsZXQgdG9wID0gcGFyc2VGbG9hdChodG1sRWwuc3R5bGUudG9wIHx8ICcwJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VGbG9hdChodG1sRWwuc3R5bGUud2lkdGggfHwgJzAnKTtcclxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gcGFyc2VGbG9hdChodG1sRWwuc3R5bGUuaGVpZ2h0IHx8ICcwJyk7XHJcblxyXG4gICAgICAgICAgICBsZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obGVmdCwgcGFnZVJlY3Qud2lkdGggLSB3aWR0aCkpO1xyXG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0b3AsIHBhZ2VSZWN0LmhlaWdodCAtIGhlaWdodCkpO1xyXG5cclxuICAgICAgICAgICAgaHRtbEVsLnN0eWxlLmxlZnQgPSBgJHtsZWZ0fXB4YDtcclxuICAgICAgICAgICAgaHRtbEVsLnN0eWxlLnRvcCA9IGAke3RvcH1weGA7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBWaXNpYmlsaXR5ICYgVXRpbGl0eVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgcHVibGljIHRvZ2dsZU92ZXJsYXlWaXNpYmlsaXR5KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuaXNPdmVybGF5VmlzaWJsZSA9ICF0aGlzLmlzT3ZlcmxheVZpc2libGU7XHJcbiAgICAgICAgY29uc3QgdGltZW91dEtleSA9ICd2aXNpYmlsaXR5VGltZW91dCc7XHJcbiAgICAgICAgY29uc3QgY2FjaGVkVGltZW91dCA9IHRoaXMubWVtb0NhY2hlLmdldCh0aW1lb3V0S2V5KTtcclxuICAgICAgICBpZiAoY2FjaGVkVGltZW91dCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY2FjaGVkVGltZW91dC52YWx1ZSBhcyBOb2RlSlMuVGltZW91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMudXBkYXRlQWxsT3ZlcmxheVZpc2liaWxpdHkoKSwgREVCT1VOQ0VfREVMQVkpO1xyXG4gICAgICAgIHRoaXMubWVtb0NhY2hlLnNldCh0aW1lb3V0S2V5LCB7IHZhbHVlOiB0aW1lb3V0LCB0aW1lc3RhbXA6IERhdGUubm93KCkgfSk7XHJcblxyXG4gICAgICAgIG5ldyBOb3RpY2UoYE92ZXJsYXkgJHt0aGlzLmlzT3ZlcmxheVZpc2libGUgPyAnc2hvd24nIDogJ2hpZGRlbid9YCk7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2hvd092ZXJsYXlCeURlZmF1bHQgPSB0aGlzLmlzT3ZlcmxheVZpc2libGU7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB1cGRhdGVBbGxPdmVybGF5VmlzaWJpbGl0eSgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBjYWNoZUtleSA9ICdjYWNoZVJlZnJlc2gnO1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVMZWF2ZXNDYWNoZSB8fCBEYXRlLm5vdygpIC0gKHRoaXMubWVtb0NhY2hlLmdldChjYWNoZUtleSk/LnRpbWVzdGFtcCB8fCAwKSA+IDEwMDApIHtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVMZWF2ZXNDYWNoZSA9IG5ldyBTZXQodGhpcy5wbHVnaW4uYXBwLndvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoJ3BkZicpKTtcclxuICAgICAgICAgICAgdGhpcy5tZW1vQ2FjaGUuc2V0KGNhY2hlS2V5LCB7IHZhbHVlOiBudWxsLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmFjdGl2ZUxlYXZlc0NhY2hlLmZvckVhY2gobGVhZiA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VzID0gdGhpcy5nZXRQREZQYWdlc0ZvckxlYWYobGVhZik7XHJcbiAgICAgICAgICAgIHBhZ2VzPy5mb3JFYWNoKHBhZ2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgcGFnZS5xdWVyeVNlbGVjdG9yQWxsKCcucGRmLXRleHQtb3ZlcmxheS1yZWZsb3cnKS5mb3JFYWNoKG92ZXJsYXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERlbGVnYXRlIHZpc2liaWxpdHkgdXBkYXRlIHRvIHVpUmVuZGVyZXJcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVpUmVuZGVyZXIuc2V0T3ZlcmxheUVsZW1lbnRWaXNpYmlsaXR5KG92ZXJsYXkgYXMgSFRNTEVsZW1lbnQsIHRoaXMuaXNPdmVybGF5VmlzaWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm90ZTogYWRqdXN0T3ZlcmxheUZvck92ZXJmbG93IGlzIG5vdyBoYW5kbGVkIGJ5IHVpUmVuZGVyZXIgYW5kIGlzIHByaXZhdGUgdGhlcmVcclxuICAgIC8vIE5vdGU6IHNldE92ZXJsYXlFbGVtZW50VmlzaWJpbGl0eSBpcyBub3cgaGFuZGxlZCBieSB1aVJlbmRlcmVyIGFuZCBpcyBwcml2YXRlIHRoZXJlXHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBHZXR0ZXJzICh3aXRoIG1lbW9pemF0aW9uKVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRNZW1vaXplZDxUPihrZXk6IHN0cmluZywgZm46ICgpID0+IFQsIHR0bDogbnVtYmVyID0gQ0FDSEVfVFRMKTogVCB7XHJcbiAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5tZW1vQ2FjaGUuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKGNhY2hlZCAmJiBEYXRlLm5vdygpIC0gY2FjaGVkLnRpbWVzdGFtcCA8IHR0bCkgcmV0dXJuIGNhY2hlZC52YWx1ZTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGZuKCk7XHJcbiAgICAgICAgdGhpcy5tZW1vQ2FjaGUuc2V0KGtleSwgeyB2YWx1ZSwgdGltZXN0YW1wOiBEYXRlLm5vdygpIH0pO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QWN0aXZlUERGTGVhZigpOiBhbnkgfCBudWxsIHtcclxuICAgICAgICBjb25zdCBhY3RpdmVMZWFmID0gdGhpcy5wbHVnaW4uYXBwLndvcmtzcGFjZS5hY3RpdmVMZWFmO1xyXG4gICAgICAgIHJldHVybiAoYWN0aXZlTGVhZj8udmlldz8uZ2V0Vmlld1R5cGUoKSA9PT0gJ3BkZicpID8gYWN0aXZlTGVhZiA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBERlBhZ2VzRm9yTGVhZihsZWFmOiBhbnkpOiBOb2RlTGlzdE9mPEhUTUxFbGVtZW50PiB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IHZpZXdlckNvbnRhaW5lciA9IGxlYWY/LnZpZXc/LmNvbnRhaW5lckVsPy5xdWVyeVNlbGVjdG9yKCcucGRmVmlld2VyLCAjdmlld2VyJykgYXMgSFRNTEVsZW1lbnQgfCBudWxsO1xyXG4gICAgICAgIHJldHVybiB2aWV3ZXJDb250YWluZXI/LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wYWdlW2RhdGEtcGFnZS1udW1iZXJdJykgfHwgbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0Q3VycmVudFBhZ2VFbGVtZW50KCk6IEhUTUxFbGVtZW50IHwgbnVsbCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWVtb2l6ZWQoJ2N1cnJlbnRQYWdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlTGVhZiA9IHRoaXMuZ2V0QWN0aXZlUERGTGVhZigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhY3RpdmVMZWFmKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VzID0gdGhpcy5nZXRQREZQYWdlc0ZvckxlYWYoYWN0aXZlTGVhZik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmlzaWJsZVBhZ2UocGFnZXMpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZygnZ2V0Q3VycmVudFBhZ2VFbGVtZW50IGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEN1cnJlbnRQYWdlVGV4dExheWVyKCk6IEhUTUxFbGVtZW50IHwgbnVsbCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWVtb2l6ZWQoJ2N1cnJlbnRUZXh0TGF5ZXInLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYWdlID0gdGhpcy5nZXRDdXJyZW50UGFnZUVsZW1lbnQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQYWdlID8gY3VycmVudFBhZ2UucXVlcnlTZWxlY3RvcignLnRleHRMYXllcicpIGFzIEhUTUxFbGVtZW50IDogbnVsbDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0Q3VycmVudFZpc2libGVQYWdlKHBhZ2VzOiBOb2RlTGlzdE9mPEhUTUxFbGVtZW50PiB8IG51bGwpOiBIVE1MRWxlbWVudCB8IG51bGwge1xyXG4gICAgICAgIGlmICghcGFnZXMgfHwgcGFnZXMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgbGV0IGJlc3RQYWdlOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xyXG4gICAgICAgIGxldCBtYXhWaXNpYmxlQXJlYSA9IC0xO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IHBhZ2Ugb2YgQXJyYXkuZnJvbShwYWdlcykpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHBhZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIGlmIChyZWN0LndpZHRoID09PSAwIHx8IHJlY3QuaGVpZ2h0ID09PSAwKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCB2aXNpYmxlVG9wID0gTWF0aC5tYXgoMCwgcmVjdC50b3ApO1xyXG4gICAgICAgICAgICBjb25zdCB2aXNpYmxlQm90dG9tID0gTWF0aC5taW4odmlld3BvcnRIZWlnaHQsIHJlY3QuYm90dG9tKTtcclxuICAgICAgICAgICAgY29uc3QgdmlzaWJsZUhlaWdodCA9IE1hdGgubWF4KDAsIHZpc2libGVCb3R0b20gLSB2aXNpYmxlVG9wKTtcclxuICAgICAgICAgICAgY29uc3QgdmlzaWJsZUFyZWEgPSB2aXNpYmxlSGVpZ2h0ICogcmVjdC53aWR0aDtcclxuXHJcbiAgICAgICAgICAgIGlmICh2aXNpYmxlQXJlYSA+IG1heFZpc2libGVBcmVhKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhWaXNpYmxlQXJlYSA9IHZpc2libGVBcmVhO1xyXG4gICAgICAgICAgICAgICAgYmVzdFBhZ2UgPSBwYWdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiZXN0UGFnZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIE92ZXJsYXkgQ3JlYXRpb24gJiBSZW5kZXJpbmdcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyB3YWl0Rm9yUGRmVGV4dExheWVyKHBhZ2VOdW1iZXI6IG51bWJlcik6IFByb21pc2U8SFRNTEVsZW1lbnQgfCBudWxsPiB7XHJcbiAgICAgICAgaWYgKHBhZ2VOdW1iZXIgPD0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKCd3YWl0Rm9yUGRmVGV4dExheWVyOiBJbnZhbGlkIHBhZ2UgbnVtYmVyJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhY3RpdmVMZWFmID0gdGhpcy5nZXRBY3RpdmVQREZMZWFmKCk7XHJcbiAgICAgICAgaWYgKCFhY3RpdmVMZWFmKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPiBPVkVSTEFZX1dBSVRfVElNRU9VVCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nRGVidWcoYFRpbWVvdXQgd2FpdGluZyBmb3IgdGV4dCBsYXllciBvbiBwYWdlICR7cGFnZU51bWJlcn1gKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VzID0gdGhpcy5nZXRQREZQYWdlc0ZvckxlYWYoYWN0aXZlTGVhZik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlID0gcGFnZXMgPyBBcnJheS5mcm9tKHBhZ2VzKS5maW5kKHAgPT4gcGFyc2VJbnQocC5kYXRhc2V0LnBhZ2VOdW1iZXIgfHwgJzAnKSA9PT0gcGFnZU51bWJlcikgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dExheWVyID0gcGFnZT8ucXVlcnlTZWxlY3RvcignLnRleHRMYXllcicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRleHRMYXllcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGV4dExheWVyIGFzIEhUTUxFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgT1ZFUkxBWV9DSEVDS19JTlRFUlZBTCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm90ZTogYnJpbmdUb1RvcCBpcyBub3cgaGFuZGxlZCBieSB1aVJlbmRlcmVyIGFuZCBpcyBwcml2YXRlIHRoZXJlXHJcbiAgICAvLyBOb3RlOiBjcmVhdGVSZWZsb3dPdmVybGF5IGlzIG5vdyBoYW5kbGVkIGJ5IHVpUmVuZGVyZXIgYW5kIGlzIHByaXZhdGUgdGhlcmVcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlciBhbGwgc2F2ZWQgb3ZlcmxheXMgb250byBhIHBhZ2UsIHVzaW5nIGEgc3RhZ2luZyBjb250YWluZXJcclxuICAgICAqIHRvIGJhdGNoIERPTSBtZWFzdXJlbWVudHMgYW5kIHJlZHVjZSBsYXlvdXQgdGhyYXNoaW5nLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcmVuZGVyU2F2ZWRPdmVybGF5KHBvc2l0aW9uRGF0YTogT3ZlcmxheVBvc2l0aW9uRGF0YVtdLCBwYWdlTnVtYmVyOiBudW1iZXIpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCB0ZXh0TGF5ZXIgPSBhd2FpdCB0aGlzLndhaXRGb3JQZGZUZXh0TGF5ZXIocGFnZU51bWJlcik7XHJcbiAgICAgICAgICAgIGlmICghdGV4dExheWVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKGBDYW5ub3QgcmVuZGVyIG92ZXJsYXkgXHUyMDEzIG5vIHRleHRMYXllciBmb3IgcGFnZSAke3BhZ2VOdW1iZXJ9YCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VFbGVtZW50ID0gdGV4dExheWVyLmNsb3Nlc3QoJy5wYWdlJykgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmICghcGFnZUVsZW1lbnQpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRleHRMYXllciBkaW1lbnNpb25zIHRvIGJlY29tZSB2YWxpZFxyXG4gICAgICAgICAgICBsZXQgcmV0cmllcyA9IDA7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0TGF5ZXJSZWN0ID0gdGV4dExheWVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICB3aGlsZSAoKHRleHRMYXllclJlY3Qud2lkdGggPT09IDAgfHwgdGV4dExheWVyUmVjdC5oZWlnaHQgPT09IDApICYmIHJldHJpZXMgPCBNQVhfRElNRU5TSU9OX1JFVFJJRVMpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCBSRVRSWV9ERUxBWSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0cmllcysrO1xyXG4gICAgICAgICAgICAgICAgdGV4dExheWVyUmVjdCA9IHRleHRMYXllci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGV4dExheWVyUmVjdC53aWR0aCA9PT0gMCB8fCB0ZXh0TGF5ZXJSZWN0LmhlaWdodCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgVGV4dExheWVyIHN0aWxsIHVuYXZhaWxhYmxlIGZvciBwYWdlICR7cGFnZU51bWJlcn0gYWZ0ZXIgJHtyZXRyaWVzfSByZXRyaWVzYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSBvdmVybGF5IGNvbnRhaW5lclxyXG4gICAgICAgICAgICBjb25zdCBvdmVybGF5Q29udGFpbmVyID0gdGhpcy5wcmVwYXJlUGFnZUZvck92ZXJsYXkocGFnZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBmYWxsYmFja1JlZiA9ICh0ZXh0TGF5ZXIucXVlcnlTZWxlY3Rvcignc3BhbicpIGFzIEhUTUxTcGFuRWxlbWVudCkgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG5cclxuICAgICAgICAgICAgLy8gLS0tIEJhdGNoaW5nIG9wdGltaXphdGlvbiAtLS1cclxuICAgICAgICAgICAgY29uc3Qgc3RhZ2luZ0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBzdGFnaW5nQ29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgICAgICAgICAgICB0b3A6IC05OTk5OXB4O1xyXG4gICAgICAgICAgICAgICAgbGVmdDogLTk5OTk5cHg7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW47XHJcbiAgICAgICAgICAgIGA7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhZ2luZ0NvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBvdmVybGF5czogSFRNTEVsZW1lbnRbXSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RlcCAxOiBDcmVhdGUgYWxsIG92ZXJsYXlzIGFuZCBwdXQgdGhlbSBpbiBzdGFnaW5nIGNvbnRhaW5lclxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRhdGEgb2YgcG9zaXRpb25EYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlWCA9IHRleHRMYXllclJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVZID0gdGV4dExheWVyUmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWJzb2x1dGVSZWN0ID0gbmV3IERPTVJlY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmVsYXRpdmVSZWN0LmxlZnQgKiBzY2FsZVgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmVsYXRpdmVSZWN0LnRvcCAqIHNjYWxlWSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yZWxhdGl2ZVJlY3Qud2lkdGggKiBzY2FsZVgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmVsYXRpdmVSZWN0LmhlaWdodCAqIHNjYWxlWVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBuZWNlc3Nhcnkgc2V0dGluZ3MgdG8gdWlSZW5kZXJlclxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlFbCA9IHRoaXMudWlSZW5kZXJlci5jcmVhdGVSZWZsb3dPdmVybGF5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVJlY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudHJhbnNsYXRlZFRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrUmVmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm9yaWdpbmFsRm9udFNpemVzIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRleHRDb250ZW50IHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vdmVybGF5T3BhY2l0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3V0cHV0Rm9udFNpemVTY2FsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3V0cHV0TGluZUhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0S25vd25TY2FsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5mb250RmFtaWx5XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFnaW5nQ29udGFpbmVyLmFwcGVuZENoaWxkKG92ZXJsYXlFbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheXMucHVzaChvdmVybGF5RWwpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoaXRlbUVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgRXJyb3Igc3RhZ2luZyBvdmVybGF5IGZvciBwYWdlICR7cGFnZU51bWJlcn1gLCBpdGVtRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdGVwIDI6IEJhdGNoIG1lYXN1cmUgJiBhZGp1c3QgZm9yIG92ZXJmbG93XHJcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KHJlc29sdmUgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZWwgb2Ygb3ZlcmxheXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIHRoZSBjdXJyZW50IGdsb2JhbCBsaW5lIGhlaWdodCBzZXR0aW5nIHRvIHRoZSBhZGp1c3RtZW50IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51aVJlbmRlcmVyLmFkanVzdE92ZXJsYXlGb3JPdmVyZmxvdyhlbCwgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3V0cHV0TGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN0ZXAgMzogTW92ZSBmaW5pc2hlZCBvdmVybGF5cyBpbnRvIHRoZSBhY3R1YWwgb3ZlcmxheSBjb250YWluZXJcclxuICAgICAgICAgICAgZm9yIChjb25zdCBlbCBvZiBvdmVybGF5cykge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxheUNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIHN0YWdpbmcgY29udGFpbmVyXHJcbiAgICAgICAgICAgIHN0YWdpbmdDb250YWluZXIucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBNYXJrIGFzIGxvYWRlZFxyXG4gICAgICAgICAgICB0aGlzLmxvYWRlZE92ZXJsYXlQYWdlcy5hZGQocGFnZU51bWJlcik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKGBSZW5kZXJlZCBzYXZlZCBvdmVybGF5IGZvciBwYWdlICR7cGFnZU51bWJlcn0gKCR7b3ZlcmxheXMubGVuZ3RofSBpdGVtcylgKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmNsYW1wQWxsQmJveFBvc2l0aW9ucygpLCA1MCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgcmVuZGVyU2F2ZWRPdmVybGF5IGZhaWxlZCBmb3IgcGFnZSAke3BhZ2VOdW1iZXJ9OmAsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBMb2FkaW5nICYgU2F2aW5nIChFTkhBTkNFRCB3aXRoIGJldHRlciBzdGF0ZSB0cmFja2luZylcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBsb2FkU2F2ZWRPdmVybGF5Rm9yUGFnZShwYWdlTnVtYmVyOiBudW1iZXIsIGZvcmNlOiBib29sZWFuID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2FjaGVkT3ZlcmxheURhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgTm8gY2FjaGVkIG92ZXJsYXkgZGF0YSBhdmFpbGFibGUgZm9yIHBhZ2UgJHtwYWdlTnVtYmVyfWApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5pbkZsaWdodFBhZ2VMb2Fkcy5oYXMocGFnZU51bWJlcikgJiYgIWZvcmNlKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5GbGlnaHRQYWdlTG9hZHMuZ2V0KHBhZ2VOdW1iZXIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBsb2FkUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlRGF0YSA9IHRoaXMuY2FjaGVkT3ZlcmxheURhdGEhLnBhZ2VPdmVybGF5c1twYWdlTnVtYmVyXTtcclxuICAgICAgICAgICAgICAgIGlmICghcGFnZURhdGEgfHwgcGFnZURhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgTm8gb3ZlcmxheSBkYXRhIGZvciBwYWdlICR7cGFnZU51bWJlcn1gKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dExheWVyID0gYXdhaXQgdGhpcy53YWl0Rm9yUGRmVGV4dExheWVyKHBhZ2VOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0ZXh0TGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKGBObyB0ZXh0IGxheWVyIGZvdW5kIGZvciBwYWdlICR7cGFnZU51bWJlcn1gKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFnZUVsZW1lbnQgPSB0ZXh0TGF5ZXIuY2xvc2VzdCgnLnBhZ2UnKSBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGlmICghcGFnZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKGBObyBwYWdlIGVsZW1lbnQgZm91bmQgZm9yIHBhZ2UgJHtwYWdlTnVtYmVyfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNPdmVybGF5ID0gcGFnZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLnBkZi10ZXh0LW92ZXJsYXktcmVmbG93JykgIT09IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0xvYWRlZCA9IHRoaXMubG9hZGVkT3ZlcmxheVBhZ2VzLmhhcyhwYWdlTnVtYmVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3ZlcmxheSAmJiBpc0xvYWRlZCAmJiAhZm9yY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIEFscmVhZHkgcHJvcGVybHkgbG9hZGVkXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhck92ZXJsYXlGcm9tUGFnZShwYWdlRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgTG9hZGluZyBvdmVybGF5cyBmb3IgcGFnZSAke3BhZ2VOdW1iZXJ9YCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlclNhdmVkT3ZlcmxheShwYWdlRGF0YSwgcGFnZU51bWJlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgcmVsZXZhbnQgbWVtb2l6YXRpb24gY2FjaGVcclxuICAgICAgICAgICAgICAgIHRoaXMubWVtb0NhY2hlLmRlbGV0ZSgnY3VycmVudFBhZ2UnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWVtb0NhY2hlLmRlbGV0ZSgnY3VycmVudFRleHRMYXllcicpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZyhgRXJyb3IgbG9hZGluZyBvdmVybGF5IGZvciBwYWdlICR7cGFnZU51bWJlcn06YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZWRPdmVybGF5UGFnZXMuZGVsZXRlKHBhZ2VOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSgpO1xyXG5cclxuICAgICAgICB0aGlzLmluRmxpZ2h0UGFnZUxvYWRzLnNldChwYWdlTnVtYmVyLCBsb2FkUHJvbWlzZSk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgbG9hZFByb21pc2U7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdGhpcy5pbkZsaWdodFBhZ2VMb2Fkcy5kZWxldGUocGFnZU51bWJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBsb2FkU2F2ZWRPdmVybGF5Rm9yQ3VycmVudFBhZ2UoZm9yY2VSZWxvYWQ6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VOdW1iZXIgPSB0aGlzLnBsdWdpbi5nZXRDdXJyZW50UGFnZU51bWJlcigpO1xyXG4gICAgICAgICAgICBpZiAocGFnZU51bWJlciA9PT0gbnVsbCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcGFnZUVsZW1lbnQgPSB0aGlzLmdldEN1cnJlbnRQYWdlRWxlbWVudCgpO1xyXG4gICAgICAgICAgICBpZiAoIXBhZ2VFbGVtZW50KSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAoZm9yY2VSZWxvYWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJPdmVybGF5RnJvbVBhZ2UocGFnZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBoYXNPdmVybGF5ID0gcGFnZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLnBkZi10ZXh0LW92ZXJsYXktY29udGFpbmVyJykgIT09IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzTG9hZGVkID0gdGhpcy5sb2FkZWRPdmVybGF5UGFnZXMuaGFzKHBhZ2VOdW1iZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGhhc092ZXJsYXkgJiYgaXNMb2FkZWQgJiYgIWZvcmNlUmVsb2FkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEFscmVhZHkgbG9hZGVkIGFuZCBub3QgZm9yY2luZyByZWxvYWRcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgYWN0aXZlRmlsZSA9IHRoaXMuZ2V0QWN0aXZlUERGTGVhZigpPy52aWV3LmZpbGU7XHJcbiAgICAgICAgICAgIGlmIChhY3RpdmVGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVPdmVybGF5U3RhdGVGb3JQZGYoYWN0aXZlRmlsZSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmxvYWRTYXZlZE92ZXJsYXlGb3JQYWdlKHBhZ2VOdW1iZXIsIGZvcmNlUmVsb2FkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nRGVidWcoJ2xvYWRTYXZlZE92ZXJsYXlGb3JDdXJyZW50UGFnZSBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZXh0cmFjdEN1cnJlbnRPdmVybGF5UGFyYW1ldGVycygpOiBQcm9taXNlPHtcclxuICAgICAgICBwb3NpdGlvbkRhdGE6IE92ZXJsYXlQb3NpdGlvbkRhdGFbXTtcclxuICAgICAgICBwYWdlTnVtYmVyOiBudW1iZXI7XHJcbiAgICAgICAgaGFzRGF0YTogYm9vbGVhbjtcclxuICAgIH0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UGFnZU51bWJlciA9IHRoaXMucGx1Z2luLmdldEN1cnJlbnRQYWdlTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFnZU51bWJlciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcG9zaXRpb25EYXRhOiBbXSwgcGFnZU51bWJlcjogMCwgaGFzRGF0YTogZmFsc2UgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgdGV4dExheWVyID0gdGhpcy5nZXRDdXJyZW50UGFnZVRleHRMYXllcigpO1xyXG4gICAgICAgICAgICBjb25zdCBvdmVybGF5Q29udGFpbmVyID0gdGV4dExheWVyPy5jbG9zZXN0KCcucGFnZScpPy5xdWVyeVNlbGVjdG9yKCcucGRmLXRleHQtb3ZlcmxheS1jb250YWluZXInKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGV4dExheWVyIHx8ICFvdmVybGF5Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBwb3NpdGlvbkRhdGE6IFtdLCBwYWdlTnVtYmVyOiBjdXJyZW50UGFnZU51bWJlciwgaGFzRGF0YTogZmFsc2UgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHRleHRMYXllclJlY3QgPSB0ZXh0TGF5ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIGxldCByZXRyaWVzID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKCh0ZXh0TGF5ZXJSZWN0LndpZHRoID09PSAwIHx8IHRleHRMYXllclJlY3QuaGVpZ2h0ID09PSAwKSAmJiByZXRyaWVzIDwgRVhUUkFDVF9NQVhfUkVUUklFUykge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIEVYVFJBQ1RfUkVUUllfSU5URVJWQUwpKTtcclxuICAgICAgICAgICAgICAgIHJldHJpZXMrKztcclxuICAgICAgICAgICAgICAgIGlmIChyZXRyaWVzICUgNSA9PT0gMCkgdGhpcy5sb2dEZWJ1ZyhgRXh0cmFjdCByZXRyeSAke3JldHJpZXN9LyR7RVhUUkFDVF9NQVhfUkVUUklFU30gZm9yIGRpbXNgKTtcclxuICAgICAgICAgICAgICAgIHRleHRMYXllclJlY3QgPSB0ZXh0TGF5ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRleHRMYXllclJlY3Qud2lkdGggPT09IDAgfHwgdGV4dExheWVyUmVjdC5oZWlnaHQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nRGVidWcoJ0V4dHJhY3Rpb24gZmFpbGVkOiBUZXh0IGxheWVyIGRpbXMgc3RpbGwgemVybyBhZnRlciByZXRyaWVzLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcG9zaXRpb25EYXRhOiBbXSwgcGFnZU51bWJlcjogY3VycmVudFBhZ2VOdW1iZXIsIGhhc0RhdGE6IGZhbHNlIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uRGF0YSA9IHRoaXMuZXh0cmFjdFBvc2l0aW9uRGF0YUZyb20odGV4dExheWVyLCBvdmVybGF5Q29udGFpbmVyLCB0ZXh0TGF5ZXJSZWN0KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkRhdGEsXHJcbiAgICAgICAgICAgICAgICBwYWdlTnVtYmVyOiBjdXJyZW50UGFnZU51bWJlcixcclxuICAgICAgICAgICAgICAgIGhhc0RhdGE6IHBvc2l0aW9uRGF0YS5sZW5ndGggPiAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZygnZXh0cmFjdEN1cnJlbnRPdmVybGF5UGFyYW1ldGVycyBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4geyBwb3NpdGlvbkRhdGE6IFtdLCBwYWdlTnVtYmVyOiAwLCBoYXNEYXRhOiBmYWxzZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGV4dHJhY3RQb3NpdGlvbkRhdGFGcm9tKHRleHRMYXllcjogSFRNTEVsZW1lbnQsIG92ZXJsYXlDb250YWluZXI6IEVsZW1lbnQsIHRleHRMYXllclJlY3Q6IERPTVJlY3QpOiBPdmVybGF5UG9zaXRpb25EYXRhW10ge1xyXG4gICAgICAgIGlmICghdGV4dExheWVyIHx8ICFvdmVybGF5Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uRGF0YTogT3ZlcmxheVBvc2l0aW9uRGF0YVtdID0gW107XHJcbiAgICAgICAgY29uc3Qgb3ZlcmxheXMgPSBvdmVybGF5Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGw8SFRNTEVsZW1lbnQ+KCcucGRmLXRleHQtb3ZlcmxheS1yZWZsb3cnKTtcclxuICAgICAgICBjb25zdCBwYWdlTnVtYmVyID0gdGhpcy5wbHVnaW4uZ2V0Q3VycmVudFBhZ2VOdW1iZXIoKSA/PyAwO1xyXG5cclxuICAgICAgICBjb25zdCBwZGZWaWV3ZXIgPSB0ZXh0TGF5ZXIuY2xvc2VzdCgnLnBkZlZpZXdlciwgI3ZpZXdlcicpIGFzIEhUTUxFbGVtZW50IHwgbnVsbDtcclxuICAgICAgICBjb25zdCBzYXZlU2NhbGUgPSBwYXJzZUZsb2F0KHBkZlZpZXdlcj8uc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnLS1zY2FsZS1mYWN0b3InKSB8fCAnMScpO1xyXG4gICAgICAgIGlmIChpc05hTihzYXZlU2NhbGUpIHx8IHNhdmVTY2FsZSA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nRGVidWcoJ0ludmFsaWQgc2F2ZVNjYWxlOyBmYWxsaW5nIGJhY2sgdG8gMS4wJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IG92ZXJsYXkgb2Ygb3ZlcmxheXMpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBvdmVybGF5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVSZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IChyZWN0LmxlZnQgLSB0ZXh0TGF5ZXJSZWN0LmxlZnQpIC8gdGV4dExheWVyUmVjdC53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IChyZWN0LnRvcCAtIHRleHRMYXllclJlY3QudG9wKSAvIHRleHRMYXllclJlY3QuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoIC8gdGV4dExheWVyUmVjdC53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0IC8gdGV4dExheWVyUmVjdC5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBvcmlnaW5hbEZvbnRTaXplczogbnVtYmVyW10gPSBbXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplc0F0dHIgPSBvdmVybGF5LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC1mb250LXNpemVzJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm9udFNpemVzQXR0cikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRm9udFNpemVzID0gSlNPTi5wYXJzZShmb250U2l6ZXNBdHRyKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nRGVidWcoXCJDb3VsZCBub3QgcGFyc2UgZm9udCBzaXplcyBmcm9tIGF0dHJpYnV0ZVwiLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVGb250U2l6ZXM6IG51bWJlcltdID0gb3JpZ2luYWxGb250U2l6ZXMubGVuZ3RoID4gMCAmJiBzYXZlU2NhbGUgPiAwXHJcbiAgICAgICAgICAgICAgICAgICAgPyBvcmlnaW5hbEZvbnRTaXplcy5tYXAoZnMgPT4gZnMgLyBzYXZlU2NhbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkRhdGEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb250ZW50OiBvdmVybGF5LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10ZXh0JykgfHwgJycsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZFRleHQ6IG92ZXJsYXkucXVlcnlTZWxlY3RvcignZGl2Jyk/LmlubmVySFRNTCB8fCBvdmVybGF5LnRleHRDb250ZW50IHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUmVjdCxcclxuICAgICAgICAgICAgICAgICAgICBwYWdlOiBwYWdlTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRm9udFNpemVzOiByZWxhdGl2ZUZvbnRTaXplcyxcclxuICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBvdmVybGF5LnN0eWxlLmZvbnRGYW1pbHkgfHwgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGl0ZW1FcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dEZWJ1ZygnZXh0cmFjdFBvc2l0aW9uRGF0YUZyb20gaXRlbSBlcnJvcjonLCBpdGVtRXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcG9zaXRpb25EYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzYXZlQ3VycmVudFBhZ2VPdmVybGF5KCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUZpbGUgPSB0aGlzLmdldEFjdGl2ZVBERkxlYWYoKT8udmlldz8uZmlsZTtcclxuICAgICAgICAgICAgaWYgKCFhY3RpdmVGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKCdDYW5ub3Qgc2F2ZSBvdmVybGF5LCBubyBhY3RpdmUgUERGIGZpbGUuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IGF3YWl0IHRoaXMuZXh0cmFjdEN1cnJlbnRPdmVybGF5UGFyYW1ldGVycygpO1xyXG4gICAgICAgICAgICBpZiAoIWV4dHJhY3RlZC5oYXNEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKCdObyBvdmVybGF5IGRhdGEgZm91bmQgb24gdGhlIGN1cnJlbnQgcGFnZSB0byBzYXZlLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwYWdlc1RvVXBkYXRlID0geyBbZXh0cmFjdGVkLnBhZ2VOdW1iZXJdOiBleHRyYWN0ZWQucG9zaXRpb25EYXRhIH07XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnN0b3JhZ2UudXBkYXRlUGFnZU92ZXJsYXlzQW5kV3JpdGUoYWN0aXZlRmlsZSwgcGFnZXNUb1VwZGF0ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBLZWVwIHJ1bnRpbWUgc3RhdGUgaW4gc3luY1xyXG4gICAgICAgICAgICB0aGlzLnBhZ2VzV2l0aE92ZXJsYXlzLmFkZChleHRyYWN0ZWQucGFnZU51bWJlcik7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVkT3ZlcmxheVBhZ2VzLmFkZChleHRyYWN0ZWQucGFnZU51bWJlcik7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZWRPdmVybGF5RGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRPdmVybGF5RGF0YSA9IHsgZmlsZVBhdGg6IGFjdGl2ZUZpbGUucGF0aCwgcGFnZU92ZXJsYXlzOiB7fSB9IGFzIFNhdmVkT3ZlcmxheTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNhY2hlZE92ZXJsYXlEYXRhLnBhZ2VPdmVybGF5c1tleHRyYWN0ZWQucGFnZU51bWJlcl0gPSBleHRyYWN0ZWQucG9zaXRpb25EYXRhO1xyXG5cclxuICAgICAgICAgICAgbmV3IE5vdGljZShgU2F2ZWQgb3ZlcmxheSBmb3IgcGFnZSAke2V4dHJhY3RlZC5wYWdlTnVtYmVyfWApO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ0RlYnVnKCdzYXZlQ3VycmVudFBhZ2VPdmVybGF5IGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0Vycm9yIHNhdmluZyBvdmVybGF5IGRhdGEuJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm90ZTogYWRqdXN0U2luZ2xlT3ZlcmxheUxpbmVIZWlnaHQgYW5kIGFkanVzdFNpbmdsZU92ZXJsYXlGb250U2l6ZSBhcmUgbm93IGhhbmRsZWQgYnkgdWlSZW5kZXJlciBhbmQgYXJlIHByaXZhdGUgdGhlcmVcclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIENsZWFudXAgKEVOSEFOQ0VEIHdpdGggYmV0dGVyIHN0YXRlIHRyYWNraW5nKVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgLy8gTm90ZTogY2xlYW51cEhvdmVySGFuZGxlcnMgYW5kIGNsZWFudXBPdmVybGF5RWxlbWVudCBhcmUgbm93IGhhbmRsZWQgYnkgdWlSZW5kZXJlciBhbmQgYXJlIHByaXZhdGUgdGhlcmVcclxuICAgIC8vIFRoZSBtYWluIGNsZWFudXBPdmVybGF5RWxlbWVudCBpcyBub3cgYSBkZWxlZ2F0ZSBjYWxsIHRvIHVpUmVuZGVyZXIuY2xlYW51cE92ZXJsYXlFbGVtZW50XHJcblxyXG4gICAgcHVibGljIGNsZWFudXBNb25pdG9yaW5nKCkge1xyXG4gICAgICAgIHRoaXMucGFnZU9ic2VydmVyPy5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgdGhpcy5wYWdlT2JzZXJ2ZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuem9vbU9ic2VydmVyPy5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgdGhpcy56b29tT2JzZXJ2ZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGFnZUludGVyc2VjdGlvbk9ic2VydmVyPy5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgdGhpcy5wYWdlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zY3JvbGxhYmxlQ29udGFpbmVyICYmIHRoaXMuc2Nyb2xsSGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbGFibGVDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5zY3JvbGxIYW5kbGVyKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxhYmxlQ29udGFpbmVyID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsZWFyIGFsbCB0aW1lb3V0c1xyXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFRocm90dGxlVGltZW91dCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zY3JvbGxUaHJvdHRsZVRpbWVvdXQpO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRocm90dGxlVGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnpvb21EZWJvdW5jZVRpbWVvdXQpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuem9vbURlYm91bmNlVGltZW91dCk7XHJcbiAgICAgICAgICAgIHRoaXMuem9vbURlYm91bmNlVGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXNldCBzdGF0ZSB0cmFja2luZ1xyXG4gICAgICAgIHRoaXMubG9hZGVkT3ZlcmxheVBhZ2VzLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5pc1Njcm9sbFNhZmVndWFyZFJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxhc3RTY3JvbGxDaGVjayA9IDA7XHJcbiAgICAgICAgdGhpcy5sYXN0UXVpY2tDaGVjayA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNsZWFudXAoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhbnVwTW9uaXRvcmluZygpO1xyXG4gICAgICAgIC8vIFRoZSBtYWluIGNsZWFudXAgZm9yIGluZGl2aWR1YWwgb3ZlcmxheSBlbGVtZW50cyBpcyBoYW5kbGVkIGJ5IHVpUmVuZGVyZXJcclxuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGl0ZXJhdGUgYW5kIGNhbGwgdWlSZW5kZXJlci5jbGVhbnVwT3ZlcmxheUVsZW1lbnQgaGVyZVxyXG4gICAgICAgIC8vIGFzIHVpUmVuZGVyZXIgbWFuYWdlcyBpdHMgb3duIHNldCBvZiB0cmFja2VkIGVsZW1lbnRzLlxyXG4gICAgICAgIC8vIFdlIGp1c3QgbmVlZCB0byB0ZWxsIHVpUmVuZGVyZXIgdG8gY2xlYXIgaXRzIHN0YXRlLlxyXG4gICAgICAgIHRoaXMudWlSZW5kZXJlci5jbGVhbnVwKCk7XHJcbiAgICAgICAgdGhpcy5tZW1vQ2FjaGUuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUxlYXZlc0NhY2hlID0gbnVsbDtcclxuICAgICAgICAvLyB0ZW1wRGl2IGlzIG5vdyBtYW5hZ2VkIGJ5IHVpUmVuZGVyZXIsIHNvIG5vIG5lZWQgdG8gY2xlYXIgaXQgaGVyZSBpZiBpdCB3YXMgb25seSB1c2VkIGZvciB0ZXh0IGV4dHJhY3Rpb25cclxuICAgICAgICAvLyB0aGlzLnRlbXBEaXYgPSBudWxsOyAvLyBDb21tZW50ZWQgb3V0IGlmIHRlbXBEaXYgaXMgb25seSBpbiB1aVJlbmRlcmVyXHJcblxyXG4gICAgICAgIC8vIFJlc2V0IGFsbCBzdGF0ZVxyXG4gICAgICAgIHRoaXMuY2FjaGVkT3ZlcmxheURhdGEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGFnZXNXaXRoT3ZlcmxheXMuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmxvYWRlZE92ZXJsYXlQYWdlcy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuaW5GbGlnaHRQYWdlTG9hZHMuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3RlOiBzaG93Q29udGV4dE1lbnUgaXMgbm93IGhhbmRsZWQgYnkgdWlSZW5kZXJlciBhbmQgaXMgcHJpdmF0ZSB0aGVyZVxyXG4gICAgLy8gSWYgdGhlIGNvbnRleHQgbWVudSBsb2dpYyBuZWVkcyB0byBiZSB0cmlnZ2VyZWQgZnJvbSBoZXJlLCBpdCBzaG91bGQgYmUgZG9uZVxyXG4gICAgLy8gYnkgY2FsbGluZyBhIG1ldGhvZCBvbiB1aVJlbmRlcmVyIHRoYXQgcmVjZWl2ZXMgdGhlIHJlcXVpcmVkIGNvbnRleHQuXHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBMb2dnaW5nIFV0aWxpdHlcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIHByaXZhdGUgbG9nRGVidWcobWVzc2FnZTogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHByZWZpeGVkID0gYFtPdmVybGF5UmVuZGVyZXJdICR7bWVzc2FnZX1gO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wbHVnaW4ubG9nRGVidWcgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4ubG9nRGVidWcocHJlZml4ZWQsIC4uLmFyZ3MpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wbHVnaW4uc2V0dGluZ3M/LmRlYnVnTW9kZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhwcmVmaXhlZCwgLi4uYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwgIi8vIG92ZXJsYXktdWkudHNcclxuLy8gRXh0cmFjdGVkIFVJIGFuZCBSZW5kZXJpbmcgbG9naWMgZm9yIFBERiBUcmFuc2xhdGlvbiBPdmVybGF5c1xyXG5cclxuaW1wb3J0IHsgTWVudSwgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgdHlwZSBPcGVuUm91dGVyVHJhbnNsYXRvclBsdWdpbiBmcm9tICcuL21haW4nOyAvLyBBZGp1c3QgcGF0aCBpZiBuZWVkZWRcclxuaW1wb3J0IHR5cGUgeyBPdmVybGF5UG9zaXRpb25EYXRhLCBTYXZlZE92ZXJsYXkgfSBmcm9tICcuL3R5cGVzJzsgLy8gQWRqdXN0IHBhdGggaWYgbmVlZGVkXHJcbmltcG9ydCB7IFJldHJhbnNsYXRlVXNpbmdPdmVybGF5c01vZGFsIH0gZnJvbSAnLi9tb2RhbC1yZXRyYW5zbGF0ZSc7IC8vIEFkanVzdCBwYXRoIGlmIG5lZWRlZFxyXG5cclxuLy8gQ29uc3RhbnRzIHJlbGV2YW50IHRvIFVJXHJcbmNvbnN0IExJTkVfSEVJR0hUX01JTiA9IDAuODtcclxuY29uc3QgTElORV9IRUlHSFRfTUFYID0gMi4wO1xyXG5jb25zdCBMSU5FX0hFSUdIVF9TVEVQID0gMC4xO1xyXG5cclxuLy8gVHlwZXMgZm9yIGludGVybmFsIHN0YXRlIChpZiBub3QgYWxyZWFkeSBkZWZpbmVkIGVsc2V3aGVyZSlcclxudHlwZSBPdmVybGF5SGFuZGxlcnMgPSB7XHJcbiAgICBjb250ZXh0SGFuZGxlcjogRXZlbnRMaXN0ZW5lcjtcclxuICAgIGhvdmVySGFuZGxlcnM/OiB7IHNob3c6IEV2ZW50TGlzdGVuZXI7IGhpZGU6IEV2ZW50TGlzdGVuZXIgfTtcclxuICAgIGJyaW5nVG9Ub3BIYW5kbGVyPzogRXZlbnRMaXN0ZW5lcjtcclxuICAgIHJlc2V0WkluZGV4SGFuZGxlcj86IEV2ZW50TGlzdGVuZXI7XHJcbn07XHJcblxyXG4vKipcclxuICogSGFuZGxlcyB0aGUgdmlzdWFsIHJlbmRlcmluZywgc3R5bGluZywgYW5kIHVzZXIgaW50ZXJhY3Rpb24gYXNwZWN0cyBvZiBQREYgdHJhbnNsYXRpb24gb3ZlcmxheXMuXHJcbiAqIFRoaXMgY2xhc3MgZm9jdXNlcyBvbiB0aGUgVUkgZWxlbWVudHMgdGhlbXNlbHZlcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBPdmVybGF5VUlSZW5kZXJlciB7XHJcbiAgICBwcml2YXRlIHBsdWdpbjogT3BlblJvdXRlclRyYW5zbGF0b3JQbHVnaW47XHJcblxyXG4gICAgLy8gU3RhdGUgYW5kIGNhY2hlcyBmb3IgVUkgZWxlbWVudHNcclxuICAgIHByaXZhdGUgY3JlYXRlZE92ZXJsYXlzOiBXZWFrTWFwPEhUTUxFbGVtZW50LCBPdmVybGF5SGFuZGxlcnM+ID0gbmV3IFdlYWtNYXAoKTtcclxuICAgIHByaXZhdGUgdHJhY2tlZE92ZXJsYXlFbGVtZW50czogU2V0PEhUTUxFbGVtZW50PiA9IG5ldyBTZXQoKTtcclxuICAgIHByaXZhdGUgdGVtcERpdjogSFRNTERpdkVsZW1lbnQgfCBudWxsID0gbnVsbDsgLy8gRm9yIGVmZmljaWVudCBIVE1MIHRvIHRleHQgY29udmVyc2lvblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBsdWdpbjogT3BlblJvdXRlclRyYW5zbGF0b3JQbHVnaW4pIHtcclxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICAgIH1cclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFB1YmxpYyBBUEkgZm9yIE92ZXJsYXlSZW5kZXJlciAob3Igb3RoZXIgbWFuYWdlcnMpXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIERPTSBlbGVtZW50IGZvciBhbiBvdmVybGF5IGJ1dCBkb2VzIE5PVFxyXG4gICAgICogZG8gZXhwZW5zaXZlIG1lYXN1cmluZy9hZGp1c3RtZW50cyAodGhhdCdzIGhhbmRsZWQgc2VwYXJhdGVseSBvciBieSBtYW5hZ2VyKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNyZWF0ZVJlZmxvd092ZXJsYXkoXHJcbiAgICAgICAgcmVjdDogRE9NUmVjdCxcclxuICAgICAgICBodG1sVGV4dDogc3RyaW5nLFxyXG4gICAgICAgIHJlZmVyZW5jZVNwYW46IEhUTUxTcGFuRWxlbWVudCxcclxuICAgICAgICBvcmlnaW5hbEZvbnRTaXplczogbnVtYmVyW10sXHJcbiAgICAgICAgcGFnZU51bWJlcjogbnVtYmVyLFxyXG4gICAgICAgIG9yaWdpbmFsVGV4dENvbnRlbnQ6IHN0cmluZyxcclxuICAgICAgICBvdmVybGF5T3BhY2l0eTogbnVtYmVyLFxyXG4gICAgICAgIG91dHB1dEZvbnRTaXplU2NhbGU6IG51bWJlcixcclxuICAgICAgICBvdXRwdXRMaW5lSGVpZ2h0OiBudW1iZXIsXHJcbiAgICAgICAgbGFzdEtub3duU2NhbGU6IG51bWJlcixcclxuICAgICAgICBmb250RmFtaWx5Pzogc3RyaW5nXHJcbiAgICApOiBIVE1MRWxlbWVudCB7XHJcbiAgICAgICAgaWYgKCFyZWN0IHx8IHJlY3Qud2lkdGggPD0gMCB8fCByZWN0LmhlaWdodCA8PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1tPdmVybGF5VUlSZW5kZXJlcl0gY3JlYXRlUmVmbG93T3ZlcmxheTogSW52YWxpZCByZWN0Jyk7XHJcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gJ3BkZi10ZXh0LW92ZXJsYXktcmVmbG93JztcclxuXHJcbiAgICAgICAgY29uc3QgYXZnT3JpZ2luYWxGb250U2l6ZSA9IG9yaWdpbmFsRm9udFNpemVzLmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgPyBvcmlnaW5hbEZvbnRTaXplcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIG9yaWdpbmFsRm9udFNpemVzLmxlbmd0aFxyXG4gICAgICAgICAgICA6IHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUocmVmZXJlbmNlU3BhbikuZm9udFNpemUpIHx8IDEyO1xyXG4gICAgICAgIGNvbnN0IGJhc2VGb250U2l6ZSA9IGF2Z09yaWdpbmFsRm9udFNpemUgKiBvdXRwdXRGb250U2l6ZVNjYWxlO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRGb250U2l6ZSA9IGJhc2VGb250U2l6ZSAqIGxhc3RLbm93blNjYWxlO1xyXG5cclxuICAgICAgICBPYmplY3QuYXNzaWduKGVsLnN0eWxlLCB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICBsZWZ0OiBgJHtyZWN0LmxlZnR9cHhgLFxyXG4gICAgICAgICAgICB0b3A6IGAke3JlY3QudG9wfXB4YCxcclxuICAgICAgICAgICAgd2lkdGg6IGAke3JlY3Qud2lkdGh9cHhgLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGAke3JlY3QuaGVpZ2h0fXB4YCxcclxuICAgICAgICAgICAgZm9udFNpemU6IGAke2N1cnJlbnRGb250U2l6ZX1weGAsXHJcbiAgICAgICAgICAgIG92ZXJmbG93OiAnYXV0bycsXHJcbiAgICAgICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxyXG4gICAgICAgICAgICB6SW5kZXg6ICcxMDEnLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1vdmVybGF5LW9wYWNpdHknLCBgJHtvdmVybGF5T3BhY2l0eX1gKTtcclxuICAgICAgICB0aGlzLnNldE92ZXJsYXlFbGVtZW50VmlzaWJpbGl0eShlbCwgdHJ1ZSk7IC8vIEFzc3VtaW5nIHZpc2libGUgYnkgZGVmYXVsdCBoZXJlLCBtYW5hZ2VyIGhhbmRsZXMgdG9nZ2xpbmdcclxuXHJcbiAgICAgICAgaWYgKGZvbnRGYW1pbHkpIHtcclxuICAgICAgICAgICAgIGVsLnN0eWxlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5uZXIgdGV4dCBjb250YWluZXJcclxuICAgICAgICBjb25zdCBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oaW5uZXIuc3R5bGUsIHtcclxuICAgICAgICAgICAgd2hpdGVTcGFjZTogJ3ByZS13cmFwJyxcclxuICAgICAgICAgICAgd29yZEJyZWFrOiAnYnJlYWstd29yZCcsXHJcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlubmVyLmlubmVySFRNTCA9IChodG1sVGV4dCB8fCAnJykudHJpbSgpIHx8ICdcdTIwMjYnO1xyXG4gICAgICAgIGVsLmFwcGVuZENoaWxkKGlubmVyKTtcclxuXHJcbiAgICAgICAgLy8gQXBwbHkgaW5pdGlhbCBsaW5lLWhlaWdodCAoYWRqdXN0bWVudCBtaWdodCBoYXBwZW4gbGF0ZXIgYnkgbWFuYWdlcilcclxuICAgICAgICB0aGlzLmFwcGx5TGluZUhlaWdodChpbm5lciwgb3V0cHV0TGluZUhlaWdodCk7XHJcblxyXG4gICAgICAgIC8vIE1ldGFkYXRhIGZvciBsYXRlciBhZGp1c3RtZW50IGFuZCBzYXZpbmcgKGlmIG5lZWRlZCBieSBtYW5hZ2VyKVxyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10ZXh0Jywgb3JpZ2luYWxUZXh0Q29udGVudCk7XHJcbiAgICAgICAgaWYgKG9yaWdpbmFsRm9udFNpemVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLWZvbnQtc2l6ZXMnLCBKU09OLnN0cmluZ2lmeShvcmlnaW5hbEZvbnRTaXplcykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW50ZXJhY3Rpb24gZXZlbnRzIChjb250ZXh0IG1lbnUsIHotaW5kZXggYnVtcCkgLSBhdHRhY2hlZCBoZXJlXHJcbiAgICAgICAgY29uc3QgY29udGV4dEhhbmRsZXIgPSAoZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dDb250ZXh0TWVudShldmVudCwgaW5uZXIudGV4dENvbnRlbnQgfHwgJycsIGVsKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1tPdmVybGF5VUlSZW5kZXJlcl0gY29udGV4dEhhbmRsZXIgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBicmluZ1RvVG9wSGFuZGxlciA9ICgpID0+IHRoaXMuYnJpbmdUb1RvcChlbCk7XHJcbiAgICAgICAgY29uc3QgcmVzZXRaSW5kZXhIYW5kbGVyID0gKCkgPT4geyBlbC5zdHlsZS56SW5kZXggPSAnMTAxJzsgfTtcclxuXHJcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBjb250ZXh0SGFuZGxlcik7XHJcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgYnJpbmdUb1RvcEhhbmRsZXIpO1xyXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCByZXNldFpJbmRleEhhbmRsZXIpO1xyXG5cclxuICAgICAgICB0aGlzLmNyZWF0ZWRPdmVybGF5cy5zZXQoZWwsIHtcclxuICAgICAgICAgICAgY29udGV4dEhhbmRsZXIsXHJcbiAgICAgICAgICAgIGJyaW5nVG9Ub3BIYW5kbGVyLFxyXG4gICAgICAgICAgICByZXNldFpJbmRleEhhbmRsZXIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy50cmFja2VkT3ZlcmxheUVsZW1lbnRzLmFkZChlbCk7XHJcblxyXG4gICAgICAgIHJldHVybiBlbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdHMgb3ZlcmxheSdzIGxpbmUgaGVpZ2h0IGZpcnN0IHRvIGZpdCwgdGhlbiBmb250IHNpemUgb25seSBhcyBsYXN0IHJlc29ydC5cclxuICAgICAqIEVuc3VyZXMgbWluaW11bSBmb250IHNpemUgZG9lc24ndCBnbyBiZWxvdyB3aGF0IHdvdWxkIG5hdHVyYWxseSBmaXQgdGhlIGJvdW5kaW5nIGJveC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkanVzdE92ZXJsYXlGb3JPdmVyZmxvdyhlbDogSFRNTEVsZW1lbnQsIG91dHB1dExpbmVIZWlnaHQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGlubmVyID0gZWwucXVlcnlTZWxlY3RvcignZGl2Jyk7XHJcbiAgICAgICAgaWYgKCFpbm5lcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBpc092ZXJmbG93aW5nID0gaW5uZXIuc2Nyb2xsSGVpZ2h0ID4gZWwuY2xpZW50SGVpZ2h0IHx8IGlubmVyLnNjcm9sbFdpZHRoID4gZWwuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgaWYgKCFpc092ZXJmbG93aW5nKSB7XHJcbiAgICAgICAgICAgIGVsLnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBpbnRlbmRlZEZvbnRTaXplID0gcGFyc2VGbG9hdChlbC5zdHlsZS5mb250U2l6ZSk7XHJcbiAgICAgICAgY29uc3QgaW50ZW5kZWRMaW5lSGVpZ2h0ID0gb3V0cHV0TGluZUhlaWdodDtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBtaW5SZWFzb25hYmxlRm9udFNpemUgPSBNYXRoLm1heCg4LCBNYXRoLm1pbihcclxuICAgICAgICAgICAgZWwuY2xpZW50SGVpZ2h0ICogMC4zLFxyXG4gICAgICAgICAgICBlbC5jbGllbnRXaWR0aCAqIDAuMDVcclxuICAgICAgICApKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBtaW5Gb250U2l6ZUZyb21JbnRlbnRpb24gPSBpbnRlbmRlZEZvbnRTaXplICogMC41O1xyXG4gICAgICAgIGNvbnN0IGFic29sdXRlTWluaW11bUZvbnRTaXplID0gTWF0aC5tYXgobWluUmVhc29uYWJsZUZvbnRTaXplLCBtaW5Gb250U2l6ZUZyb21JbnRlbnRpb24pO1xyXG5cclxuICAgICAgICBsZXQgY3VycmVudExpbmVIZWlnaHQgPSBpbnRlbmRlZExpbmVIZWlnaHQ7XHJcbiAgICAgICAgbGV0IGF0dGVtcHRzID0gMDtcclxuICAgICAgICBcclxuICAgICAgICB3aGlsZSAoY3VycmVudExpbmVIZWlnaHQgPiAwLjggJiYgYXR0ZW1wdHMgPCAyMCkge1xyXG4gICAgICAgICAgICBjdXJyZW50TGluZUhlaWdodCAtPSAwLjAzO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5TGluZUhlaWdodChpbm5lciBhcyBIVE1MRGl2RWxlbWVudCwgY3VycmVudExpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGlubmVyLnNjcm9sbEhlaWdodCA8PSBlbC5jbGllbnRIZWlnaHQgJiYgaW5uZXIuc2Nyb2xsV2lkdGggPD0gZWwuY2xpZW50V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhdHRlbXB0cysrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHRlc3RGb250U2l6ZSA9IGludGVuZGVkRm9udFNpemU7XHJcbiAgICAgICAgYXR0ZW1wdHMgPSAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHdoaWxlICh0ZXN0Rm9udFNpemUgPiBhYnNvbHV0ZU1pbmltdW1Gb250U2l6ZSAmJiBhdHRlbXB0cyA8IDE1KSB7XHJcbiAgICAgICAgICAgIGVsLnN0eWxlLmZvbnRTaXplID0gYCR7dGVzdEZvbnRTaXplfXB4YDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChpbm5lci5zY3JvbGxIZWlnaHQgPD0gZWwuY2xpZW50SGVpZ2h0ICYmIGlubmVyLnNjcm9sbFdpZHRoIDw9IGVsLmNsaWVudFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRlc3RGb250U2l6ZSAqPSAwLjk2O1xyXG4gICAgICAgICAgICBhdHRlbXB0cysrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFic29sdXRlTWluaW11bUZvbnRTaXplIDw9IGludGVuZGVkRm9udFNpemUpIHtcclxuICAgICAgICAgICAgZWwuc3R5bGUuZm9udFNpemUgPSBgJHthYnNvbHV0ZU1pbmltdW1Gb250U2l6ZX1weGA7XHJcbiAgICAgICAgICAgIGlmIChpbm5lci5zY3JvbGxIZWlnaHQgPD0gZWwuY2xpZW50SGVpZ2h0ICYmIGlubmVyLnNjcm9sbFdpZHRoIDw9IGVsLmNsaWVudFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsLnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xyXG4gICAgICAgIGNvbnNvbGUuZGVidWcoXCJbT3ZlcmxheVVJUmVuZGVyZXJdIENvdWxkIG5vdCBmaXQgY29udGVudCB3aXRoIG1pbmltdW0gZm9udCBzaXplLCBlbmFibGVkIHNjcm9sbGJhclwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdHMgdGhlIGxpbmUgaGVpZ2h0IGZvciBhIHNpbmdsZSwgc3BlY2lmaWMgb3ZlcmxheSBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRqdXN0U2luZ2xlT3ZlcmxheUxpbmVIZWlnaHQob3ZlcmxheUVsOiBIVE1MRWxlbWVudCwgZGVsdGE6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGlubmVyID0gb3ZlcmxheUVsLnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xyXG4gICAgICAgIGlmICghaW5uZXIpIHJldHVybjtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TGluZUhlaWdodCA9IHBhcnNlRmxvYXQoaW5uZXIuc3R5bGUubGluZUhlaWdodCkgfHwgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3V0cHV0TGluZUhlaWdodCB8fCAxLjI7XHJcbiAgICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IGN1cnJlbnRMaW5lSGVpZ2h0ICsgZGVsdGE7XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gTWF0aC5tYXgoTElORV9IRUlHSFRfTUlOLCBNYXRoLm1pbihMSU5FX0hFSUdIVF9NQVgsIG5ld1ZhbHVlKSk7XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gTWF0aC5yb3VuZChuZXdWYWx1ZSAqIDEwKSAvIDEwO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5TGluZUhlaWdodChpbm5lciwgbmV3VmFsdWUpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBbT3ZlcmxheVVJUmVuZGVyZXJdIExpbmUgaGVpZ2h0IGZvciBhIHNpbmdsZSBvdmVybGF5IGFkanVzdGVkIHRvICR7bmV3VmFsdWV9YCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnW092ZXJsYXlVSVJlbmRlcmVyXSBhZGp1c3RTaW5nbGVPdmVybGF5TGluZUhlaWdodCBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdHMgdGhlIGZvbnQgc2l6ZSBmb3IgYSBzaW5nbGUsIHNwZWNpZmljIG92ZXJsYXkgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkanVzdFNpbmdsZU92ZXJsYXlGb250U2l6ZShvdmVybGF5RWw6IEhUTUxFbGVtZW50LCBzY2FsZUZhY3RvcjogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCFvdmVybGF5RWwpIHJldHVybjtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U2l6ZSA9IHBhcnNlRmxvYXQob3ZlcmxheUVsLnN0eWxlLmZvbnRTaXplKTtcclxuICAgICAgICAgICAgaWYgKGlzTmFOKGN1cnJlbnRTaXplKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnW092ZXJsYXlVSVJlbmRlcmVyXSBDb3VsZCBub3QgcGFyc2UgY3VycmVudCBmb250IHNpemUgZm9yIGFkanVzdG1lbnQuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgRk9OVF9TSVpFX01JTl9QWCA9IDY7XHJcbiAgICAgICAgICAgIGNvbnN0IEZPTlRfU0laRV9NQVhfUFggPSA3MjtcclxuICAgICAgICAgICAgbGV0IG5ld1NpemUgPSBjdXJyZW50U2l6ZSAqIHNjYWxlRmFjdG9yO1xyXG4gICAgICAgICAgICBuZXdTaXplID0gTWF0aC5tYXgoRk9OVF9TSVpFX01JTl9QWCwgTWF0aC5taW4oRk9OVF9TSVpFX01BWF9QWCwgbmV3U2l6ZSkpO1xyXG4gICAgICAgICAgICBvdmVybGF5RWwuc3R5bGUuZm9udFNpemUgPSBgJHtuZXdTaXplfXB4YDtcclxuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhgW092ZXJsYXlVSVJlbmRlcmVyXSBGb250IHNpemUgZm9yIGEgc2luZ2xlIG92ZXJsYXkgYWRqdXN0ZWQgdG8gJHtuZXdTaXplfXB4YCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnW092ZXJsYXlVSVJlbmRlcmVyXSBhZGp1c3RTaW5nbGVPdmVybGF5Rm9udFNpemUgZmFpbGVkOicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFwcGx5TGluZUhlaWdodChpbm5lcjogSFRNTERpdkVsZW1lbnQsIHZhbHVlOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBsaW5lSGVpZ2h0U3RyID0gYCR7dmFsdWV9YDtcclxuICAgICAgICBpbm5lci5zdHlsZS5saW5lSGVpZ2h0ID0gbGluZUhlaWdodFN0cjtcclxuICAgICAgICBpbm5lci5wYXJlbnRFbGVtZW50Py5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1vdmVybGF5LWxpbmUtaGVpZ2h0JywgbGluZUhlaWdodFN0cik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldE92ZXJsYXlFbGVtZW50VmlzaWJpbGl0eShlbDogSFRNTEVsZW1lbnQsIGlzVmlzaWJsZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGlmIChpc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgZWwuc3R5bGUub3BhY2l0eSA9IGVsLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoJy0tb3ZlcmxheS1vcGFjaXR5JykgfHwgYCR7dGhpcy5wbHVnaW4uc2V0dGluZ3Mub3ZlcmxheU9wYWNpdHl9YDtcclxuICAgICAgICAgICAgZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcclxuICAgICAgICAgICAgZWwuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zdHlsZS5vcGFjaXR5ID0gJzAnO1xyXG4gICAgICAgICAgICBlbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xyXG4gICAgICAgICAgICBlbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBicmluZ1RvVG9wKGVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG92ZXJsYXlzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnBkZi10ZXh0LW92ZXJsYXktcmVmbG93Jyk7XHJcbiAgICAgICAgbGV0IG1heFpJbmRleCA9IDEwMDtcclxuICAgICAgICBvdmVybGF5cy5mb3JFYWNoKG92ZXJsYXkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB6SW5kZXggPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShvdmVybGF5KS56SW5kZXgsIDEwKTtcclxuICAgICAgICAgICAgaWYgKCFpc05hTih6SW5kZXgpICYmIHpJbmRleCA+IG1heFpJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgbWF4WkluZGV4ID0gekluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZWwuc3R5bGUuekluZGV4ID0gYCR7bWF4WkluZGV4ICsgMX1gO1xyXG4gICAgfVxyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gQ29udGV4dCBNZW51XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBwcml2YXRlIHNob3dDb250ZXh0TWVudShldmVudDogRXZlbnQsIHRleHRUb0NvcHk6IHN0cmluZywgdGFyZ2V0T3ZlcmxheTogSFRNTEVsZW1lbnQpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBtZSA9IGV2ZW50IGFzIE1vdXNlRXZlbnQ7XHJcbiAgICAgICAgbWUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBtZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBpZiAoIXRhcmdldE92ZXJsYXkpIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgYWN0aXZlTGVhZiA9IHRoaXMucGx1Z2luLmFwcC53b3Jrc3BhY2UuYWN0aXZlTGVhZjtcclxuICAgICAgICBjb25zdCBhY3RpdmVGaWxlID0gYWN0aXZlTGVhZj8udmlldz8uZmlsZTtcclxuICAgICAgICBjb25zdCBwYWdlTnVtYmVyID0gdGhpcy5wbHVnaW4uZ2V0Q3VycmVudFBhZ2VOdW1iZXIoKTtcclxuXHJcbiAgICAgICAgY29uc3QgbWVudSA9IG5ldyBNZW51KCk7XHJcbiAgICAgICAgY29uc3QgYWRkSXRlbSA9ICh0aXRsZTogc3RyaW5nLCBpY29uOiBzdHJpbmcsIG9uQ2xpY2s6ICgpID0+IHZvaWQpID0+XHJcbiAgICAgICAgICAgIG1lbnUuYWRkSXRlbShpdGVtID0+IGl0ZW0uc2V0VGl0bGUodGl0bGUpLnNldEljb24oaWNvbikub25DbGljayhvbkNsaWNrKSk7XHJcblxyXG4gICAgICAgIGFkZEl0ZW0oJ0NvcHkgVHJhbnNsYXRpb24nLCAnY29weScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHRUb0NvcHkpO1xyXG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnVHJhbnNsYXRpb24gY29waWVkLicpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0ZhaWxlZCB0byBjb3B5IHRyYW5zbGF0aW9uLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIC0tLSBORVc6IERZTkFNSUMgRk9STUFUVEVEIENPUFkgLS0tXHJcbiAgICAgICAgY29uc3QgY29weUZvcm1hdHRlZFRleHQgPSBhc3luYyAoZm9ybWF0OiBzdHJpbmcsIHRpdGxlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFhY3RpdmVGaWxlIHx8IHBhZ2VOdW1iZXIgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYENhbm5vdCBjb3B5IGFzICR7dGl0bGV9OiBQREYgZmlsZSBvciBwYWdlIG51bWJlciBpcyBub3QgYXZhaWxhYmxlLmApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8gUHJlcGFyZSBhbGwgcGxhY2Vob2xkZXIgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlTGluayA9IGBbWyR7YWN0aXZlRmlsZS5wYXRofSNwYWdlPSR7cGFnZU51bWJlcn1dXWA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9ja3F1b3RlVGV4dCA9IHRleHRUb0NvcHkuc3BsaXQoJ1xcbicpLm1hcChsaW5lID0+IGA+ICR7bGluZX1gKS5qb2luKCdcXG4nKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBwbGFjZWhvbGRlcnMgaW4gdGhlIGZvcm1hdCBzdHJpbmdcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFRleHQgPSBmb3JtYXRcclxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgve2Jsb2NrcXVvdGVfdGV4dH0vZywgYmxvY2txdW90ZVRleHQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL3t0ZXh0fS9nLCB0ZXh0VG9Db3B5KVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC97ZmlsZW5hbWV9L2csIGFjdGl2ZUZpbGUubmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgve3BhZ2VsaW5rfS9nLCBwYWdlTGluaylcclxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgve3BhZ2VudW1iZXJ9L2csIFN0cmluZyhwYWdlTnVtYmVyKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoZm9ybWF0dGVkVGV4dCk7XHJcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBDb3BpZWQgYXMgJHt0aXRsZX0uYCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gY29weSB0cmFuc2xhdGlvbiBhcyAke3RpdGxlfTpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBGYWlsZWQgdG8gY29weSBhcyAke3RpdGxlfS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGFkZEl0ZW0oJ0NvcHkgYXMgQ2FsbG91dCcsICcnLCAoKSA9PiBcclxuICAgICAgICAgICAgY29weUZvcm1hdHRlZFRleHQodGhpcy5wbHVnaW4uc2V0dGluZ3MuY2FsbG91dEZvcm1hdCwgJ2NhbGxvdXQnKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYWRkSXRlbSgnQ29weSBhcyBDaXRhdGlvbicsICcnLCAoKSA9PiBcclxuICAgICAgICAgICAgY29weUZvcm1hdHRlZFRleHQodGhpcy5wbHVnaW4uc2V0dGluZ3MuY2l0YXRpb25Gb3JtYXQsICdjaXRhdGlvbicpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgYWRkSXRlbSgnQ29weSBhcyBGb290bm90ZScsICcnLCAoKSA9PiBcclxuICAgICAgICAgICAgY29weUZvcm1hdHRlZFRleHQodGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9vdG5vdGVGb3JtYXQsICdmb290bm90ZScpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgbWVudS5hZGRTZXBhcmF0b3IoKTtcclxuXHJcbiAgICAgICAgYWRkSXRlbSgnUmV0cmFuc2xhdGUgUGFnZS4uLicsICdyZWZyZXNoLWN3JywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWFjdGl2ZUZpbGUpIHJldHVybjtcclxuICAgICAgICAgICAgbmV3IFJldHJhbnNsYXRlVXNpbmdPdmVybGF5c01vZGFsKHRoaXMucGx1Z2luLmFwcCwgdGhpcy5wbHVnaW4sIGFjdGl2ZUZpbGUpLm9wZW4oKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBhZGRJdGVtKCdGb3JjZSBSZWZyZXNoIE92ZXJsYXlzJywgJ3JlZnJlc2gtY2N3JywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLnBsdWdpbi5yZW5kZXJlciA/PyB0aGlzLnBsdWdpbikuZm9yY2VSZWZyZXNoVmlzaWJsZU92ZXJsYXlzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgKHRoaXMucGx1Z2luLnJlbmRlcmVyID8/IHRoaXMucGx1Z2luKS5mb3JjZVJlZnJlc2hWaXNpYmxlT3ZlcmxheXMoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJSZWZyZXNoIGZ1bmN0aW9uIG5vdCBhdmFpbGFibGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBtZW51LmFkZFNlcGFyYXRvcigpO1xyXG5cclxuICAgICAgICAvLyBGb250IHNpemUgY29udHJvbHNcclxuICAgICAgICBhZGRJdGVtKCdJbmNyZWFzZSBUZXh0IFNpemUnLCAnem9vbS1pbicsICgpID0+IHRoaXMuYWRqdXN0U2luZ2xlT3ZlcmxheUZvbnRTaXplKHRhcmdldE92ZXJsYXksIDEuMSkpO1xyXG4gICAgICAgIGFkZEl0ZW0oJ0RlY3JlYXNlIFRleHQgU2l6ZScsICd6b29tLW91dCcsICgpID0+IHRoaXMuYWRqdXN0U2luZ2xlT3ZlcmxheUZvbnRTaXplKHRhcmdldE92ZXJsYXksIDEgLyAxLjEpKTtcclxuICAgICAgICAvLyBMaW5lIGhlaWdodCBjb250cm9sc1xyXG4gICAgICAgIGFkZEl0ZW0oJ0luY3JlYXNlIExpbmUgSGVpZ2h0JywgJ3BsdXMnLCAoKSA9PiB0aGlzLmFkanVzdFNpbmdsZU92ZXJsYXlMaW5lSGVpZ2h0KHRhcmdldE92ZXJsYXksIExJTkVfSEVJR0hUX1NURVApKTtcclxuICAgICAgICBhZGRJdGVtKCdEZWNyZWFzZSBMaW5lIEhlaWdodCcsICdtaW51cycsICgpID0+IHRoaXMuYWRqdXN0U2luZ2xlT3ZlcmxheUxpbmVIZWlnaHQodGFyZ2V0T3ZlcmxheSwgLUxJTkVfSEVJR0hUX1NURVApKTtcclxuXHJcbiAgICAgICAgbWVudS5hZGRTZXBhcmF0b3IoKTtcclxuXHJcbiAgICAgICAgYWRkSXRlbSgnR28gdG8gVHJhbnNsYXRpb24gRmlsZScsICdmaWxlLXRleHQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFjdGl2ZUZpbGUgfHwgYWN0aXZlRmlsZS5leHRlbnNpb24gIT09ICdwZGYnIHx8IHBhZ2VOdW1iZXIgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdObyBQREYgb3IgcGFnZSBhdmFpbGFibGUuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRpb25GaWxlTmFtZSA9IGAke2FjdGl2ZUZpbGUuYmFzZW5hbWV9LnRyYW5zbGF0aW9uc2A7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3aWtpTGluayA9IGAke3RyYW5zbGF0aW9uRmlsZU5hbWV9I1BhZ2UgJHtwYWdlTnVtYmVyfWA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5hcHAud29ya3NwYWNlLm9wZW5MaW5rVGV4dCh3aWtpTGluaywgJycsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYE9wZW5lZCB0cmFuc2xhdGlvbiBmb3IgcGFnZSAke3BhZ2VOdW1iZXJ9YCk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBbT3ZlcmxheVVJUmVuZGVyZXJdIE9wZW5lZCB0cmFuc2xhdGlvbiBsaW5rOiAke3dpa2lMaW5rfWApO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnW092ZXJsYXlVSVJlbmRlcmVyXSBHbyB0byB0cmFuc2xhdGlvbiBmaWxlIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0Vycm9yIG9wZW5pbmcgdHJhbnNsYXRpb24gZmlsZS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBtZW51LnNob3dBdFBvc2l0aW9uKHsgeDogbWUuY2xpZW50WCwgeTogbWUuY2xpZW50WSB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIENsZWFudXBcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIHByaXZhdGUgY2xlYW51cEhvdmVySGFuZGxlcnMoZWw6IEhUTUxFbGVtZW50KTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSB0aGlzLmNyZWF0ZWRPdmVybGF5cy5nZXQoZWwpPy5ob3ZlckhhbmRsZXJzO1xyXG4gICAgICAgIGlmIChoYW5kbGVycykge1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgaGFuZGxlcnMuc2hvdyk7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBoYW5kbGVycy5oaWRlKTtcclxuICAgICAgICAgICAgY29uc3QgYWxsSGFuZGxlcnMgPSB0aGlzLmNyZWF0ZWRPdmVybGF5cy5nZXQoZWwpITtcclxuICAgICAgICAgICAgZGVsZXRlIGFsbEhhbmRsZXJzLmhvdmVySGFuZGxlcnM7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlZE92ZXJsYXlzLnNldChlbCwgYWxsSGFuZGxlcnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2xlYW51cE92ZXJsYXlFbGVtZW50KGVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY2xlYW51cEhvdmVySGFuZGxlcnMoZWwpO1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5jcmVhdGVkT3ZlcmxheXMuZ2V0KGVsKTtcclxuICAgICAgICBpZiAoaGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBoYW5kbGVycy5jb250ZXh0SGFuZGxlcik7XHJcbiAgICAgICAgICAgIGlmIChoYW5kbGVycy5icmluZ1RvVG9wSGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgaGFuZGxlcnMuYnJpbmdUb1RvcEhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoYW5kbGVycy5yZXNldFpJbmRleEhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBoYW5kbGVycy5yZXNldFpJbmRleEhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlZE92ZXJsYXlzLmRlbGV0ZShlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJhY2tlZE92ZXJsYXlFbGVtZW50cy5kZWxldGUoZWwpO1xyXG4gICAgICAgIGVsLnJlbW92ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjbGVhbnVwKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudHJhY2tlZE92ZXJsYXlFbGVtZW50cy5mb3JFYWNoKGVsID0+IHRoaXMuY2xlYW51cE92ZXJsYXlFbGVtZW50KGVsKSk7XHJcbiAgICAgICAgdGhpcy50cmFja2VkT3ZlcmxheUVsZW1lbnRzLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVkT3ZlcmxheXMgPSBuZXcgV2Vha01hcCgpOyAvLyBDbGVhciB0aGUgbWFwXHJcbiAgICAgICAgdGhpcy50ZW1wRGl2ID0gbnVsbDsgLy8gQ2xlYXIgdGVtcCBkaXYgcmVmZXJlbmNlXHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGVscGVyIGZvciB0ZXh0IGV4dHJhY3Rpb24gKGlmIG5lZWRlZCBoZXJlKVxyXG4gICAgcHVibGljIGV4dHJhY3RQbGFpblRleHRGcm9tSHRtbChodG1sOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICghdGhpcy50ZW1wRGl2KSB0aGlzLnRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICB0aGlzLnRlbXBEaXYuaW5uZXJIVE1MID0gaHRtbDtcclxuICAgICAgICByZXR1cm4gdGhpcy50ZW1wRGl2LnRleHRDb250ZW50IHx8IHRoaXMudGVtcERpdi5pbm5lclRleHQgfHwgJyc7XHJcbiAgICB9XHJcbn0iLCAiLy8gbW9kYWwtcmV0cmFuc2xhdGUudHNcclxuaW1wb3J0IHsgQXBwLCBNb2RhbCwgTm90aWNlLCBTZXR0aW5nLCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IE9wZW5Sb3V0ZXJUcmFuc2xhdG9yUGx1Z2luIGZyb20gJy4vbWFpbic7XHJcbmltcG9ydCB7IFNhdmVkT3ZlcmxheSwgT3ZlcmxheVBvc2l0aW9uRGF0YSB9IGZyb20gJy4vdHlwZXMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIFJldHJhbnNsYXRlVXNpbmdPdmVybGF5c01vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG4gIHByaXZhdGUgcGx1Z2luOiBPcGVuUm91dGVyVHJhbnNsYXRvclBsdWdpbjtcclxuICBwcml2YXRlIGZpbGU6IFRGaWxlO1xyXG5cclxuICBwcml2YXRlIG9ubHlDdXJyZW50UGFnZSA9IHRydWU7XHJcbiAgcHJpdmF0ZSBmcm9tUGFnZTogbnVtYmVyIHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSB0b1BhZ2U6IG51bWJlciB8IG51bGwgPSBudWxsO1xyXG5cclxuICAvLyBPcHRpb25zXHJcbiAgcHJpdmF0ZSBvbmx5RW1wdHkgPSBmYWxzZTsgICAgICAgLy8gb25seSB0cmFuc2xhdGUgaXRlbXMgd2l0aCBlbXB0eSB0cmFuc2xhdGVkVGV4dFxyXG4gIHByaXZhdGUgY29uZmlybU92ZXJ3cml0ZSA9IHRydWU7IC8vIHNob3cgY29uZmlybWF0aW9uIGlmIG92ZXJ3cml0aW5nIG5vbi1lbXB0eSBpdGVtc1xyXG5cclxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBPcGVuUm91dGVyVHJhbnNsYXRvclBsdWdpbiwgZmlsZTogVEZpbGUpIHtcclxuICAgIHN1cGVyKGFwcCk7XHJcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICAgIHRoaXMuZmlsZSA9IGZpbGU7XHJcbiAgfVxyXG5cclxuICBvbk9wZW4oKTogdm9pZCB7XHJcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xyXG5cclxuICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdSZS10cmFuc2xhdGUgdXNpbmcgc2F2ZWQgb3ZlcmxheSBib3hlcycgfSk7XHJcblxyXG4gICAgLy8gU2NvcGUgc2VsZWN0b3JcclxuICAgIGxldCByYW5nZVNldHRpbmc6IFNldHRpbmc7XHJcblxyXG4gICAgbmV3IFNldHRpbmcoY29udGVudEVsKVxyXG4gICAgICAuc2V0TmFtZSgnU2NvcGUnKVxyXG4gICAgICAuc2V0RGVzYygnQ2hvb3NlIHdoaWNoIHBhZ2VzIHRvIHJlLXRyYW5zbGF0ZScpXHJcbiAgICAgIC5hZGREcm9wZG93bigoZGQpID0+IHtcclxuICAgICAgICBkZC5hZGRPcHRpb24oJ2N1cnJlbnQnLCAnQ3VycmVudCBwYWdlIG9ubHknKTtcclxuICAgICAgICBkZC5hZGRPcHRpb24oJ3JhbmdlJywgJ1BhZ2UgcmFuZ2VcdTIwMjYnKTtcclxuICAgICAgICBkZC5zZXRWYWx1ZSgnY3VycmVudCcpO1xyXG4gICAgICAgIGRkLm9uQ2hhbmdlKCh2YWwpID0+IHtcclxuICAgICAgICAgIHRoaXMub25seUN1cnJlbnRQYWdlID0gKHZhbCA9PT0gJ2N1cnJlbnQnKTtcclxuICAgICAgICAgIGlmIChyYW5nZVNldHRpbmcpIHtcclxuICAgICAgICAgICAgcmFuZ2VTZXR0aW5nLnNldHRpbmdFbC50b2dnbGVDbGFzcygnaXMtaGlkZGVuJywgdGhpcy5vbmx5Q3VycmVudFBhZ2UpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyBSYW5nZSBpbnB1dHNcclxuICAgIHJhbmdlU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcclxuICAgICAgLnNldE5hbWUoJ1BhZ2UgcmFuZ2UnKVxyXG4gICAgICAuc2V0RGVzYygnSW5jbHVzaXZlIHBhZ2UgcmFuZ2UgKDEtYmFzZWQgaW5kaWNlcyknKVxyXG4gICAgICAuYWRkVGV4dCgodHh0KSA9PiB7XHJcbiAgICAgICAgdHh0LnNldFBsYWNlaG9sZGVyKCdGcm9tJylcclxuICAgICAgICAgIC5vbkNoYW5nZSgodmFsKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4gPSBwYXJzZUludCh2YWwsIDEwKTtcclxuICAgICAgICAgICAgdGhpcy5mcm9tUGFnZSA9IE51bWJlci5pc0Zpbml0ZShuKSAmJiBuID4gMCA/IG4gOiBudWxsO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5hZGRUZXh0KCh0eHQpID0+IHtcclxuICAgICAgICB0eHQuc2V0UGxhY2Vob2xkZXIoJ1RvJylcclxuICAgICAgICAgIC5vbkNoYW5nZSgodmFsKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4gPSBwYXJzZUludCh2YWwsIDEwKTtcclxuICAgICAgICAgICAgdGhpcy50b1BhZ2UgPSBOdW1iZXIuaXNGaW5pdGUobikgJiYgbiA+IDAgPyBuIDogbnVsbDtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICByYW5nZVNldHRpbmcuc2V0dGluZ0VsLmFkZENsYXNzKCdpcy1oaWRkZW4nKTtcclxuXHJcbiAgICAvLyBPcHRpb25zXHJcbiAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXHJcbiAgICAgIC5zZXROYW1lKCdPbmx5IHJlLXRyYW5zbGF0ZSBlbXB0eSBpdGVtcycpXHJcbiAgICAgIC5zZXREZXNjKCdJZiBlbmFibGVkLCBvbmx5IGl0ZW1zIHdpdGggbm8gdHJhbnNsYXRlZCB0ZXh0IHdpbGwgYmUgdHJhbnNsYXRlZC4nKVxyXG4gICAgICAuYWRkVG9nZ2xlKCh0ZykgPT4ge1xyXG4gICAgICAgIHRnLnNldFZhbHVlKHRoaXMub25seUVtcHR5KVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKCh2KSA9PiAodGhpcy5vbmx5RW1wdHkgPSB2KSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcclxuICAgICAgLnNldE5hbWUoJ0FzayBiZWZvcmUgb3ZlcndyaXRpbmcgbm9uLWVtcHR5IGl0ZW1zJylcclxuICAgICAgLnNldERlc2MoJ1doZW4gdW5jaGVja2VkLCBleGlzdGluZyB0cmFuc2xhdGlvbnMgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRob3V0IGNvbmZpcm1hdGlvbi4nKVxyXG4gICAgICAuYWRkVG9nZ2xlKCh0ZykgPT4ge1xyXG4gICAgICAgIHRnLnNldFZhbHVlKHRoaXMuY29uZmlybU92ZXJ3cml0ZSlcclxuICAgICAgICAgIC5vbkNoYW5nZSgodikgPT4gKHRoaXMuY29uZmlybU92ZXJ3cml0ZSA9IHYpKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gQWN0aW9uc1xyXG4gICAgbmV3IFNldHRpbmcoY29udGVudEVsKVxyXG4gICAgICAuYWRkQnV0dG9uKChidG4pID0+IHtcclxuICAgICAgICBidG4uc2V0QnV0dG9uVGV4dCgnU3RhcnQnKVxyXG4gICAgICAgICAgLnNldEN0YSgpXHJcbiAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5SZXRyYW5zbGF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgICAgICAgIG5ldyBOb3RpY2UoYFJldHJhbnNsYXRpb24gZmFpbGVkOiAke2U/Lm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfSlcclxuICAgICAgLmFkZEJ1dHRvbigoYnRuKSA9PiB7XHJcbiAgICAgICAgYnRuLnNldEJ1dHRvblRleHQoJ0NhbmNlbCcpXHJcbiAgICAgICAgICAub25DbGljaygoKSA9PiB0aGlzLmNsb3NlKCkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyBTbWFsbCBoZWxwZXIgc3R5bGVcclxuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICAgIHN0eWxlLnRleHRDb250ZW50ID0gYFxyXG4gICAgICAuaXMtaGlkZGVuIHsgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9XHJcbiAgICAgIC5tb2RhbCAuc2V0dGluZy1pdGVtLmlzLWhpZGRlbiB7IGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDsgfVxyXG4gICAgYDtcclxuICAgIGNvbnRlbnRFbC5hcHBlbmRDaGlsZChzdHlsZSk7XHJcbiAgfVxyXG5cclxuICBvbkNsb3NlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5jb250ZW50RWwuZW1wdHkoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcnVuUmV0cmFuc2xhdGlvbigpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGFuIGFjdGl2ZSBwYWdlIChmb3IgZGVmYXVsdCBzZWxlY3Rpb24gYW5kIHJlbmRlcmluZylcclxuICAgIGNvbnN0IGN1cnJlbnRQYWdlID0gdGhpcy5wbHVnaW4uZ2V0Q3VycmVudFBhZ2VOdW1iZXIoKTtcclxuICAgIGlmIChjdXJyZW50UGFnZSA9PSBudWxsKSB7XHJcbiAgICAgIG5ldyBOb3RpY2UoJ05vIGFjdGl2ZSBwYWdlIGRldGVjdGVkLicpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTG9hZCB0aGUgc2F2ZWQgb3ZlcmxheSBmaWxlXHJcbiAgICBjb25zdCB0cmFuc2xhdGlvbkZpbGUgPSBhd2FpdCB0aGlzLnBsdWdpbi5zdG9yYWdlLmZpbmRUcmFuc2xhdGlvbkZpbGVGb3JQZGYodGhpcy5maWxlKTtcclxuICAgIGlmICghdHJhbnNsYXRpb25GaWxlKSB7XHJcbiAgICAgIG5ldyBOb3RpY2UoJ05vIHRyYW5zbGF0aW9uIGZpbGUgZm91bmQgZm9yIHRoaXMgUERGLicpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBtZCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQodHJhbnNsYXRpb25GaWxlKTtcclxuICAgIGNvbnN0IHNhdmVkID0gdGhpcy5wbHVnaW4uc3RvcmFnZS5wYXJzZU1hcmtkb3duT3ZlcmxheShtZCwgdGhpcy5maWxlKTtcclxuICAgIGlmICghc2F2ZWQpIHtcclxuICAgICAgbmV3IE5vdGljZSgnTm8gc2F2ZWQgb3ZlcmxheXMgZm91bmQuJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCdWlsZCBwYWdlIGxpc3RcclxuICAgIGNvbnN0IHRhcmdldFBhZ2VzID0gdGhpcy5vbmx5Q3VycmVudFBhZ2VcclxuICAgICAgPyBbY3VycmVudFBhZ2VdXHJcbiAgICAgIDogdGhpcy5idWlsZFBhZ2VSYW5nZSgpO1xyXG4gICAgaWYgKHRhcmdldFBhZ2VzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBuZXcgTm90aWNlKCdJbnZhbGlkIG9yIGVtcHR5IHBhZ2UgcmFuZ2UuJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb2xsZWN0IGpvYnNcclxuICAgIGNvbnN0IGpvYnM6IHsgcGFnZTogbnVtYmVyOyBpdGVtczogT3ZlcmxheVBvc2l0aW9uRGF0YVtdIH1bXSA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBwIG9mIHRhcmdldFBhZ2VzKSB7XHJcbiAgICAgIGNvbnN0IGtleSA9IFN0cmluZyhwKTtcclxuICAgICAgY29uc3QgaXRlbXMgPSAoc2F2ZWQucGFnZU92ZXJsYXlzW2tleV0gfHwgW10pXHJcbiAgICAgICAgLmZpbHRlcigoaXQpID0+IChpdC50ZXh0Q29udGVudCB8fCAnJykudHJpbSgpLmxlbmd0aCA+IDApO1xyXG5cclxuICAgICAgaWYgKHRoaXMub25seUVtcHR5KSB7XHJcbiAgICAgICAgLy8gRmlsdGVyIHRvIG9ubHkgdW50cmFuc2xhdGVkIG9yIGJsYW5rXHJcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBpdGVtcy5maWx0ZXIoKGl0KSA9PiAhaXQudHJhbnNsYXRlZFRleHQgfHwgIWl0LnRyYW5zbGF0ZWRUZXh0LnRyaW0oKSk7XHJcbiAgICAgICAgaWYgKGZpbHRlcmVkLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGpvYnMucHVzaCh7IHBhZ2U6IHAsIGl0ZW1zOiBmaWx0ZXJlZCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGpvYnMucHVzaCh7IHBhZ2U6IHAsIGl0ZW1zIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChqb2JzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBuZXcgTm90aWNlKCdObyBtYXRjaGluZyBvdmVybGF5IGl0ZW1zIGZvdW5kIGZvciB0aGUgc2VsZWN0ZWQgc2NvcGUuJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb25maXJtIG92ZXJ3cml0ZSBpZiBuZWVkZWRcclxuICAgIGlmICghdGhpcy5vbmx5RW1wdHkgJiYgdGhpcy5jb25maXJtT3ZlcndyaXRlKSB7XHJcbiAgICAgIGNvbnN0IHdpbGxPdmVyd3JpdGUgPSBqb2JzLnNvbWUoaiA9PiBqLml0ZW1zLnNvbWUoaSA9PiAoaS50cmFuc2xhdGVkVGV4dCB8fCAnJykudHJpbSgpLmxlbmd0aCA+IDApKTtcclxuICAgICAgaWYgKHdpbGxPdmVyd3JpdGUpIHtcclxuICAgICAgICBjb25zdCBwcm9jZWVkID0gYXdhaXQgdGhpcy5jb25maXJtKFxyXG4gICAgICAgICAgJ092ZXJ3cml0ZSBleGlzdGluZyB0cmFuc2xhdGlvbnM/JyxcclxuICAgICAgICAgICdTb21lIGl0ZW1zIGFscmVhZHkgaGF2ZSB0cmFuc2xhdGVkIHRleHQuIERvIHlvdSB3YW50IHRvIG92ZXJ3cml0ZSB0aGVtPydcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmICghcHJvY2VlZCkgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHRvdGFsSXRlbXMgPSBqb2JzLnJlZHVjZSgoYWNjLCBqKSA9PiBhY2MgKyBqLml0ZW1zLmxlbmd0aCwgMCk7XHJcbiAgICBuZXcgTm90aWNlKGBSZS10cmFuc2xhdGluZyAke3RvdGFsSXRlbXN9IGl0ZW0ocykgYWNyb3NzICR7am9icy5sZW5ndGh9IHBhZ2UocykuLi5gLCAzMDAwKTtcclxuXHJcbiAgICAvLyBFeGVjdXRlIHBhZ2UgYnkgcGFnZVxyXG4gICAgZm9yIChjb25zdCBqb2Igb2Ygam9icykge1xyXG4gICAgICBjb25zdCB0ZXh0cyA9IGpvYi5pdGVtcy5tYXAoaSA9PiBpLnRleHRDb250ZW50IHx8ICcnKTtcclxuXHJcbiAgICAgIGxldCB0cmFuc2xhdGVkOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VCYXRjaFRyYW5zbGF0aW9uICYmIHRleHRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgIGNvbnN0IG51bWJlcmVkID0gdGV4dHMubWFwKCh0LCBpZHgpID0+IGAke2lkeCArIDF9LiAke3R9YCkuam9pbignXFxuJyk7XHJcbiAgICAgICAgICBjb25zdCBtYXhDaGFycyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLm1heEJhdGNoQ2hhcnM7XHJcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gbnVtYmVyZWQubGVuZ3RoID4gbWF4Q2hhcnMgPyBudW1iZXJlZC5zbGljZSgwLCBtYXhDaGFycykgOiBudW1iZXJlZDtcclxuICAgICAgICAgIGNvbnN0IHJhdyA9IGF3YWl0IHRoaXMucGx1Z2luLnRyYW5zbGF0aW9uLnRyYW5zbGF0ZUJhdGNoKHBheWxvYWQsIHRleHRzLmxlbmd0aCk7XHJcbiAgICAgICAgICB0cmFuc2xhdGVkID0gdGhpcy5wbHVnaW4ucHJvY2Vzc29yLmV4dHJhY3ROdW1iZXJlZExpbmVzKHJhdywgdGV4dHMubGVuZ3RoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gU2VxdWVudGlhbFxyXG4gICAgICAgICAgdHJhbnNsYXRlZCA9IFtdO1xyXG4gICAgICAgICAgZm9yIChjb25zdCB0IG9mIHRleHRzKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgY29uc3Qgb3V0ID0gYXdhaXQgdGhpcy5wbHVnaW4udHJhbnNsYXRpb24udHJhbnNsYXRlV2l0aE9wZW5Sb3V0ZXIodCk7XHJcbiAgICAgICAgICAgICAgdHJhbnNsYXRlZC5wdXNoKG91dCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdTZXF1ZW50aWFsIHRyYW5zbGF0ZSBmYWlsZWQ6JywgZSk7XHJcbiAgICAgICAgICAgICAgdHJhbnNsYXRlZC5wdXNoKHQpOyAvLyBmYWxsYmFja1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignUmV0cmFuc2xhdGlvbiBlcnJvciBvbiBwYWdlJywgam9iLnBhZ2UsIGUpO1xyXG4gICAgICAgIHRyYW5zbGF0ZWQgPSB0ZXh0cy5zbGljZSgpOyAvLyBmYWxsYmFjazoga2VlcCBvcmlnaW5hbFxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVcGRhdGUgc2F2ZWQgb3ZlcmxheSBkYXRhXHJcbiAgICAgIGpvYi5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XHJcbiAgICAgICAgaXRlbS50cmFuc2xhdGVkVGV4dCA9IHRyYW5zbGF0ZWRbaV0gfHwgaXRlbS50ZXh0Q29udGVudCB8fCAnJztcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBXcml0ZSBiYWNrIHRvIG1lbW9yeSBzdHJ1Y3R1cmVcclxuICAgICAgc2F2ZWQucGFnZU92ZXJsYXlzW1N0cmluZyhqb2IucGFnZSldID0gam9iLml0ZW1zO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBlcnNpc3QgdG8gZGlza1xyXG4gICAgc2F2ZWQudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgIGNvbnN0IG5ld01kID0gdGhpcy5wbHVnaW4uc3RvcmFnZS5nZW5lcmF0ZU1hcmtkb3duRm9yT3ZlcmxheShzYXZlZCwgdGhpcy5maWxlKTtcclxuICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeSh0cmFuc2xhdGlvbkZpbGUsIG5ld01kKTtcclxuXHJcbiAgICAvLyBSZS1yZW5kZXIgY3VycmVudCB2aXNpYmxlIHBhZ2UgaWYgYXBwbGljYWJsZVxyXG4gICAgY29uc3QgcGFnZVRvUmVmcmVzaCA9IHRoaXMub25seUN1cnJlbnRQYWdlID8gY3VycmVudFBhZ2UgOiB0aGlzLnBsdWdpbi5nZXRDdXJyZW50UGFnZU51bWJlcigpO1xyXG4gICAgaWYgKHBhZ2VUb1JlZnJlc2ggIT0gbnVsbCkge1xyXG4gICAgICBhd2FpdCB0aGlzLnJlZnJlc2hQYWdlT3ZlcmxheUZyb21TYXZlZChzYXZlZCwgcGFnZVRvUmVmcmVzaCk7XHJcbiAgICB9XHJcblxyXG4gICAgbmV3IE5vdGljZSgnXHUyNzA1IFJlLXRyYW5zbGF0aW9uIGNvbXBsZXRlLicpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBidWlsZFBhZ2VSYW5nZSgpOiBudW1iZXJbXSB7XHJcbiAgICBjb25zdCBvdXQ6IG51bWJlcltdID0gW107XHJcbiAgICBpZiAodGhpcy5mcm9tUGFnZSA9PSBudWxsIHx8IHRoaXMudG9QYWdlID09IG51bGwpIHJldHVybiBvdXQ7XHJcbiAgICBpZiAodGhpcy50b1BhZ2UgPCB0aGlzLmZyb21QYWdlKSByZXR1cm4gb3V0O1xyXG4gICAgZm9yIChsZXQgcCA9IHRoaXMuZnJvbVBhZ2U7IHAgPD0gdGhpcy50b1BhZ2U7IHArKykgb3V0LnB1c2gocCk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyByZWZyZXNoUGFnZU92ZXJsYXlGcm9tU2F2ZWQoc2F2ZWQ6IFNhdmVkT3ZlcmxheSwgcGFnZU51bWJlcjogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwYWdlRGF0YSA9IHNhdmVkLnBhZ2VPdmVybGF5c1tTdHJpbmcocGFnZU51bWJlcildO1xyXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFnZURhdGEpIHx8IHBhZ2VEYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG5cclxuICAgICAgY29uc3QgdGV4dExheWVyID0gYXdhaXQgdGhpcy5wbHVnaW4ub3ZlcmxheS53YWl0Rm9yUGRmVGV4dExheWVyKHBhZ2VOdW1iZXIpO1xyXG4gICAgICBpZiAoIXRleHRMYXllcikgcmV0dXJuO1xyXG5cclxuICAgICAgLy8gQ2xlYXIgZXhpc3Rpbmcgb3ZlcmxheXMgb24gdGhlIHBhZ2VcclxuICAgICAgY29uc3QgcGFnZUVsID0gdGhpcy5nZXRQYWdlRWxlbWVudEJ5TnVtYmVyKHBhZ2VOdW1iZXIpO1xyXG4gICAgICBwYWdlRWw/LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wZGYtdGV4dC1vdmVybGF5LWNvbnRhaW5lcicpPy5mb3JFYWNoKGVsID0+IGVsLnJlbW92ZSgpKTtcclxuXHJcbiAgICAgIC8vIFJlbmRlciBmcm9tIHNhdmVkIGRhdGFcclxuICAgICAgdGhpcy5wbHVnaW4ub3ZlcmxheS5yZW5kZXJTYXZlZE92ZXJsYXkocGFnZURhdGEsIHBhZ2VOdW1iZXIpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcmVmcmVzaCBvdmVybGF5IGZvciBwYWdlJywgcGFnZU51bWJlciwgZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBVc2Ugb3ZlcmxheSBoZWxwZXIgaWYgcHJlc2VudDsgb3RoZXJ3aXNlIHVzZSBhIGxvY2FsIHF1ZXJ5XHJcbiAgcHJpdmF0ZSBnZXRQYWdlRWxlbWVudEJ5TnVtYmVyKHBhZ2VOdW1iZXI6IG51bWJlcik6IEhUTUxFbGVtZW50IHwgbnVsbCB7XHJcbiAgICAvLyBQcmVmZXIgcGx1Z2luLm92ZXJsYXkuZ2V0UGFnZUVsZW1lbnRCeU51bWJlciBpZiBhdmFpbGFibGVcclxuICAgIGNvbnN0IGFueU92ZXJsYXk6IGFueSA9IHRoaXMucGx1Z2luLm92ZXJsYXkgYXMgYW55O1xyXG4gICAgaWYgKHR5cGVvZiBhbnlPdmVybGF5LmdldFBhZ2VFbGVtZW50QnlOdW1iZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcmV0dXJuIGFueU92ZXJsYXkuZ2V0UGFnZUVsZW1lbnRCeU51bWJlcihwYWdlTnVtYmVyKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHZpZXdlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wZGZWaWV3ZXIsICN2aWV3ZXInKTtcclxuICAgIGlmICghdmlld2VyKSByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiB2aWV3ZXIucXVlcnlTZWxlY3RvcihgLnBhZ2VbZGF0YS1wYWdlLW51bWJlcj1cIiR7cGFnZU51bWJlcn1cIl1gKSBhcyBIVE1MRWxlbWVudCB8IG51bGw7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGNvbmZpcm0odGl0bGU6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2U8Ym9vbGVhbj4oKHJlc29sdmUpID0+IHtcclxuICAgICAgY29uc3QgZGxnID0gbmV3IE1vZGFsKHRoaXMuYXBwKTtcclxuICAgICAgZGxnLmNvbnRlbnRFbC5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6IHRpdGxlIH0pO1xyXG4gICAgICBkbGcuY29udGVudEVsLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiBtZXNzYWdlIH0pO1xyXG5cclxuICAgICAgbmV3IFNldHRpbmcoZGxnLmNvbnRlbnRFbClcclxuICAgICAgICAuYWRkQnV0dG9uKChidG4pID0+IHtcclxuICAgICAgICAgIGJ0bi5zZXRCdXR0b25UZXh0KCdDYW5jZWwnKVxyXG4gICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgZGxnLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmFkZEJ1dHRvbigoYnRuKSA9PiB7XHJcbiAgICAgICAgICBidG4uc2V0Q3RhKCk7XHJcbiAgICAgICAgICBidG4uc2V0QnV0dG9uVGV4dCgnT3ZlcndyaXRlJylcclxuICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgIGRsZy5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgZGxnLm9uQ2xvc2UgPSAoKSA9PiBkbGcuY29udGVudEVsLmVtcHR5KCk7XHJcbiAgICAgIGRsZy5vcGVuKCk7XHJcbiAgICB9KTtcclxuICB9XHJcbn0iLCAiLy8gdHJhbnNsYXRpb24udHNcclxuaW1wb3J0IHsgcmVxdWVzdFVybCwgTm90aWNlLCBSZXF1ZXN0VXJsUGFyYW0gfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCBPcGVuUm91dGVyVHJhbnNsYXRvclBsdWdpbiBmcm9tICcuL21haW4nO1xyXG5pbXBvcnQgeyBBVkFJTEFCTEVfTEFOR1VBR0VTIH0gZnJvbSAnLi90eXBlcyc7XHJcblxyXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRpb25FbmdpbmUge1xyXG4gICAgcHJpdmF0ZSBwbHVnaW46IE9wZW5Sb3V0ZXJUcmFuc2xhdG9yUGx1Z2luO1xyXG4gICAgcHJpdmF0ZSB3YXJuZWRBYm91dFF3ZW4gPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwbHVnaW46IE9wZW5Sb3V0ZXJUcmFuc2xhdG9yUGx1Z2luKSB7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPT09IExhbmd1YWdlIEhlbHBlcnMgKE5vIGNoYW5nZXMgbmVlZGVkKSA9PT1cclxuICAgIGdldFNvdXJjZUxhbmdOYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGx1Z2luLnNldHRpbmdzLnNvdXJjZUxhbmd1YWdlID09PSAnYXV0bydcclxuICAgICAgICAgICAgPyAnQXV0by1kZXRlY3QnXHJcbiAgICAgICAgICAgIDogQVZBSUxBQkxFX0xBTkdVQUdFUy5maW5kKGwgPT4gbC5jb2RlID09PSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zb3VyY2VMYW5ndWFnZSk/Lm5hbWUgfHwgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc291cmNlTGFuZ3VhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VGFyZ2V0TGFuZ05hbWUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gQVZBSUxBQkxFX0xBTkdVQUdFUy5maW5kKGwgPT4gbC5jb2RlID09PSB0aGlzLnBsdWdpbi5zZXR0aW5ncy50YXJnZXRMYW5ndWFnZSk/Lm5hbWUgfHwgdGhpcy5wbHVnaW4uc2V0dGluZ3MudGFyZ2V0TGFuZ3VhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPT09IEhpZ2gtTGV2ZWwgVHJhbnNsYXRpb24gTWV0aG9kcyA9PT1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zbGF0ZXMgYSBiYXRjaCBvZiB0ZXh0IHVzaW5nIHRoZSBjdXJyZW50bHkgY29uZmlndXJlZCBwcm92aWRlci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgdHJhbnNsYXRlQmF0Y2gob3JpZ2luYWxUZXh0OiBzdHJpbmcsIGV4cGVjdGVkTGluZUNvdW50OiBudW1iZXIpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIGNvbnN0IHN5c3RlbVByb21wdFRlbXBsYXRlID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuYmF0Y2hQcm9tcHQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgc3lzdGVtIHByb21wdCBieSBmaWxsaW5nIGluIGFsbCBwbGFjZWhvbGRlcnMgZXhjZXB0IHRoZSBtYWluIHRleHRcclxuICAgICAgICBjb25zdCBzeXN0ZW1Qcm9tcHQgPSBzeXN0ZW1Qcm9tcHRUZW1wbGF0ZVxyXG4gICAgICAgICAgICAucmVwbGFjZSgve3NvdXJjZUxhbmd9L2csIHRoaXMuZ2V0U291cmNlTGFuZ05hbWUoKSlcclxuICAgICAgICAgICAgLnJlcGxhY2UoL3t0YXJnZXRMYW5nfS9nLCB0aGlzLmdldFRhcmdldExhbmdOYW1lKCkpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC97bGluZUNvdW50fS9nLCBleHBlY3RlZExpbmVDb3VudC50b1N0cmluZygpKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgve2lucHV0VGV4dH0vZywgJycpOyAvLyBUaGUgYWN0dWFsIHRleHQgaXMgc2VudCBhcyB0aGUgdXNlciBwcm9tcHRcclxuXHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubWFrZUFwaUNhbGwoc3lzdGVtUHJvbXB0LCBvcmlnaW5hbFRleHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNsYXRlcyBhIHNpbmdsZSBwaWVjZSBvZiB0ZXh0LiBNYWludGFpbmVkIGZvciBjb21wYXRpYmlsaXR5LlxyXG4gICAgICovXHJcbiAgICBhc3luYyB0cmFuc2xhdGVXaXRoT3BlblJvdXRlcih0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIGNvbnN0IHN5c3RlbVByb21wdFRlbXBsYXRlID0gdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2luZ2xlUHJvbXB0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFByZXBhcmUgdGhlIHN5c3RlbSBwcm9tcHRcclxuICAgICAgICBjb25zdCBzeXN0ZW1Qcm9tcHQgPSBzeXN0ZW1Qcm9tcHRUZW1wbGF0ZVxyXG4gICAgICAgICAgICAucmVwbGFjZSgve3NvdXJjZUxhbmd9L2csIHRoaXMuZ2V0U291cmNlTGFuZ05hbWUoKSlcclxuICAgICAgICAgICAgLnJlcGxhY2UoL3t0YXJnZXRMYW5nfS9nLCB0aGlzLmdldFRhcmdldExhbmdOYW1lKCkpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC97aW5wdXRUZXh0fS9nLCAnJyk7IC8vIFRoZSBhY3R1YWwgdGV4dCBpcyBzZW50IGFzIHRoZSB1c2VyIHByb21wdFxyXG5cclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5tYWtlQXBpQ2FsbChzeXN0ZW1Qcm9tcHQsIHRleHQuc2xpY2UoMCwgMzAwMCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vID09PSBMb3ctTGV2ZWwgQVBJIENvbW11bmljYXRpb24gPT09XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTYWZlbHkgcmV0cmlldmVzIGEgbmVzdGVkIHByb3BlcnR5IGZyb20gYW4gb2JqZWN0IHVzaW5nIGEgc3RyaW5nIHBhdGggKGUuZy4sICdjaG9pY2VzWzBdLm1lc3NhZ2UuY29udGVudCcpLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldFByb3BlcnR5QnlQYXRoKG9iajogYW55LCBwYXRoOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBwYXRoLnJlcGxhY2UoL1xcWyhcXHcrKVxcXS9nLCAnLiQxJykucmVwbGFjZSgvXlxcLi8sICcnKS5zcGxpdCgnLicpO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBvYmo7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEVzY2FwZXMgY2hhcmFjdGVycyBpbiBhIHN0cmluZyBmb3Igc2FmZSBpbmNsdXNpb24gaW4gYSBKU09OIHJlcXVlc3QgYm9keS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBlc2NhcGVKc29uU3RyaW5nKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcclxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKVxyXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpXHJcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJylcclxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcdC9nLCAnXFxcXHQnKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgdGhlIHJlcXVlc3QgVVJMLCBoZWFkZXJzLCBhbmQgYm9keSBiYXNlZCBvbiB0aGUgc2VsZWN0ZWQgcHJvdmlkZXIuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0UmVxdWVzdENvbmZpZyhzeXN0ZW1Qcm9tcHQ6IHN0cmluZywgdXNlclByb21wdDogc3RyaW5nKTogeyB1cmw6IHN0cmluZzsgb3B0aW9uczogUmVxdWVzdFVybFBhcmFtIH0ge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVySWQgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hcGlQcm92aWRlcjtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnByb3ZpZGVyU2V0dGluZ3NbcHJvdmlkZXJJZF07XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IHVybDogc3RyaW5nO1xyXG4gICAgICAgIGxldCBib2R5OiBhbnk7XHJcbiAgICAgICAgbGV0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChwcm92aWRlcklkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ29wZW5yb3V0ZXInOlxyXG4gICAgICAgICAgICAgICAgaWYgKCFwcm92aWRlci5hcGlLZXkpIHRocm93IG5ldyBFcnJvcignT3BlblJvdXRlciBBUEkga2V5IGlzIG1pc3NpbmcuJyk7XHJcbiAgICAgICAgICAgICAgICB1cmwgPSAnaHR0cHM6Ly9vcGVucm91dGVyLmFpL2FwaS92MS9jaGF0L2NvbXBsZXRpb25zJztcclxuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHtwcm92aWRlci5hcGlLZXl9YDtcclxuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0hUVFAtUmVmZXJlciddID0gJ29ic2lkaWFuOi8vcGRmLXRyYW5zbGF0b3InO1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyc1snWC1UaXRsZSddID0gJ1BERiBUcmFuc2xhdG9yIFBsdWdpbic7XHJcbiAgICAgICAgICAgICAgICBib2R5ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiBwcm92aWRlci5tb2RlbCxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHJvbGU6ICdzeXN0ZW0nLCBjb250ZW50OiBzeXN0ZW1Qcm9tcHQgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyByb2xlOiAndXNlcicsIGNvbnRlbnQ6IHVzZXJQcm9tcHQgfVxyXG4gICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4X3Rva2VuczogNDA5NixcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wZXJhdHVyZTogMC4xLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FzZSAnb2xsYW1hJzpcclxuICAgICAgICAgICAgICAgIGlmICghcHJvdmlkZXIuYXBpRW5kcG9pbnQgfHwgIXByb3ZpZGVyLm1vZGVsKSB0aHJvdyBuZXcgRXJyb3IoJ09sbGFtYSBlbmRwb2ludCBvciBtb2RlbCBpcyBtaXNzaW5nLicpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBwcm92aWRlci5hcGlFbmRwb2ludC5lbmRzV2l0aCgnLycpID8gcHJvdmlkZXIuYXBpRW5kcG9pbnQuc2xpY2UoMCwgLTEpIDogcHJvdmlkZXIuYXBpRW5kcG9pbnQ7XHJcbiAgICAgICAgICAgICAgICB1cmwgPSBgJHtlbmRwb2ludH0vYXBpL2NoYXRgO1xyXG4gICAgICAgICAgICAgICAgYm9keSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbDogcHJvdmlkZXIubW9kZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHJvbGU6ICdzeXN0ZW0nLCBjb250ZW50OiBzeXN0ZW1Qcm9tcHQgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyByb2xlOiAndXNlcicsIGNvbnRlbnQ6IHVzZXJQcm9tcHQgfVxyXG4gICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2N1c3RvbSc6XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByb3ZpZGVyLmFwaUVuZHBvaW50KSB0aHJvdyBuZXcgRXJyb3IoJ0N1c3RvbSBBUEkgZW5kcG9pbnQgaXMgbWlzc2luZy4nKTtcclxuICAgICAgICAgICAgICAgIHVybCA9IHByb3ZpZGVyLmFwaUVuZHBvaW50O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIuaGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcHVsYXRlZEhlYWRlcnMgPSBwcm92aWRlci5oZWFkZXJzLnJlcGxhY2UoL3thcGlLZXl9L2csIHByb3ZpZGVyLmFwaUtleSB8fCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyA9IHsgLi4uaGVhZGVycywgLi4uSlNPTi5wYXJzZShwb3B1bGF0ZWRIZWFkZXJzKSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgY3VzdG9tIGhlYWRlcnMgSlNPTi4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLnJlcXVlc3RCb2R5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9wdWxhdGVkQm9keSA9IHByb3ZpZGVyLnJlcXVlc3RCb2R5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC97bW9kZWx9L2csIHByb3ZpZGVyLm1vZGVsIHx8ICcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgve3N5c3RlbVByb21wdH0vZywgdGhpcy5lc2NhcGVKc29uU3RyaW5nKHN5c3RlbVByb21wdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC97dXNlclByb21wdH0vZywgdGhpcy5lc2NhcGVKc29uU3RyaW5nKHVzZXJQcm9tcHQpKTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShwb3B1bGF0ZWRCb2R5KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIGN1c3RvbSByZXF1ZXN0IGJvZHkgSlNPTi4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1c3RvbSByZXF1ZXN0IGJvZHkgc2V0dGluZyBpcyBtaXNzaW5nLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBBUEkgcHJvdmlkZXI6ICR7cHJvdmlkZXJJZH1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVybCxcclxuICAgICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXHJcbiAgICAgICAgICAgICAgICB0aHJvdzogZmFsc2UsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFrZXMgYW4gQVBJIGNhbGwgdG8gdGhlIGNvbmZpZ3VyZWQgcHJvdmlkZXIgd2l0aCByZXRyeSBsb2dpYy5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgbWFrZUFwaUNhbGwoc3lzdGVtUHJvbXB0OiBzdHJpbmcsIHVzZXJQcm9tcHQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXJJZCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmFwaVByb3ZpZGVyO1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyU2V0dGluZ3MgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm92aWRlclNldHRpbmdzW3Byb3ZpZGVySWRdO1xyXG5cclxuICAgICAgICBpZiAocHJvdmlkZXJJZCA9PT0gJ29wZW5yb3V0ZXInICYmIHByb3ZpZGVyU2V0dGluZ3MubW9kZWw/LmluY2x1ZGVzKCdxd2VuJykgJiYgIXRoaXMud2FybmVkQWJvdXRRd2VuKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1dhcm5pbmc6IFNvbWUgUXdlbiBtb2RlbHMgaGF2ZSBsb3cgcmF0ZSBsaW1pdHMuIENvbnNpZGVyIGdlbWluaS1mbGFzaC4nLCA2MDAwKTtcclxuICAgICAgICAgICAgdGhpcy53YXJuZWRBYm91dFF3ZW4gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgTUFYX1JFVFJJRVMgPSAzO1xyXG4gICAgICAgIGNvbnN0IEJBU0VfREVMQVkgPSAxMDAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSBNQVhfUkVUUklFUzsgYXR0ZW1wdCsrKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVybCwgb3B0aW9ucyB9ID0gdGhpcy5nZXRSZXF1ZXN0Q29uZmlnKHN5c3RlbVByb21wdCwgdXNlclByb21wdCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgNDUwMDApO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwgPSBjb250cm9sbGVyLnNpZ25hbDtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoeyB1cmwsIC4uLm9wdGlvbnMgfSk7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2VQYXRoID0gJ2Nob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50JzsgLy8gRGVmYXVsdCBmb3IgT3BlbkFJLWNvbXBhdGlibGUgQVBJc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm92aWRlcklkID09PSAnb2xsYW1hJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVBhdGggPSAnbWVzc2FnZS5jb250ZW50JztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3ZpZGVySWQgPT09ICdjdXN0b20nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUGF0aCA9IHByb3ZpZGVyU2V0dGluZ3MucmVzcG9uc2VQYXRoIHx8IHJlc3BvbnNlUGF0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZWRUZXh0ID0gdGhpcy5nZXRQcm9wZXJ0eUJ5UGF0aChyZXNwb25zZS5qc29uLCByZXNwb25zZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVkVGV4dD8udHJpbSgpIHx8IHVzZXJQcm9tcHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNc2cgPSByZXNwb25zZS5qc29uPy5lcnJvcj8ubWVzc2FnZSB8fCByZXNwb25zZS50ZXh0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5IHx8ICh0eXBlb2YgZXJyb3JNc2cgPT09ICdzdHJpbmcnICYmIGVycm9yTXNnLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA9PT0gTUFYX1JFVFJJRVMpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gQkFTRV9ERUxBWSAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKSArIE1hdGgucmFuZG9tKCkgKiA1MDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLmRlYnVnTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUmF0ZSBsaW1pdCBoaXQuIFJldHJ5aW5nIGluICR7ZGVsYXl9bXMgKGF0dGVtcHQgJHthdHRlbXB0fSlgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zbGVlcChkZWxheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIEVycm9yIC0gSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3JNc2d9YCk7XHJcblxyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgdGltZWQgb3V0ICg0NXMpJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA9PT0gTUFYX1JFVFJJRVMpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBBUEkgY2FsbCBmYWlsZWQ6ICR7ZXJyLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JhdGUgbGltaXQgZXhjZWVkZWQgYWZ0ZXIgbXVsdGlwbGUgcmV0cmllcy4nKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyA9PT0gVXRpbGl0eTogU2FmZSBkZWxheSA9PT1cclxuICAgIGFzeW5jIHNsZWVwKG1zOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XHJcbiAgICB9XHJcbn0iLCAiXHJcbi8vIHByb2Nlc3NpbmcudHNcclxuaW1wb3J0IHsgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgT3BlblJvdXRlclRyYW5zbGF0b3JQbHVnaW4gZnJvbSAnLi9tYWluJztcclxuaW1wb3J0IHsgVHJhbnNsYXRpb25Vbml0IH0gZnJvbSAnLi90eXBlcyc7XHJcbmltcG9ydCB7IExheW91dERldGVjdG9yLCBMYXlvdXRTZXR0aW5ncyB9IGZyb20gJy4vbGF5b3V0LWRldGVjdG9yJztcclxuXHJcbmV4cG9ydCBjbGFzcyBUZXh0UHJvY2Vzc29yIHtcclxuICBwcml2YXRlIHBsdWdpbjogT3BlblJvdXRlclRyYW5zbGF0b3JQbHVnaW47XHJcbiAgcHVibGljIGxheW91dERldGVjdG9yOiBMYXlvdXREZXRlY3RvcjtcclxuXHJcbiAgLy8gQ2FjaGVzXHJcbiAgcHJpdmF0ZSBtZWFzdXJlbWVudENhY2hlID0gbmV3IE1hcDxIVE1MRWxlbWVudCwgeyByZWN0OiBET01SZWN0OyB0aW1lc3RhbXA6IG51bWJlciB9PigpO1xyXG4gIHByaXZhdGUgc3R5bGVDYWNoZSA9IG5ldyBNYXA8SFRNTEVsZW1lbnQsIENTU1N0eWxlRGVjbGFyYXRpb24+KCk7XHJcbiAgcHJpdmF0ZSBjb2xvckRpc3RhbmNlQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xyXG4gIHByaXZhdGUgbGFzdFByZXBhcmVkVW5pdHM6IHsgcGFnZUVsZW1lbnQ6IEhUTUxFbGVtZW50LCB1bml0czogVHJhbnNsYXRpb25Vbml0W10gfSB8IG51bGwgPSBudWxsO1xyXG5cclxuICAvLyBTdGF0ZVxyXG4gIHByaXZhdGUgb3ZlcmxheUNvbnRhaW5lcnM6IEhUTUxFbGVtZW50W10gPSBbXTtcclxuICBwcml2YXRlIHRyYW5zbGF0aW9uRmFpbHVyZXM6IHsgc2VnbWVudEluZGV4OiBudW1iZXI7IGVycm9yOiBzdHJpbmcgfVtdID0gW107XHJcbiAgcHJpdmF0ZSBsYXN0Q29sdW1uQW5hbHlzaXM6IHsgZWRnZUNvbHM6IERPTVJlY3RbXTsgZ2FwQ29sczogRE9NUmVjdFtdIH0gfCBudWxsID0gbnVsbDtcclxuXHJcbiAgY29uc3RydWN0b3IocGx1Z2luOiBPcGVuUm91dGVyVHJhbnNsYXRvclBsdWdpbikge1xyXG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICB0aGlzLmxheW91dERldGVjdG9yID0gbmV3IExheW91dERldGVjdG9yKHRoaXMucGx1Z2luLnNldHRpbmdzLmxheW91dFNldHRpbmdzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIExheW91dERldGVjdG9yIGluc3RhbmNlIHdpdGggbmV3IHNldHRpbmdzLlxyXG4gICAqIEBwYXJhbSBuZXdTZXR0aW5ncyBUaGUgbmV3IExheW91dFNldHRpbmdzIG9iamVjdCBmcm9tIHRoZSBtb2RhbC5cclxuICAgKi9cclxuICBwdWJsaWMgdXBkYXRlTGF5b3V0RGV0ZWN0b3JTZXR0aW5ncyhuZXdTZXR0aW5nczogTGF5b3V0U2V0dGluZ3MpOiB2b2lkIHtcclxuICAgIGNvbnNvbGUubG9nKFwiVXBkYXRpbmcgTGF5b3V0RGV0ZWN0b3Igd2l0aCBuZXcgc2V0dGluZ3M6XCIsIG5ld1NldHRpbmdzKTtcclxuICAgIHRoaXMubGF5b3V0RGV0ZWN0b3IgPSBuZXcgTGF5b3V0RGV0ZWN0b3IobmV3U2V0dGluZ3MpO1xyXG4gICAgbmV3IE5vdGljZSgnTGF5b3V0IGRldGVjdGlvbiBzZXR0aW5ncyBoYXZlIGJlZW4gdXBkYXRlZC4nKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1haW4gZW50cnkgcG9pbnQgZm9yIHRoZSBcIlRyYW5zbGF0ZSBQYWdlXCIgY29tbWFuZC5cclxuICAgKi9cclxuICBwdWJsaWMgYXN5bmMgYWRkVGV4dE92ZXJsYXkoKSB7XHJcbiAgICBjb25zdCBjdXJyZW50UGFnZSA9IHRoaXMucGx1Z2luLm92ZXJsYXkuZ2V0Q3VycmVudFBhZ2VFbGVtZW50KCk7XHJcbiAgICBpZiAoY3VycmVudFBhZ2UpIHtcclxuICAgICAgYXdhaXQgdGhpcy5hZGRPdmVybGF5VG9QYWdlKGN1cnJlbnRQYWdlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG5ldyBOb3RpY2UoJ05vIGFjdGl2ZSBQREYgcGFnZSBmb3VuZC4nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9yY2hlc3RyYXRlcyB0aGUgZW50aXJlIHRyYW5zbGF0aW9uIGFuZCByZW5kZXJpbmcgcHJvY2VzcyBmb3IgYSBzaW5nbGUgcGFnZS5cclxuICAgKiBAcGFyYW0gcGFnZUVsZW1lbnQgVGhlIC5wYWdlIGVsZW1lbnQgdG8gYWRkIHRoZSBvdmVybGF5IHRvLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBhc3luYyBhZGRPdmVybGF5VG9QYWdlKHBhZ2VFbGVtZW50OiBIVE1MRWxlbWVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgdHJhbnNsYXRlZFRleHQgPSBhd2FpdCB0aGlzLnRyYW5zbGF0ZVBhZ2VDb250ZW50KHBhZ2VFbGVtZW50KTtcclxuICAgICAgaWYgKHRyYW5zbGF0ZWRUZXh0KSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVPdmVybGF5V2l0aFRleHQocGFnZUVsZW1lbnQsIHRyYW5zbGF0ZWRUZXh0KTtcclxuICAgICAgICBjb25zdCBzdWNjZXNzZnVsVHJhbnNsYXRpb25zID0gdHJhbnNsYXRlZFRleHQuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IGxpbmUgIT09ICdUcmFuc2xhdGlvbiBtaXNzaW5nJykubGVuZ3RoO1xyXG4gICAgICAgIG5ldyBOb3RpY2UoYFx1MjcwNSBUcmFuc2xhdGlvbiBjb21wbGV0ZS4gUmVuZGVyZWQgJHtzdWNjZXNzZnVsVHJhbnNsYXRpb25zfSBzZWdtZW50KHMpLmAsIDMwMDApO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcImFkZE92ZXJsYXlUb1BhZ2UgcHJvY2VzcyBmYWlsZWQ6XCIsIGVycm9yKTtcclxuICAgICAgICBuZXcgTm90aWNlKGBcdTI2QTBcdUZFMEYgVHJhbnNsYXRpb24gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCwgNDAwMCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeHRyYWN0cyB0ZXh0LCBnZXRzIHRoZSB0cmFuc2xhdGlvbiwgYnV0IGRvZXMgTk9UIG1vZGlmeSB0aGUgRE9NLlxyXG4gICAqIEBwYXJhbSBwYWdlRWxlbWVudCBUaGUgLnBhZ2UgZWxlbWVudCB0byBwcm9jZXNzLlxyXG4gICAqIEByZXR1cm5zIEEgc2luZ2xlIHN0cmluZyBjb250YWluaW5nIGFsbCB0cmFuc2xhdGVkIHRleHQsIG9yIG51bGwgaWYgZmFpbGVkLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBhc3luYyB0cmFuc2xhdGVQYWdlQ29udGVudChwYWdlRWxlbWVudDogSFRNTEVsZW1lbnQpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICAgIGNvbnN0IHRleHRMYXllciA9IHBhZ2VFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy50ZXh0TGF5ZXInKSBhcyBIVE1MRWxlbWVudDtcclxuICAgIGlmICghdGV4dExheWVyKSB7XHJcbiAgICAgIG5ldyBOb3RpY2UoJ1RleHQgbGF5ZXIgbm90IGZvdW5kLiBXYWl0IGZvciBQREYgdG8gZnVsbHkgcmVuZGVyLicpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0cmFuc2xhdGlvblVuaXRzID0gdGhpcy5wcmVwYXJlVHJhbnNsYXRpb25Vbml0cyh0ZXh0TGF5ZXIsIHBhZ2VFbGVtZW50KTtcclxuICAgIGlmICghdHJhbnNsYXRpb25Vbml0cyB8fCB0cmFuc2xhdGlvblVuaXRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBuZXcgTm90aWNlKCdObyB2YWxpZCB0ZXh0IHRvIHRyYW5zbGF0ZS4nLCAyMDAwKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5sYXN0UHJlcGFyZWRVbml0cyA9IHsgcGFnZUVsZW1lbnQsIHVuaXRzOiBbLi4udHJhbnNsYXRpb25Vbml0c10gfTtcclxuICAgIGNvbnN0IHRyYW5zbGF0ZWRMaW5lcyA9IGF3YWl0IHRoaXMuZXhlY3V0ZVRyYW5zbGF0aW9uKHRyYW5zbGF0aW9uVW5pdHMpO1xyXG4gICAgcmV0dXJuIHRyYW5zbGF0ZWRMaW5lcy5qb2luKCdcXG4nKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gb3ZlcmxheSBvbiB0aGUgcGFnZSB1c2luZyBwcmUtdHJhbnNsYXRlZCB0ZXh0LlxyXG4gICAqIEBwYXJhbSBwYWdlRWxlbWVudCBUaGUgLnBhZ2UgZWxlbWVudCB0byBhZGQgdGhlIG92ZXJsYXkgdG8uXHJcbiAgICogQHBhcmFtIHRyYW5zbGF0ZWRUZXh0IEEgc2luZ2xlIHN0cmluZyBvZiB0cmFuc2xhdGVkIHRleHQsIHdpdGggbGluZXMgc2VwYXJhdGVkIGJ5ICdcXG4nLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBhc3luYyBjcmVhdGVPdmVybGF5V2l0aFRleHQocGFnZUVsZW1lbnQ6IEhUTUxFbGVtZW50LCB0cmFuc2xhdGVkVGV4dDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBwcmVwUmVzdWx0ID0gdGhpcy52YWxpZGF0ZUFuZFByZXBhcmVQcmVyZXF1aXNpdGVzKHBhZ2VFbGVtZW50KTtcclxuICAgIGlmICghcHJlcFJlc3VsdCkgcmV0dXJuO1xyXG4gICAgY29uc3QgeyB0ZXh0TGF5ZXIsIG92ZXJsYXlDb250YWluZXIgfSA9IHByZXBSZXN1bHQ7XHJcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJzLnB1c2gob3ZlcmxheUNvbnRhaW5lcik7XHJcblxyXG4gICAgbGV0IHRyYW5zbGF0aW9uVW5pdHMgPSAodGhpcy5sYXN0UHJlcGFyZWRVbml0cz8ucGFnZUVsZW1lbnQgPT09IHBhZ2VFbGVtZW50KVxyXG4gICAgICAgID8gdGhpcy5sYXN0UHJlcGFyZWRVbml0cy51bml0c1xyXG4gICAgICAgIDogdGhpcy5wcmVwYXJlVHJhbnNsYXRpb25Vbml0cyh0ZXh0TGF5ZXIsIHBhZ2VFbGVtZW50KTtcclxuXHJcbiAgICBpZiAoIXRyYW5zbGF0aW9uVW5pdHMgfHwgdHJhbnNsYXRpb25Vbml0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBvdmVybGF5Q29udGFpbmVyLnJlbW92ZSgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0cmFuc2xhdGVkTGluZXMgPSB0cmFuc2xhdGVkVGV4dC5zcGxpdCgnXFxuJyk7XHJcbiAgICBpZiAodHJhbnNsYXRlZExpbmVzLmxlbmd0aCAhPT0gdHJhbnNsYXRpb25Vbml0cy5sZW5ndGgpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdUcmFuc2xhdGlvbiBzdHJ1Y3R1cmUgbWlzbWF0Y2guIE9yaWdpbmFsIHVuaXRzOicsIHRyYW5zbGF0aW9uVW5pdHMubGVuZ3RoLCAnVHJhbnNsYXRlZCBsaW5lczonLCB0cmFuc2xhdGVkTGluZXMubGVuZ3RoKTtcclxuICAgICAgICBuZXcgTm90aWNlKCdcdTI2QTBcdUZFMEYgRXJyb3I6IFRyYW5zbGF0aW9uIHN0cnVjdHVyZSBtaXNtYXRjaC4gQ2Fubm90IGNyZWF0ZSBvdmVybGF5LicpO1xyXG4gICAgICAgIG92ZXJsYXlDb250YWluZXIucmVtb3ZlKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucmVuZGVyT3ZlcmxheSh0cmFuc2xhdGlvblVuaXRzLCB0cmFuc2xhdGVkTGluZXMsIG92ZXJsYXlDb250YWluZXIsIHBhZ2VFbGVtZW50KTtcclxuXHJcbiAgICBpZiAodGhpcy5wbHVnaW4uc2V0dGluZ3MuYXV0b1NhdmVPdmVybGF5KSB7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMucGx1Z2luLm92ZXJsYXkuc2F2ZUN1cnJlbnRQYWdlT3ZlcmxheSgpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFxyXG4gIC8vIENPUkUgTE9HSUMgKE5vdyBtb3JlIG1vZHVsYXIgZm9yIHJldXNlKVxyXG4gIC8vIFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFx1MjAxNFxyXG5cclxuICBwcml2YXRlIHZhbGlkYXRlQW5kUHJlcGFyZVByZXJlcXVpc2l0ZXMocGFnZUVsZW1lbnQ6IEhUTUxFbGVtZW50KTogeyB0ZXh0TGF5ZXI6IEhUTUxFbGVtZW50OyBvdmVybGF5Q29udGFpbmVyOiBIVE1MRWxlbWVudCB9IHwgbnVsbCB7XHJcbiAgICBpZiAoIXRoaXMudmFsaWRhdGVQYWdlRWxlbWVudChwYWdlRWxlbWVudCkpIHtcclxuICAgICAgbmV3IE5vdGljZSgnSW52YWxpZCBwYWdlIGVsZW1lbnQnKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvdmVybGF5Q29udGFpbmVyID0gdGhpcy5wbHVnaW4ub3ZlcmxheS5wcmVwYXJlUGFnZUZvck92ZXJsYXkocGFnZUVsZW1lbnQpO1xyXG4gICAgY29uc3QgdGV4dExheWVyID0gcGFnZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLnRleHRMYXllcicpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgaWYgKCF0ZXh0TGF5ZXIpIHtcclxuICAgICAgbmV3IE5vdGljZSgnVGV4dCBsYXllciBub3QgZm91bmQuIFdhaXQgZm9yIFBERiB0byBmdWxseSByZW5kZXIuJyk7XHJcbiAgICAgIG92ZXJsYXlDb250YWluZXIucmVtb3ZlKCk7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgdGV4dExheWVyLCBvdmVybGF5Q29udGFpbmVyIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNT0RJRklFRDogTm93IGEgcHVibGljIG1ldGhvZCB0aGF0IGNhbiBhY2NlcHQgZWl0aGVyIHRoZSB0ZXh0TGF5ZXIgZWxlbWVudFxyXG4gICAqIHRvIHByb2Nlc3MgYSB3aG9sZSBwYWdlLCBvciBhIHNwZWNpZmljIGFycmF5IG9mIHNwYW5zIGZvciByZXByb2Nlc3NpbmcuXHJcbiAgICogQHBhcmFtIHRleHRMYXllck9yU3BhbnMgVGhlIHBhcmVudCAudGV4dExheWVyIGVsZW1lbnQgT1IgYW4gYXJyYXkgb2YgSFRNTFNwYW5FbGVtZW50LlxyXG4gICAqIEBwYXJhbSBwYWdlRWxlbWVudCBUaGUgcm9vdCAucGFnZSBlbGVtZW50IGZvciBjb250ZXh0LlxyXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIFRyYW5zbGF0aW9uVW5pdFtdIG9yIG51bGwuXHJcbiAgICovXHJcbiAgcHVibGljIHByZXBhcmVUcmFuc2xhdGlvblVuaXRzKHRleHRMYXllck9yU3BhbnM6IEhUTUxFbGVtZW50IHwgSFRNTFNwYW5FbGVtZW50W10sIHBhZ2VFbGVtZW50OiBIVE1MRWxlbWVudCk6IFRyYW5zbGF0aW9uVW5pdFtdIHwgbnVsbCB7XHJcbiAgICBjb25zdCByYXdTcGFucyA9IEFycmF5LmlzQXJyYXkodGV4dExheWVyT3JTcGFucylcclxuICAgICAgPyB0ZXh0TGF5ZXJPclNwYW5zXHJcbiAgICAgIDogQXJyYXkuZnJvbSh0ZXh0TGF5ZXJPclNwYW5zLnF1ZXJ5U2VsZWN0b3JBbGw8SFRNTFNwYW5FbGVtZW50Pignc3BhbicpKTtcclxuXHJcbiAgICBjb25zdCB0ZXh0U3BhbnMgPSB0aGlzLnZhbGlkYXRlU3BhbnMocmF3U3BhbnMpLmZpbHRlcihzcGFuID0+IHRoaXMuaXNWYWxpZFNwYW4oc3BhbikpO1xyXG5cclxuICAgIGlmICh0ZXh0U3BhbnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMubGF5b3V0RGV0ZWN0b3IuZGV0ZWN0TGF5b3V0KHRleHRTcGFucywgcGFnZUVsZW1lbnQpO1xyXG4gICAgdGhpcy5sYXN0Q29sdW1uQW5hbHlzaXMgPSByZXN1bHQuY29sdW1uQW5hbHlzaXM7XHJcbiAgICB0aGlzLmNsZWFyQ2FjaGVzKCk7XHJcblxyXG4gICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLmRlYnVnTW9kZSkge1xyXG4gICAgICBjb25zb2xlLmxvZyhgUERGIFRyYW5zbGF0b3I6IEZvdW5kICR7cmVzdWx0LnBhcmFncmFwaHMubGVuZ3RofSBwYXJhZ3JhcGgocykgdG8gcHJvY2Vzcy5gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IG1heEJhdGNoQ2hhcnMgfSA9IHRoaXMucGx1Z2luLnNldHRpbmdzO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQucGFyYWdyYXBocy5mbGF0TWFwKChwYXJhZ3JhcGhTcGFucywgcGFyYUluZGV4KSA9PiB7XHJcbiAgICAgIGlmICghcGFyYWdyYXBoU3BhbnMgfHwgcGFyYWdyYXBoU3BhbnMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XHJcbiAgICAgIGNvbnN0IHBhcmFncmFwaElkID0gYHBhcmEtJHtwYXJhSW5kZXh9YDtcclxuICAgICAgY29uc3QgcGFyYWdyYXBoQXNIdG1sID0gdGhpcy5zcGFuc1RvSHRtbChwYXJhZ3JhcGhTcGFucyk7XHJcblxyXG4gICAgICBpZiAocGFyYWdyYXBoQXNIdG1sLmxlbmd0aCA8PSBtYXhCYXRjaENoYXJzKSB7XHJcbiAgICAgICAgaWYgKHBhcmFncmFwaEFzSHRtbC5sZW5ndGggPD0gNSkgcmV0dXJuIFtdO1xyXG4gICAgICAgIHJldHVybiBbe1xyXG4gICAgICAgICAgb3JpZ2luYWxTcGFuczogcGFyYWdyYXBoU3BhbnMsXHJcbiAgICAgICAgICB0ZXh0OiBwYXJhZ3JhcGhBc0h0bWwsXHJcbiAgICAgICAgICBpZDogcGFyYWdyYXBoSWQsXHJcbiAgICAgICAgICBwYXJhZ3JhcGhJZDogcGFyYWdyYXBoSWQsXHJcbiAgICAgICAgfV07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWJ1Z01vZGUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgUERGIFRyYW5zbGF0b3I6IFBhcmFncmFwaCAke3BhcmFJbmRleH0gaXMgdG9vIGxvbmcsIHNwbGl0dGluZyBpbnRvIHNlbnRlbmNlcy5gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgc29ydGVkU3BhbnMgPSBbLi4ucGFyYWdyYXBoU3BhbnNdLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICBjb25zdCByZWN0QSA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0Q2FjaGVkKGEpO1xyXG4gICAgICAgIGNvbnN0IHJlY3RCID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3RDYWNoZWQoYik7XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHJlY3RBLnRvcCAtIHJlY3RCLnRvcCkgPiA1KSByZXR1cm4gcmVjdEEudG9wIC0gcmVjdEIudG9wO1xyXG4gICAgICAgIHJldHVybiByZWN0QS5sZWZ0IC0gcmVjdEIubGVmdDtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBzZW50ZW5jZVNwYW5Hcm91cHM6IEhUTUxTcGFuRWxlbWVudFtdW10gPSBbXTtcclxuICAgICAgbGV0IGN1cnJlbnRTZW50ZW5jZVNwYW5zOiBIVE1MU3BhbkVsZW1lbnRbXSA9IFtdO1xyXG4gICAgICBjb25zdCBzZW50ZW5jZUVuZFJlZ2V4ID0gL1suPyFdXFxzKiQvO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBzcGFuIG9mIHNvcnRlZFNwYW5zKSB7XHJcbiAgICAgICAgY3VycmVudFNlbnRlbmNlU3BhbnMucHVzaChzcGFuKTtcclxuICAgICAgICBpZiAoc2VudGVuY2VFbmRSZWdleC50ZXN0KChzcGFuLnRleHRDb250ZW50IHx8ICcnKS50cmltKCkpKSB7XHJcbiAgICAgICAgICBzZW50ZW5jZVNwYW5Hcm91cHMucHVzaChjdXJyZW50U2VudGVuY2VTcGFucyk7XHJcbiAgICAgICAgICBjdXJyZW50U2VudGVuY2VTcGFucyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoY3VycmVudFNlbnRlbmNlU3BhbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHNlbnRlbmNlU3Bhbkdyb3Vwcy5wdXNoKGN1cnJlbnRTZW50ZW5jZVNwYW5zKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHNlbnRlbmNlU3Bhbkdyb3Vwc1xyXG4gICAgICAgIC5tYXAoKHNwYW5zLCBzZW50ZW5jZUluZGV4KSA9PiB7XHJcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5zcGFuc1RvSHRtbChzcGFucyk7XHJcbiAgICAgICAgICBpZiAoIXRleHQgfHwgdGV4dC5sZW5ndGggPD0gNSkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvcmlnaW5hbFNwYW5zOiBzcGFucyxcclxuICAgICAgICAgICAgdGV4dCxcclxuICAgICAgICAgICAgaWQ6IGAke3BhcmFncmFwaElkfS1zZW50LSR7c2VudGVuY2VJbmRleH1gLFxyXG4gICAgICAgICAgICBwYXJhZ3JhcGhJZDogcGFyYWdyYXBoSWQsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmZpbHRlcigodW5pdCk6IHVuaXQgaXMgVHJhbnNsYXRpb25Vbml0ID0+ICEhdW5pdCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1PRElGSUVEOiBOb3cgYSBwdWJsaWMgbWV0aG9kLlxyXG4gICAqIEV4ZWN1dGVzIHRoZSB0cmFuc2xhdGlvbiBwcm9jZXNzIGZvciBhIGdpdmVuIHNldCBvZiB0ZXh0IHVuaXRzLlxyXG4gICAqIEBwYXJhbSB1bml0cyBUaGUgdGV4dCB1bml0cyB0byBiZSB0cmFuc2xhdGVkLlxyXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIHRyYW5zbGF0ZWQgc3RyaW5ncy5cclxuICAgKi9cclxuICBwdWJsaWMgYXN5bmMgZXhlY3V0ZVRyYW5zbGF0aW9uKHVuaXRzOiBUcmFuc2xhdGlvblVuaXRbXSk6IFByb21pc2U8c3RyaW5nW10+IHtcclxuICAgIHRoaXMudHJhbnNsYXRpb25GYWlsdXJlcyA9IFtdO1xyXG4gICAgY29uc3QgZnVsbFRleHQgPSB1bml0cy5tYXAoKHUsIGkpID0+IGAke2kgKyAxfS4gJHt1LnRleHR9YCkuam9pbignXFxuJyk7XHJcbiAgICBjb25zdCB7IHVzZUJhdGNoVHJhbnNsYXRpb246IHVzZUJhdGNoLCBtYXhCYXRjaENoYXJzIH0gPSB0aGlzLnBsdWdpbi5zZXR0aW5ncztcclxuICAgIFxyXG4gICAgY29uc3Qgc2hvdWxkVXNlQ2h1bmtpbmcgPSB1c2VCYXRjaCAmJiB1bml0cy5sZW5ndGggPiAxICYmIGZ1bGxUZXh0Lmxlbmd0aCA+IG1heEJhdGNoQ2hhcnM7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICBsZXQgdHJhbnNsYXRlZExpbmVzOiBzdHJpbmdbXTtcclxuICAgICAgICBpZiAoc2hvdWxkVXNlQ2h1bmtpbmcpIHtcclxuICAgICAgICAgICAgbmV3IE5vdGljZShgTG9uZyBwYWdlIGRldGVjdGVkLiBUcmFuc2xhdGluZyBpbiBtdWx0aXBsZSBiYXRjaGVzLi4uYCwgNDAwMCk7XHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZWRMaW5lcyA9IGF3YWl0IHRoaXMucGVyZm9ybUNodW5rZWRUcmFuc2xhdGlvbih1bml0cywgbWF4QmF0Y2hDaGFycyk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh1c2VCYXRjaCAmJiB1bml0cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFRyYW5zbGF0aW5nICR7dW5pdHMubGVuZ3RofSBzZWdtZW50cyBpbiBhIGJhdGNoLi4uYCwgMzAwMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhdyA9IGF3YWl0IHRoaXMucGx1Z2luLnRyYW5zbGF0aW9uLnRyYW5zbGF0ZUJhdGNoKGZ1bGxUZXh0LCB1bml0cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICB0cmFuc2xhdGVkTGluZXMgPSB0aGlzLmV4dHJhY3ROdW1iZXJlZExpbmVzKHJhdywgdW5pdHMubGVuZ3RoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuZXcgTm90aWNlKGBUcmFuc2xhdGluZyAke3VuaXRzLmxlbmd0aH0gc2VnbWVudChzKSBzZXF1ZW50aWFsbHkuLi5gLCAzMDAwKTtcclxuICAgICAgICAgICAgdHJhbnNsYXRlZExpbmVzID0gYXdhaXQgdGhpcy5wZXJmb3JtU2VxdWVudGlhbFRyYW5zbGF0aW9uKHVuaXRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICBjb25zdCBtaXNzaW5nQ291bnQgPSB0cmFuc2xhdGVkTGluZXMuZmlsdGVyKHQgPT4gdCA9PT0gJ1RyYW5zbGF0aW9uIG1pc3NpbmcnKS5sZW5ndGg7XHJcbiAgICAgIGlmIChtaXNzaW5nQ291bnQgPiAwLjUgKiB1bml0cy5sZW5ndGggJiYgdW5pdHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIG5ldyBOb3RpY2UoJ1x1MjZBMFx1RkUwRiBJbnZhbGlkIHJlc3BvbnNlLiBGYWxsaW5nIGJhY2sgdG8gb3JpZ2luYWwgdGV4dC4nKTtcclxuICAgICAgICByZXR1cm4gdW5pdHMubWFwKHUgPT4gdS50ZXh0KTtcclxuICAgICAgfSBlbHNlIGlmIChtaXNzaW5nQ291bnQgPiAwKSB7XHJcbiAgICAgICAgbmV3IE5vdGljZShgXHUyNkEwXHVGRTBGICR7bWlzc2luZ0NvdW50fSBzZWdtZW50cyBmYWlsZWQgdHJhbnNsYXRpb24uIFNlZSBjb25zb2xlIGZvciBkZXRhaWxzLmApO1xyXG4gICAgICAgIHRoaXMucmVwb3J0VHJhbnNsYXRpb25GYWlsdXJlcyh1bml0cywgdHJhbnNsYXRlZExpbmVzKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJhbnNsYXRlZExpbmVzO1xyXG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgdGhpcy5wbHVnaW4ubG9nRGVidWcoJ1RyYW5zbGF0aW9uIGZhaWxlZDonLCBlcnIpO1xyXG4gICAgICB0aGlzLnRyYW5zbGF0aW9uRmFpbHVyZXMucHVzaCh7XHJcbiAgICAgICAgc2VnbWVudEluZGV4OiAtMSxcclxuICAgICAgICBlcnJvcjogYEJhdGNoIHRyYW5zbGF0aW9uIGZhaWxlZDogJHtlcnIubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCxcclxuICAgICAgfSk7XHJcbiAgICAgIHRocm93IGVycjtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcHJpdmF0ZSBhc3luYyBwZXJmb3JtQ2h1bmtlZFRyYW5zbGF0aW9uKHVuaXRzOiBUcmFuc2xhdGlvblVuaXRbXSwgbWF4Q2h1bmtDaGFyczogbnVtYmVyKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xyXG4gICAgY29uc3QgYWxsVHJhbnNsYXRlZExpbmVzOiBzdHJpbmdbXSA9IEFycmF5KHVuaXRzLmxlbmd0aCkuZmlsbCgnVHJhbnNsYXRpb24gbWlzc2luZycpO1xyXG4gICAgaW50ZXJmYWNlIENodW5rIHsgdGV4dDogc3RyaW5nOyBvcmlnaW5hbEluZGljZXM6IG51bWJlcltdOyB9XHJcblxyXG4gICAgY29uc3QgZW5kc1dpdGhTZW50ZW5jZVRlcm1pbmF0b3IgPSAoaHRtbFRleHQ6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xyXG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSBodG1sVGV4dC50cmltKCk7XHJcbiAgICAgICAgaWYgKHRyaW1tZWQuZW5kc1dpdGgoJzxicj4nKSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgY29uc3QgcmVnZXggPSAvWy4/IV0oPzpcXHMqPFxcL1tiaV0+KSpcXHMqJC87XHJcbiAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QodHJpbW1lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGNodW5rczogQ2h1bmtbXSA9IFtdO1xyXG4gICAgbGV0IGN1cnJlbnRDaHVua1RleHQgPSAnJztcclxuICAgIGxldCBjdXJyZW50Q2h1bmtJbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5pdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCB1bml0ID0gdW5pdHNbaV07XHJcbiAgICAgICAgY29uc3QgbGluZSA9IGAke2N1cnJlbnRDaHVua0luZGljZXMubGVuZ3RoICsgMX0uICR7dW5pdC50ZXh0fVxcbmA7XHJcblxyXG4gICAgICAgIGlmIChjdXJyZW50Q2h1bmtUZXh0Lmxlbmd0aCArIGxpbmUubGVuZ3RoID4gbWF4Q2h1bmtDaGFycyAmJiBjdXJyZW50Q2h1bmtUZXh0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgbGFzdFVuaXRJbmRleCA9IGN1cnJlbnRDaHVua0luZGljZXNbY3VycmVudENodW5rSW5kaWNlcy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgY29uc3QgbGFzdFVuaXQgPSB1bml0c1tsYXN0VW5pdEluZGV4XTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2h1bmtJbmRpY2VzLmxlbmd0aCA+IDEgJiYgIWVuZHNXaXRoU2VudGVuY2VUZXJtaW5hdG9yKGxhc3RVbml0LnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmtJbmRpY2VzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q2h1bmtUZXh0ID0gY3VycmVudENodW5rSW5kaWNlcy5tYXAoKG9yaWdpbmFsSW5kZXgsIG5ld0luZGV4KSA9PiBgJHtuZXdJbmRleCArIDF9LiAke3VuaXRzW29yaWdpbmFsSW5kZXhdLnRleHR9YCkuam9pbignXFxuJyk7XHJcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaCh7IHRleHQ6IG5ld0NodW5rVGV4dCwgb3JpZ2luYWxJbmRpY2VzOiBbLi4uY3VycmVudENodW5rSW5kaWNlc10gfSk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmtUZXh0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmtJbmRpY2VzID0gW107XHJcbiAgICAgICAgICAgICAgICBpID0gbGFzdFVuaXRJbmRleCAtIDE7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaCh7IHRleHQ6IGN1cnJlbnRDaHVua1RleHQudHJpbSgpLCBvcmlnaW5hbEluZGljZXM6IFsuLi5jdXJyZW50Q2h1bmtJbmRpY2VzXSB9KTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVua1RleHQgPSAnJztcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVua0luZGljZXMgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Q2h1bmtUZXh0ICs9IGAke2N1cnJlbnRDaHVua0luZGljZXMubGVuZ3RoICsgMX0uICR7dW5pdC50ZXh0fVxcbmA7XHJcbiAgICAgICAgY3VycmVudENodW5rSW5kaWNlcy5wdXNoKGkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoY3VycmVudENodW5rVGV4dC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY2h1bmtzLnB1c2goeyB0ZXh0OiBjdXJyZW50Q2h1bmtUZXh0LnRyaW0oKSwgb3JpZ2luYWxJbmRpY2VzOiBjdXJyZW50Q2h1bmtJbmRpY2VzIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWJ1Z01vZGUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgUERGIFRyYW5zbGF0b3I6IFNwbGl0dGluZyB0cmFuc2xhdGlvbiBpbnRvICR7Y2h1bmtzLmxlbmd0aH0gY2h1bmtzLmApO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2h1bmsgPSBjaHVua3NbaV07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbmV3IE5vdGljZShgVHJhbnNsYXRpbmcgYmF0Y2ggJHtpICsgMX0gb2YgJHtjaHVua3MubGVuZ3RofS4uLmApO1xyXG4gICAgICAgICAgICBjb25zdCByYXcgPSBhd2FpdCB0aGlzLnBsdWdpbi50cmFuc2xhdGlvbi50cmFuc2xhdGVCYXRjaChjaHVuay50ZXh0LCBjaHVuay5vcmlnaW5hbEluZGljZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlZENodW5rTGluZXMgPSB0aGlzLmV4dHJhY3ROdW1iZXJlZExpbmVzKHJhdywgY2h1bmsub3JpZ2luYWxJbmRpY2VzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdHJhbnNsYXRlZENodW5rTGluZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSW5kZXggPSBjaHVuay5vcmlnaW5hbEluZGljZXNbal07XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxJbmRleCAhPT0gdW5kZWZpbmVkKSBhbGxUcmFuc2xhdGVkTGluZXNbb3JpZ2luYWxJbmRleF0gPSB0cmFuc2xhdGVkQ2h1bmtMaW5lc1tqXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4ubG9nRGVidWcoYFRyYW5zbGF0aW9uIGZvciBjaHVuayAke2krMX0gZmFpbGVkOmAsIGVycm9yKTtcclxuICAgICAgICAgICAgbmV3IE5vdGljZShgXHUyNkEwXHVGRTBGIEJhdGNoICR7aSsxfSBmYWlsZWQuIE9yaWdpbmFsIHRleHQgd2lsbCBiZSB1c2VkIGZvciB0aGF0IHNlY3Rpb24uYCk7XHJcbiAgICAgICAgICAgIGNodW5rLm9yaWdpbmFsSW5kaWNlcy5mb3JFYWNoKG9yaWdpbmFsSW5kZXggPT4geyBhbGxUcmFuc2xhdGVkTGluZXNbb3JpZ2luYWxJbmRleF0gPSB1bml0c1tvcmlnaW5hbEluZGV4XS50ZXh0OyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWxsVHJhbnNsYXRlZExpbmVzO1xyXG4gIH1cclxuICBcclxuICBwcml2YXRlIHJlbmRlck92ZXJsYXkodW5pdHM6IFRyYW5zbGF0aW9uVW5pdFtdLCB0cmFuc2xhdGVkTGluZXM6IHN0cmluZ1tdLCBvdmVybGF5Q29udGFpbmVyOiBIVE1MRWxlbWVudCwgcGFnZUVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XHJcbiAgICBjb25zdCByZWFzc2VtYmxlZFBhcmFncmFwaHMgPSBuZXcgTWFwPHN0cmluZywgeyBvcmlnaW5hbFNwYW5zOiBIVE1MU3BhbkVsZW1lbnRbXTsgdHJhbnNsYXRlZFRleHQ6IHN0cmluZzsgfT4oKTtcclxuICAgIHVuaXRzLmZvckVhY2goKHVuaXQsIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgcGFyYWdyYXBoSWQsIG9yaWdpbmFsU3BhbnMgfSA9IHVuaXQ7XHJcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZWRMaW5lID0gdHJhbnNsYXRlZExpbmVzW2luZGV4XTtcclxuICAgICAgaWYgKCFyZWFzc2VtYmxlZFBhcmFncmFwaHMuaGFzKHBhcmFncmFwaElkKSkgcmVhc3NlbWJsZWRQYXJhZ3JhcGhzLnNldChwYXJhZ3JhcGhJZCwgeyBvcmlnaW5hbFNwYW5zOiBbXSwgdHJhbnNsYXRlZFRleHQ6ICcnIH0pO1xyXG4gICAgICBjb25zdCBncm91cCA9IHJlYXNzZW1ibGVkUGFyYWdyYXBocy5nZXQocGFyYWdyYXBoSWQpITtcclxuICAgICAgZ3JvdXAub3JpZ2luYWxTcGFucy5wdXNoKC4uLm9yaWdpbmFsU3BhbnMpO1xyXG4gICAgICBncm91cC50cmFuc2xhdGVkVGV4dCArPSAoZ3JvdXAudHJhbnNsYXRlZFRleHQgPyAnICcgOiAnJykgKyB0cmFuc2xhdGVkTGluZTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IG1lcmdlZFVuaXRzOiBUcmFuc2xhdGlvblVuaXRbXSA9IFtdO1xyXG4gICAgY29uc3QgbWVyZ2VkVHJhbnNsYXRlZExpbmVzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgcmVhc3NlbWJsZWRQYXJhZ3JhcGhzLmZvckVhY2goKGdyb3VwLCBwYXJhZ3JhcGhJZCkgPT4ge1xyXG4gICAgICBtZXJnZWRVbml0cy5wdXNoKHsgaWQ6IHBhcmFncmFwaElkLCBwYXJhZ3JhcGhJZDogcGFyYWdyYXBoSWQsIG9yaWdpbmFsU3BhbnM6IGdyb3VwLm9yaWdpbmFsU3BhbnMsIHRleHQ6ICcnIH0pO1xyXG4gICAgICBtZXJnZWRUcmFuc2xhdGVkTGluZXMucHVzaChncm91cC50cmFuc2xhdGVkVGV4dCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnBsdWdpbi5vdmVybGF5LnJlbmRlck92ZXJsYXlzKG1lcmdlZFVuaXRzLCBtZXJnZWRUcmFuc2xhdGVkTGluZXMsIG92ZXJsYXlDb250YWluZXIsIHBhZ2VFbGVtZW50KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3BhbnNUb0h0bWwoc3BhbnM6IEhUTUxTcGFuRWxlbWVudFtdKTogc3RyaW5nIHtcclxuICAgIGlmICghc3BhbnM/Lmxlbmd0aCkgcmV0dXJuICcnO1xyXG4gICAgY29uc3QgbGluZXMgPSBuZXcgTWFwPG51bWJlciwgSFRNTFNwYW5FbGVtZW50W10+KCk7XHJcbiAgICBzcGFucy5mb3JFYWNoKHNwYW4gPT4ge1xyXG4gICAgICBjb25zdCBsaW5lS2V5ID0gTWF0aC5yb3VuZCh0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdENhY2hlZChzcGFuKS50b3ApO1xyXG4gICAgICBpZiAoIWxpbmVzLmhhcyhsaW5lS2V5KSkgbGluZXMuc2V0KGxpbmVLZXksIFtdKTtcclxuICAgICAgbGluZXMuZ2V0KGxpbmVLZXkpIS5wdXNoKHNwYW4pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbShsaW5lcy5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdKS5tYXAoKFtfLCBsaW5lU3BhbnNdKSA9PiBsaW5lU3BhbnMuc29ydCgoYSwgYikgPT4gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3RDYWNoZWQoYSkubGVmdCAtIHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0Q2FjaGVkKGIpLmxlZnQpLm1hcChzcGFuID0+IHtcclxuICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLmdldENvbXB1dGVkU3R5bGVDYWNoZWQoc3Bhbik7XHJcbiAgICAgIGxldCBjb250ZW50ID0gdGhpcy5lc2NhcGVIdG1sKHNwYW4udGV4dENvbnRlbnQgfHwgJycpO1xyXG4gICAgICBjb25zdCBpc0JvbGQgPSBwYXJzZUludChzdHlsZS5mb250V2VpZ2h0LCAxMCkgPj0gNzAwIHx8IHN0eWxlLmZvbnRXZWlnaHQgPT09ICdib2xkJztcclxuICAgICAgaWYgKGlzQm9sZCkgY29udGVudCA9IGA8Yj4ke2NvbnRlbnR9PC9iPmA7XHJcbiAgICAgIGlmIChzdHlsZS5mb250U3R5bGUgPT09ICdpdGFsaWMnKSBjb250ZW50ID0gYDxpPiR7Y29udGVudH08L2k+YDtcclxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgICB9KS5qb2luKCcgJykpLmpvaW4oJzxicj4nKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZXNjYXBlSHRtbCh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcgeyByZXR1cm4gdGV4dC5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpLnJlcGxhY2UoLycvZywgJyYjMDM5OycpOyB9XHJcblxyXG4gIHByaXZhdGUgZXh0cmFjdE51bWJlcmVkTGluZXMocmF3VGV4dDogc3RyaW5nLCBleHBlY3RlZENvdW50OiBudW1iZXIpOiBzdHJpbmdbXSB7XHJcbiAgICBjb25zdCBsaW5lczogc3RyaW5nW10gPSBBcnJheShleHBlY3RlZENvdW50KS5maWxsKCdUcmFuc2xhdGlvbiBtaXNzaW5nJyk7XHJcbiAgICBjb25zdCByZWdleCA9IC9eXFxzKihcXGQrKVxcLlxccysoLis/KSg/OlxcbnwkKS9nbTtcclxuICAgIGxldCBtYXRjaCwgZm91bmQgPSAwO1xyXG4gICAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWMocmF3VGV4dCkpICE9PSBudWxsKSB7XHJcbiAgICAgIGNvbnN0IG51bSA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCkgLSAxO1xyXG4gICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgZXhwZWN0ZWRDb3VudCkge1xyXG4gICAgICAgIGxpbmVzW251bV0gPSBtYXRjaFsyXS50cmltKCk7XHJcbiAgICAgICAgZm91bmQrKztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGZvdW5kIDwgZXhwZWN0ZWRDb3VudCAqIDAuNSAmJiBmb3VuZCA8IGV4cGVjdGVkQ291bnQpIHtcclxuICAgICAgY29uc3QgcmF3TGluZXMgPSByYXdUZXh0LnRyaW0oKS5zcGxpdCgnXFxuJykubWFwKGwgPT4gbC50cmltKCkucmVwbGFjZSgvXlxccypcXGQrXFwuXFxzKi8sICcnKSk7XHJcbiAgICAgIGlmIChyYXdMaW5lcy5sZW5ndGggPT09IGV4cGVjdGVkQ291bnQpIHJldHVybiByYXdMaW5lcztcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihyYXdMaW5lcy5sZW5ndGgsIGV4cGVjdGVkQ291bnQpOyBpKyspIGxpbmVzW2ldID0gcmF3TGluZXNbaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGluZXM7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgaXNWYWxpZFNwYW4oc3BhbjogSFRNTFNwYW5FbGVtZW50KTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3RDYWNoZWQoc3Bhbik7XHJcbiAgICBjb25zdCB0ZXh0ID0gKHNwYW4udGV4dENvbnRlbnQgfHwgJycpLnRyaW0oKTtcclxuICAgIGlmIChyZWN0LndpZHRoIDw9IDEgfHwgcmVjdC5oZWlnaHQgPD0gMSB8fCAhdGV4dCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYgKC9eXFxkezEsM30kLy50ZXN0KHRleHQpKSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAodGV4dC5sZW5ndGggPT09IDEgJiYgL1tcdTIwMjJcXC1cdTIwMjJcdTAwQkJcdTAwQUJdLy50ZXN0KHRleHQpKSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAodGV4dC5zdGFydHNXaXRoKCdodHRwJykpIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB2YWxpZGF0ZVNwYW5zKHNwYW5zOiBIVE1MU3BhbkVsZW1lbnRbXSk6IEhUTUxTcGFuRWxlbWVudFtdIHsgcmV0dXJuIHNwYW5zLmZpbHRlcihzcGFuID0+IHNwYW4gaW5zdGFuY2VvZiBIVE1MU3BhbkVsZW1lbnQgJiYgc3Bhbi5pc0Nvbm5lY3RlZCk7IH1cclxuICBwcml2YXRlIHZhbGlkYXRlUGFnZUVsZW1lbnQocGFnZUVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7IHJldHVybiBwYWdlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHBhZ2VFbGVtZW50LmlzQ29ubmVjdGVkOyB9XHJcbiAgcHJpdmF0ZSBnZXRCb3VuZGluZ0NsaWVudFJlY3RDYWNoZWQoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBET01SZWN0IHtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLm1lYXN1cmVtZW50Q2FjaGUuZ2V0KGVsZW1lbnQpO1xyXG4gICAgaWYgKGNhY2hlZCAmJiBub3cgLSBjYWNoZWQudGltZXN0YW1wIDwgMTAwKSByZXR1cm4gY2FjaGVkLnJlY3Q7XHJcbiAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHRoaXMubWVhc3VyZW1lbnRDYWNoZS5zZXQoZWxlbWVudCwgeyByZWN0LCB0aW1lc3RhbXA6IG5vdyB9KTtcclxuICAgIHJldHVybiByZWN0O1xyXG4gIH1cclxuICBwcml2YXRlIGdldENvbXB1dGVkU3R5bGVDYWNoZWQoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBDU1NTdHlsZURlY2xhcmF0aW9uIHsgcmV0dXJuIHRoaXMuc3R5bGVDYWNoZS5nZXQoZWxlbWVudCkgfHwgdGhpcy5zdHlsZUNhY2hlLnNldChlbGVtZW50LCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSkuZ2V0KGVsZW1lbnQpITsgfVxyXG4gIHByaXZhdGUgY2xlYXJDYWNoZXMoKTogdm9pZCB7XHJcbiAgICB0aGlzLm1lYXN1cmVtZW50Q2FjaGUuY2xlYXIoKTtcclxuICAgIHRoaXMuc3R5bGVDYWNoZS5jbGVhcigpO1xyXG4gICAgaWYgKHRoaXMuY29sb3JEaXN0YW5jZUNhY2hlLnNpemUgPiAxMDAwKSB0aGlzLmNvbG9yRGlzdGFuY2VDYWNoZS5jbGVhcigpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldFNwYW5zQmJveChzcGFuczogSFRNTFNwYW5FbGVtZW50W10sIHBhZ2VFbGVtZW50OiBIVE1MRWxlbWVudCkge1xyXG4gICAgaWYgKCFzcGFucz8ubGVuZ3RoKSByZXR1cm4geyByZWN0OiBudWxsLCBmb250U2l6ZXM6IFtdLCBhdmdGb250U2l6ZTogMTIsIGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyB9O1xyXG4gICAgY29uc3QgcGFnZVJlY3QgPSBwYWdlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGxldCBsZWZ0ID0gSW5maW5pdHksIHRvcCA9IEluZmluaXR5LCByaWdodCA9IC1JbmZpbml0eSwgYm90dG9tID0gLUluZmluaXR5O1xyXG4gICAgY29uc3QgZm9udFNpemVzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgbGV0IGZvbnRGYW1pbHkgPSAnc2Fucy1zZXJpZic7XHJcbiAgICBmb3IgKGNvbnN0IHNwYW4gb2Ygc3BhbnMpIHtcclxuICAgICAgY29uc3QgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0Q2FjaGVkKHNwYW4pO1xyXG4gICAgICBsZWZ0ID0gTWF0aC5taW4obGVmdCwgcmVjdC5sZWZ0KTsgdG9wID0gTWF0aC5taW4odG9wLCByZWN0LnRvcCk7IHJpZ2h0ID0gTWF0aC5tYXgocmlnaHQsIHJlY3QucmlnaHQpOyBib3R0b20gPSBNYXRoLm1heChib3R0b20sIHJlY3QuYm90dG9tKTtcclxuICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLmdldENvbXB1dGVkU3R5bGVDYWNoZWQoc3Bhbik7XHJcbiAgICAgIGZvbnRTaXplcy5wdXNoKHBhcnNlRmxvYXQoc3R5bGUuZm9udFNpemUpIHx8IDEyKTtcclxuICAgICAgaWYgKGZvbnRGYW1pbHkgPT09ICdzYW5zLXNlcmlmJyAmJiBzdHlsZS5mb250RmFtaWx5KSBmb250RmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseS5zcGxpdCgnLCcpWzBdLnJlcGxhY2UoL1snXCJdL2csICcnKS50cmltKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzRmluaXRlKGxlZnQpKSByZXR1cm4geyByZWN0OiBudWxsLCBmb250U2l6ZXM6IFtdLCBhdmdGb250U2l6ZTogMTIsIGZvbnRGYW1pbHkgfTtcclxuICAgIGNvbnN0IHJlY3QgPSBuZXcgRE9NUmVjdChsZWZ0IC0gcGFnZVJlY3QubGVmdCwgdG9wIC0gcGFnZVJlY3QudG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XHJcbiAgICBjb25zdCBhdmdGb250U2l6ZSA9IGZvbnRTaXplcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIGZvbnRTaXplcy5sZW5ndGggfHwgMTI7XHJcbiAgICByZXR1cm4geyByZWN0LCBmb250U2l6ZXMsIGF2Z0ZvbnRTaXplLCBmb250RmFtaWx5IH07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHBlcmZvcm1TZXF1ZW50aWFsVHJhbnNsYXRpb24odW5pdHM6IFRyYW5zbGF0aW9uVW5pdFtdKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHVuaXRzLm1hcChhc3luYyAodW5pdCwgaSkgPT4ge1xyXG4gICAgICB0cnkgeyByZXR1cm4gYXdhaXQgdGhpcy5wbHVnaW4udHJhbnNsYXRpb24udHJhbnNsYXRlV2l0aE9wZW5Sb3V0ZXIodW5pdC50ZXh0KTsgfVxyXG4gICAgICBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICAgIHRoaXMucGx1Z2luLmxvZ0RlYnVnKGBUcmFuc2xhdGlvbiBmYWlsZWQgZm9yIHNlZ21lbnQgJHtpfTpgLCBlcnJvcik7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGlvbkZhaWx1cmVzLnB1c2goeyBzZWdtZW50SW5kZXg6IGksIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJyB9KTtcclxuICAgICAgICByZXR1cm4gXCJUcmFuc2xhdGlvbiBtaXNzaW5nXCI7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVwb3J0VHJhbnNsYXRpb25GYWlsdXJlcyh1bml0czogVHJhbnNsYXRpb25Vbml0W10sIHRyYW5zbGF0ZWRMaW5lczogc3RyaW5nW10pOiB2b2lkIHtcclxuICAgIHRoaXMudHJhbnNsYXRpb25GYWlsdXJlcy5mb3JFYWNoKCh7IHNlZ21lbnRJbmRleCwgZXJyb3IgfSkgPT4ge1xyXG4gICAgICBpZiAoc2VnbWVudEluZGV4ID49IDApIHRoaXMucGx1Z2luLmxvZ0RlYnVnKGBTZWdtZW50ICR7c2VnbWVudEluZGV4ICsgMX0gZmFpbGVkOmAsIGVycm9yLCBgT3JpZ2luYWw6IFwiJHt1bml0c1tzZWdtZW50SW5kZXhdLnRleHQuc3Vic3RyaW5nKDAsIDEwMCl9Li4uXCJgKTtcclxuICAgICAgZWxzZSB0aGlzLnBsdWdpbi5sb2dEZWJ1ZyhgQmF0Y2ggdHJhbnNsYXRpb24gZmFpbGVkOmAsIGVycm9yKTtcclxuICAgIH0pO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2xhdGVkTGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHRyYW5zbGF0ZWRMaW5lc1tpXSA9PT0gJ1RyYW5zbGF0aW9uIG1pc3NpbmcnKSB7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4ubG9nRGVidWcoYFNlZ21lbnQgJHtpICsgMX0gd2FzIG1pc3NpbmcgZnJvbSB0aGUgYmF0Y2ggcmVzcG9uc2UuIE9yaWdpbmFsOiBcIiR7dW5pdHNbaV0udGV4dC5zdWJzdHJpbmcoMCwgMTAwKX0uLi5cImApO1xyXG4gICAgICAgIHRyYW5zbGF0ZWRMaW5lc1tpXSA9IHVuaXRzW2ldLnRleHQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBjbGVhbnVwKCk6IHZvaWQge1xyXG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVycy5mb3JFYWNoKGNvbnRhaW5lciA9PiBjb250YWluZXIucmVtb3ZlKCkpO1xyXG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVycyA9IFtdO1xyXG4gICAgdGhpcy5jbGVhckNhY2hlcygpO1xyXG4gICAgdGhpcy50cmFuc2xhdGlvbkZhaWx1cmVzID0gW107XHJcbiAgICB0aGlzLmxhc3RDb2x1bW5BbmFseXNpcyA9IG51bGw7XHJcbiAgICB0aGlzLmxhc3RQcmVwYXJlZFVuaXRzID0gbnVsbDtcclxuICB9XHJcbn0iLCAiLy8gR2FwRGV0ZWN0b3IudHNcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2ltcGxlUmVjdCB7XHJcbiAgbGVmdDogbnVtYmVyO1xyXG4gIHRvcDogbnVtYmVyO1xyXG4gIHJpZ2h0OiBudW1iZXI7XHJcbiAgYm90dG9tOiBudW1iZXI7XHJcbiAgd2lkdGg6IG51bWJlcjtcclxuICBoZWlnaHQ6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBHYXBCb3VuZGFyeSB7XHJcbiAgeDogbnVtYmVyO1xyXG4gIGNvbmZpZGVuY2U6IG51bWJlcjtcclxuICB3aWR0aDogbnVtYmVyO1xyXG4gIGhlaWdodDogbnVtYmVyO1xyXG4gIHNlZ21lbnRJbmRleDogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFZlcnRpY2FsU3RyaXAge1xyXG4gIGxlZnQ6IG51bWJlcjtcclxuICByaWdodDogbnVtYmVyO1xyXG4gIHRvcDogbnVtYmVyO1xyXG4gIGJvdHRvbTogbnVtYmVyO1xyXG4gIGNvbmZpZGVuY2U6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBIb3Jpem9udGFsQmFuZCB7XHJcbiAgeTogbnVtYmVyO1xyXG4gIGhlaWdodDogbnVtYmVyO1xyXG4gIGxlZnQ6IG51bWJlcjtcclxuICByaWdodDogbnVtYmVyO1xyXG4gIGNvbmZpZGVuY2U6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBHYXBBbmFseXNpcyB7XHJcbiAgdmVydGljYWxCb3VuZGFyaWVzOiBHYXBCb3VuZGFyeVtdO1xyXG4gIGNvbHVtbnM6IFNpbXBsZVJlY3RbXTtcclxuICBsYXlvdXRTZWdtZW50czogQXJyYXk8eyB0b3A6IG51bWJlcjsgYm90dG9tOiBudW1iZXI7IGxlZnQ6IG51bWJlcjsgcmlnaHQ6IG51bWJlciB9PjtcclxuICB2ZXJ0aWNhbFN0cmlwcz86IFZlcnRpY2FsU3RyaXBbXTtcclxuICBob3Jpem9udGFsQmFuZHM/OiBIb3Jpem9udGFsQmFuZFtdO1xyXG59XHJcblxyXG4vKipcclxuICogUmVoYXVsZWQgR2FwRGV0ZWN0b3JcclxuICogLSBXb3JrcyBvbiBub3JtYWxpemVkIGNvb3JkaW5hdGVzIChEUFIgYWxyZWFkeSBkaXZpZGVkKVxyXG4gKiAtIFVzZXMgeS1iYW5kZWQgb2NjdXBhbmN5IHRvIGJ1aWxkIHJvYnVzdCB2ZXJ0aWNhbCBzdHJpcHMgd2l0aCBjb25maWRlbmNlXHJcbiAqIC0gRXhwb3NlcyBib3RoIGNsYXNzaWMgdmVydGljYWxCb3VuZGFyaWVzIGFuZCBuZXcgdmVydGljYWxTdHJpcHNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBHYXBEZXRlY3RvciB7XHJcbiAgLy8gVHVuaW5nIHBhcmFtZXRlcnNcclxuICBwcml2YXRlIHJlYWRvbmx5IE1JTl9TVFJJUF9DT05GSURFTkNFID0gMC42O1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgTUFYX0NPTFVNTlMgPSA2O1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgTUlOX0dBUF9XSURUSF9QWCA9IDI7ICAgICAgICAgICAvLyBNaW5pbXVtIGhvcml6b250YWwgZ2FwIHdpZHRoIHRvIGNvbnNpZGVyXHJcbiAgcHJpdmF0ZSByZWFkb25seSBCQU5EX1NURVBfRkFDVE9SID0gMC43NTsgICAgICAgIC8vIHN0ZXAgPSBtYXgoNiwgYXZnTGluZUhlaWdodCAqIEJBTkRfU1RFUF9GQUNUT1IpXHJcbiAgcHJpdmF0ZSByZWFkb25seSBNSU5fU1RSSVBfSEVJR0hUX0ZBQ1RPUiA9IDEuNTsgIC8vIG1pbiBzdHJpcCBoZWlnaHQgaW4gbXVsdGlwbGVzIG9mIGF2Z0xpbmVIZWlnaHRcclxuICBwcml2YXRlIHJlYWRvbmx5IENFTlRFUl9YX1RPTF9GQUNUT1IgPSAwLjU7ICAgICAgLy8geCBjbHVzdGVyaW5nIHRvbGVyYW5jZSBpbiBtdWx0aXBsZXMgb2YgYXZnTGluZUhlaWdodFxyXG4gIHByaXZhdGUgcmVhZG9ubHkgV0lEVEhfU1RBQklMSVRZX1dFSUdIVCA9IDAuMjU7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBDRU5URVJfU1RBQklMSVRZX1dFSUdIVCA9IDAuMjU7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBDT1ZFUkFHRV9XRUlHSFQgPSAwLjU7XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBhdGliaWxpdHkgQVBJOiBBY2NlcHRzIERPTSBzcGFucyBhbmQgcGFnZSBlbGVtZW50LCBub3JtYWxpemVzIGJ5IERQUixcclxuICAgKiBhbmQgZGVsZWdhdGVzIHRvIGRldGVjdEdhcHNGcm9tUmVjdHMuXHJcbiAgICovXHJcbiAgcHVibGljIGRldGVjdEdhcHMoc3BhbnM6IEhUTUxTcGFuRWxlbWVudFtdLCBwYWdlRWxlbWVudDogSFRNTEVsZW1lbnQpOiBHYXBBbmFseXNpcyB7XHJcbiAgICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xyXG4gICAgY29uc3QgcGFnZVJlY3RSYXcgPSBwYWdlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGNvbnN0IHBhZ2VSZWN0ID0gbmV3IERPTVJlY3QoXHJcbiAgICAgIHBhZ2VSZWN0UmF3LmxlZnQgLyBkcHIsXHJcbiAgICAgIHBhZ2VSZWN0UmF3LnRvcCAvIGRwcixcclxuICAgICAgcGFnZVJlY3RSYXcud2lkdGggLyBkcHIsXHJcbiAgICAgIHBhZ2VSZWN0UmF3LmhlaWdodCAvIGRwclxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCByZWN0czogRE9NUmVjdFtdID0gc3BhbnMubWFwKHMgPT4ge1xyXG4gICAgICBjb25zdCByID0gcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgcmV0dXJuIG5ldyBET01SZWN0KHIubGVmdCAvIGRwciwgci50b3AgLyBkcHIsIHIud2lkdGggLyBkcHIsIHIuaGVpZ2h0IC8gZHByKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmRldGVjdEdhcHNGcm9tUmVjdHMocmVjdHMsIHBhZ2VSZWN0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZWZlcnJlZCBBUEk6IEFjY2VwdHMgbm9ybWFsaXplZCBzcGFuIHJlY3RzIGFuZCBwYWdlIHJlY3QuXHJcbiAgICovXHJcbiAgcHVibGljIGRldGVjdEdhcHNGcm9tUmVjdHMoc3BhblJlY3RzOiBET01SZWN0W10sIHBhZ2VSZWN0OiBET01SZWN0KTogR2FwQW5hbHlzaXMge1xyXG4gICAgaWYgKCFzcGFuUmVjdHMgfHwgc3BhblJlY3RzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHZlcnRpY2FsQm91bmRhcmllczogW10sXHJcbiAgICAgICAgY29sdW1uczogW10sXHJcbiAgICAgICAgbGF5b3V0U2VnbWVudHM6IFtdLFxyXG4gICAgICAgIHZlcnRpY2FsU3RyaXBzOiBbXSxcclxuICAgICAgICBob3Jpem9udGFsQmFuZHM6IFtdXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMSkgRXN0aW1hdGUgYXZlcmFnZSBsaW5lIGhlaWdodFxyXG4gICAgY29uc3QgYXZnTGluZUhlaWdodCA9IHRoaXMuZXN0aW1hdGVBdmVyYWdlTGluZUhlaWdodChzcGFuUmVjdHMpO1xyXG5cclxuICAgIC8vIDIpIFNlZ21lbnQgdGhlIHBhZ2UgYnkgdmVydGljYWwgbGF5b3V0IChzaW1wbGUgc2luZ2xlIHNlZ21lbnQgYnkgZGVmYXVsdClcclxuICAgIGNvbnN0IGxheW91dFNlZ21lbnRzID0gdGhpcy5zZWdtZW50VmVydGljYWxMYXlvdXRzKHNwYW5SZWN0cywgcGFnZVJlY3QsIGF2Z0xpbmVIZWlnaHQpO1xyXG5cclxuICAgIC8vIDMpIEJ1aWxkIHZlcnRpY2FsIHN0cmlwcyBhbmQgaG9yaXpvbnRhbCBiYW5kcyB1c2luZyB5LWJhbmRlZCBvY2N1cGFuY3lcclxuICAgIGNvbnN0IHsgdmVydGljYWxTdHJpcHMsIGhvcml6b250YWxCYW5kcyB9ID0gdGhpcy5kZXRlY3RTdHJpcHNBbmRCYW5kcyhcclxuICAgICAgc3BhblJlY3RzLFxyXG4gICAgICBwYWdlUmVjdCxcclxuICAgICAgYXZnTGluZUhlaWdodFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyA0KSBDb252ZXJ0IHN0cmlwcyB0byBjbGFzc2ljIHZlcnRpY2FsQm91bmRhcmllcyAoY2VudGVyIHgpIGZvciBiYWNrLWNvbXBhdFxyXG4gICAgY29uc3QgdmVydGljYWxCb3VuZGFyaWVzOiBHYXBCb3VuZGFyeVtdID0gdmVydGljYWxTdHJpcHMubWFwKHMgPT4gKHtcclxuICAgICAgeDogKHMubGVmdCArIHMucmlnaHQpIC8gMixcclxuICAgICAgY29uZmlkZW5jZTogcy5jb25maWRlbmNlLFxyXG4gICAgICB3aWR0aDogTWF0aC5tYXgoMSwgcy5yaWdodCAtIHMubGVmdCksXHJcbiAgICAgIGhlaWdodDogcGFnZVJlY3QuaGVpZ2h0LFxyXG4gICAgICBzZWdtZW50SW5kZXg6IDBcclxuICAgIH0pKVxyXG4gICAgICAuZmlsdGVyKGIgPT4gYi5jb25maWRlbmNlID49IHRoaXMuTUlOX1NUUklQX0NPTkZJREVOQ0UpXHJcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnggLSBiLngpO1xyXG5cclxuICAgIC8vIDUpIENyZWF0ZSBjb2x1bW5zIGJhc2VkIG9uIGJvdW5kYXJpZXNcclxuICAgIGNvbnN0IGNvbHVtbnMgPSB0aGlzLmNyZWF0ZUNvbHVtbnNGcm9tQm91bmRhcmllcyh2ZXJ0aWNhbEJvdW5kYXJpZXMsIHBhZ2VSZWN0KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB2ZXJ0aWNhbEJvdW5kYXJpZXMsXHJcbiAgICAgIGNvbHVtbnMsXHJcbiAgICAgIGxheW91dFNlZ21lbnRzLFxyXG4gICAgICB2ZXJ0aWNhbFN0cmlwcyxcclxuICAgICAgaG9yaXpvbnRhbEJhbmRzXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyBDb3JlIGNvbXB1dGF0aW9uc1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIHByaXZhdGUgZXN0aW1hdGVBdmVyYWdlTGluZUhlaWdodChzcGFuUmVjdHM6IERPTVJlY3RbXSk6IG51bWJlciB7XHJcbiAgICBpZiAoIXNwYW5SZWN0cyB8fCBzcGFuUmVjdHMubGVuZ3RoID09PSAwKSByZXR1cm4gMTU7XHJcbiAgICBjb25zdCBoZWlnaHRzID0gc3BhblJlY3RzLm1hcChyID0+IHIuaGVpZ2h0KS5maWx0ZXIoaCA9PiBoID4gMyk7XHJcbiAgICBpZiAoIWhlaWdodHMubGVuZ3RoKSByZXR1cm4gMTU7XHJcbiAgICBoZWlnaHRzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcclxuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoaGVpZ2h0cy5sZW5ndGggLyAyKTtcclxuICAgIHJldHVybiBoZWlnaHRzLmxlbmd0aCAlIDIgPyBoZWlnaHRzW21pZF0gOiAoaGVpZ2h0c1ttaWQgLSAxXSArIGhlaWdodHNbbWlkXSkgLyAyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2ltcGxlIHNpbmdsZS1zZWdtZW50IGltcGxlbWVudGF0aW9uLlxyXG4gICAqIEtlZXAgQVBJIHNvIHlvdSBjYW4gbGF0ZXIgc3dhcCB3aXRoIGEgbW9yZSBhZHZhbmNlZCBzZWdtZW50ZXIgaWYgbmVlZGVkLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgc2VnbWVudFZlcnRpY2FsTGF5b3V0cyhcclxuICAgIHNwYW5SZWN0czogRE9NUmVjdFtdLFxyXG4gICAgcGFnZVJlY3Q6IERPTVJlY3QsXHJcbiAgICBhdmdMaW5lSGVpZ2h0OiBudW1iZXJcclxuICApOiBBcnJheTx7IHRvcDogbnVtYmVyOyBib3R0b206IG51bWJlcjsgbGVmdDogbnVtYmVyOyByaWdodDogbnVtYmVyIH0+IHtcclxuICAgIHJldHVybiBbe1xyXG4gICAgICB0b3A6IHBhZ2VSZWN0LnRvcCxcclxuICAgICAgYm90dG9tOiBwYWdlUmVjdC5ib3R0b20sXHJcbiAgICAgIGxlZnQ6IHBhZ2VSZWN0LmxlZnQsXHJcbiAgICAgIHJpZ2h0OiBwYWdlUmVjdC5yaWdodFxyXG4gICAgfV07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlY3QgdmVydGljYWwgc3RyaXBzIChnYXBzKSB2aWEgeS1iYW5kZWQgb2NjdXBhbmN5IGFuZCBvcHRpb25hbCBob3Jpem9udGFsIGJhbmRzLlxyXG4gICAqIFN0ZXBzOlxyXG4gICAqICAtIFN3ZWVwIHRoZSBwYWdlIGluIGhvcml6b250YWwgYmFuZHMgKHktYXhpcyksIGNvbGxlY3Qgb2NjdXBpZWQgeC1pbnRlcnZhbHNcclxuICAgKiAgLSBJbnZlcnQgdG8gZ2FwcyB3aXRoaW4gZWFjaCBiYW5kXHJcbiAgICogIC0gQ2x1c3RlciBnYXBzIGFjcm9zcyBhZGphY2VudCBiYW5kcyBieSBjZW50ZXIgeFxyXG4gICAqICAtIENvbXB1dGUgc3RyaXAgY29uZmlkZW5jZSBmcm9tIGNvdmVyYWdlIGFuZCBzdGFiaWxpdHlcclxuICAgKi9cclxuICBwcml2YXRlIGRldGVjdFN0cmlwc0FuZEJhbmRzKFxyXG4gICAgc3BhblJlY3RzOiBET01SZWN0W10sXHJcbiAgICBwYWdlUmVjdDogRE9NUmVjdCxcclxuICAgIGF2Z0xpbmU6IG51bWJlclxyXG4gICk6IHsgdmVydGljYWxTdHJpcHM6IFZlcnRpY2FsU3RyaXBbXTsgaG9yaXpvbnRhbEJhbmRzOiBIb3Jpem9udGFsQmFuZFtdIH0ge1xyXG4gICAgY29uc3QgYmFuZFN0ZXAgPSBNYXRoLm1heCg2LCBhdmdMaW5lICogdGhpcy5CQU5EX1NURVBfRkFDVE9SKTtcclxuICAgIGNvbnN0IGJhbmRzOiBBcnJheTx7IHkxOiBudW1iZXI7IHkyOiBudW1iZXI7IGdhcHM6IEFycmF5PHsgbGVmdDogbnVtYmVyOyByaWdodDogbnVtYmVyIH0+IH0+ID0gW107XHJcblxyXG4gICAgLy8gMSkgQnVpbGQgeS1iYW5kcyBhbmQgaW52ZXJ0ZWQgb2NjdXBhbmN5IGFzIGdhcCBpbnRlcnZhbHNcclxuICAgIGZvciAobGV0IHkgPSBwYWdlUmVjdC50b3A7IHkgPCBwYWdlUmVjdC5ib3R0b207IHkgKz0gYmFuZFN0ZXApIHtcclxuICAgICAgY29uc3QgeTEgPSB5O1xyXG4gICAgICBjb25zdCB5MiA9IE1hdGgubWluKHBhZ2VSZWN0LmJvdHRvbSwgeSArIGJhbmRTdGVwKTtcclxuXHJcbiAgICAgIC8vIENvbGxlY3Qgc3BhbnMgaW50ZXJzZWN0aW5nIHRoaXMgYmFuZFxyXG4gICAgICBjb25zdCBhY3RpdmUgPSBzcGFuUmVjdHMuZmlsdGVyKHIgPT4gci5ib3R0b20gPiB5MSAmJiByLnRvcCA8IHkyKTtcclxuICAgICAgLy8gSWYgbm9uZSwgZW50aXJlIHdpZHRoIGlzIGEgZ2FwXHJcbiAgICAgIGlmIChhY3RpdmUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgYmFuZHMucHVzaCh7IHkxLCB5MiwgZ2FwczogW3sgbGVmdDogcGFnZVJlY3QubGVmdCwgcmlnaHQ6IHBhZ2VSZWN0LnJpZ2h0IH1dIH0pO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBNZXJnZSBvY2N1cGllZCBpbnRlcnZhbHMgW2xlZnQscmlnaHRdIGFjcm9zcyBhY3RpdmUgcmVjdHNcclxuICAgICAgY29uc3Qgb2NjID0gYWN0aXZlLm1hcChyID0+ICh7IGxlZnQ6IHIubGVmdCwgcmlnaHQ6IHIucmlnaHQgfSkpXHJcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEubGVmdCAtIGIubGVmdCk7XHJcblxyXG4gICAgICBjb25zdCBtZXJnZWRPY2M6IEFycmF5PHsgbGVmdDogbnVtYmVyOyByaWdodDogbnVtYmVyIH0+ID0gW107XHJcbiAgICAgIGZvciAoY29uc3QgbyBvZiBvY2MpIHtcclxuICAgICAgICBpZiAoIW1lcmdlZE9jYy5sZW5ndGggfHwgby5sZWZ0ID4gbWVyZ2VkT2NjW21lcmdlZE9jYy5sZW5ndGggLSAxXS5yaWdodCkge1xyXG4gICAgICAgICAgbWVyZ2VkT2NjLnB1c2goeyBsZWZ0OiBvLmxlZnQsIHJpZ2h0OiBvLnJpZ2h0IH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBtZXJnZWRPY2NbbWVyZ2VkT2NjLmxlbmd0aCAtIDFdLnJpZ2h0ID0gTWF0aC5tYXgobWVyZ2VkT2NjW21lcmdlZE9jYy5sZW5ndGggLSAxXS5yaWdodCwgby5yaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbnZlcnQgdG8gZ2FwcyB3aXRoaW4gcGFnZVJlY3RcclxuICAgICAgY29uc3QgZ2FwczogQXJyYXk8eyBsZWZ0OiBudW1iZXI7IHJpZ2h0OiBudW1iZXIgfT4gPSBbXTtcclxuICAgICAgbGV0IGN1cnNvciA9IHBhZ2VSZWN0LmxlZnQ7XHJcbiAgICAgIGZvciAoY29uc3QgbSBvZiBtZXJnZWRPY2MpIHtcclxuICAgICAgICBpZiAobS5sZWZ0IC0gY3Vyc29yID49IHRoaXMuTUlOX0dBUF9XSURUSF9QWCkge1xyXG4gICAgICAgICAgZ2Fwcy5wdXNoKHsgbGVmdDogY3Vyc29yLCByaWdodDogbS5sZWZ0IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJzb3IgPSBNYXRoLm1heChjdXJzb3IsIG0ucmlnaHQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwYWdlUmVjdC5yaWdodCAtIGN1cnNvciA+PSB0aGlzLk1JTl9HQVBfV0lEVEhfUFgpIHtcclxuICAgICAgICBnYXBzLnB1c2goeyBsZWZ0OiBjdXJzb3IsIHJpZ2h0OiBwYWdlUmVjdC5yaWdodCB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYmFuZHMucHVzaCh7IHkxLCB5MiwgZ2FwcyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAyKSBDbHVzdGVyIGdhcHMgYWNyb3NzIGJhbmRzIGJ5IGNlbnRlciB4IHByb3hpbWl0eVxyXG4gICAgY29uc3QgeFRvbCA9IE1hdGgubWF4KDQsIGF2Z0xpbmUgKiB0aGlzLkNFTlRFUl9YX1RPTF9GQUNUT1IpO1xyXG4gICAgdHlwZSBDbHVzdGVyID0ge1xyXG4gICAgICBjZW50ZXJzOiBudW1iZXJbXTtcclxuICAgICAgd2lkdGhzOiBudW1iZXJbXTtcclxuICAgICAgbGVmdHM6IG51bWJlcltdO1xyXG4gICAgICByaWdodHM6IG51bWJlcltdO1xyXG4gICAgICB5MXM6IG51bWJlcltdO1xyXG4gICAgICB5MnM6IG51bWJlcltdO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGNsdXN0ZXJzOiBDbHVzdGVyW10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGJhbmQgb2YgYmFuZHMpIHtcclxuICAgICAgY29uc3QgeyB5MSwgeTIgfSA9IGJhbmQ7XHJcbiAgICAgIGZvciAoY29uc3QgZyBvZiBiYW5kLmdhcHMpIHtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IGcucmlnaHQgLSBnLmxlZnQ7XHJcbiAgICAgICAgaWYgKHdpZHRoIDwgdGhpcy5NSU5fR0FQX1dJRFRIX1BYKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgY29uc3QgY2VudGVyID0gKGcubGVmdCArIGcucmlnaHQpIC8gMjtcclxuICAgICAgICBsZXQgcGxhY2VkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIFRyeSB0byBhc3NpZ24gdG8gYW4gZXhpc3RpbmcgY2x1c3RlciBieSBwcm94aW1pdHkgdG8gbGFzdCBjZW50ZXJcclxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY2x1c3RlcnMpIHtcclxuICAgICAgICAgIGNvbnN0IGxhc3RDZW50ZXIgPSBjLmNlbnRlcnNbYy5jZW50ZXJzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgaWYgKE1hdGguYWJzKGNlbnRlciAtIGxhc3RDZW50ZXIpIDw9IHhUb2wpIHtcclxuICAgICAgICAgICAgYy5jZW50ZXJzLnB1c2goY2VudGVyKTtcclxuICAgICAgICAgICAgYy53aWR0aHMucHVzaCh3aWR0aCk7XHJcbiAgICAgICAgICAgIGMubGVmdHMucHVzaChnLmxlZnQpO1xyXG4gICAgICAgICAgICBjLnJpZ2h0cy5wdXNoKGcucmlnaHQpO1xyXG4gICAgICAgICAgICBjLnkxcy5wdXNoKHkxKTtcclxuICAgICAgICAgICAgYy55MnMucHVzaCh5Mik7XHJcbiAgICAgICAgICAgIHBsYWNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNsdXN0ZXIgaWYgbm8gbWF0Y2hcclxuICAgICAgICBpZiAoIXBsYWNlZCkge1xyXG4gICAgICAgICAgY2x1c3RlcnMucHVzaCh7XHJcbiAgICAgICAgICAgIGNlbnRlcnM6IFtjZW50ZXJdLFxyXG4gICAgICAgICAgICB3aWR0aHM6IFt3aWR0aF0sXHJcbiAgICAgICAgICAgIGxlZnRzOiBbZy5sZWZ0XSxcclxuICAgICAgICAgICAgcmlnaHRzOiBbZy5yaWdodF0sXHJcbiAgICAgICAgICAgIHkxczogW3kxXSxcclxuICAgICAgICAgICAgeTJzOiBbeTJdXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyAzKSBDb252ZXJ0IGNsdXN0ZXJzIGludG8gdmVydGljYWwgc3RyaXBzIHdpdGggY29uZmlkZW5jZVxyXG4gICAgY29uc3QgbWluU3RyaXBIZWlnaHQgPSBhdmdMaW5lICogdGhpcy5NSU5fU1RSSVBfSEVJR0hUX0ZBQ1RPUjtcclxuICAgIGNvbnN0IHRvdGFsQmFuZHMgPSBiYW5kcy5sZW5ndGg7XHJcbiAgICBjb25zdCBzdHJpcHM6IFZlcnRpY2FsU3RyaXBbXSA9IFtdO1xyXG5cclxuICAgIGZvciAoY29uc3QgYyBvZiBjbHVzdGVycykge1xyXG4gICAgICBpZiAoIWMuY2VudGVycy5sZW5ndGgpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgLy8gU3RyaXAgZ2VvbWV0cnkgdmlhIG1lZGlhbnMgKHJvYnVzdClcclxuICAgICAgY29uc3QgbGVmdCA9IG1lZGlhbihjLmxlZnRzKTtcclxuICAgICAgY29uc3QgcmlnaHQgPSBtZWRpYW4oYy5yaWdodHMpO1xyXG4gICAgICBjb25zdCB0b3AgPSBNYXRoLm1pbiguLi5jLnkxcyk7XHJcbiAgICAgIGNvbnN0IGJvdHRvbSA9IE1hdGgubWF4KC4uLmMueTJzKTtcclxuICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xyXG5cclxuICAgICAgaWYgKGhlaWdodCA8IG1pblN0cmlwSGVpZ2h0KSBjb250aW51ZTtcclxuXHJcbiAgICAgIC8vIENvdmVyYWdlOiBob3cgbWFueSBiYW5kcyBwYXJ0aWNpcGF0ZWRcclxuICAgICAgY29uc3QgY292ZXJhZ2UgPSBhcHByb3hVbmlxdWVCYW5kQ291bnQoYy55MXMpIC8gdG90YWxCYW5kcztcclxuXHJcbiAgICAgIC8vIFN0YWJpbGl0eTogd2lkdGggJiBjZW50ZXIgc3RkZXYgbm9ybWFsaXplZCBieSB0aGVpciBtZWRpYW5zXHJcbiAgICAgIGNvbnN0IHdpZHRoU3RkID0gc3RkZGV2KGMud2lkdGhzKTtcclxuICAgICAgY29uc3QgY2VudGVyU3RkID0gc3RkZGV2KGMuY2VudGVycyk7XHJcbiAgICAgIGNvbnN0IG5vcm1XaWR0aFN0ZCA9IHdpZHRoU3RkIC8gTWF0aC5tYXgoMSwgbWVkaWFuKGMud2lkdGhzKSk7XHJcbiAgICAgIGNvbnN0IG5vcm1DZW50ZXJTdGQgPSBjZW50ZXJTdGQgLyBNYXRoLm1heCgxLCBtZWRpYW4oYy5jZW50ZXJzKSk7XHJcblxyXG4gICAgICAvLyBDb25maWRlbmNlOiB3ZWlnaHRlZCBjb21ib1xyXG4gICAgICBsZXQgY29uZmlkZW5jZSA9XHJcbiAgICAgICAgdGhpcy5DT1ZFUkFHRV9XRUlHSFQgKiBjb3ZlcmFnZSArXHJcbiAgICAgICAgdGhpcy5XSURUSF9TVEFCSUxJVFlfV0VJR0hUICogKDEgLSBjbGFtcDAxKG5vcm1XaWR0aFN0ZCkpICtcclxuICAgICAgICB0aGlzLkNFTlRFUl9TVEFCSUxJVFlfV0VJR0hUICogKDEgLSBjbGFtcDAxKG5vcm1DZW50ZXJTdGQpKTtcclxuICAgICAgY29uZmlkZW5jZSA9IGNsYW1wMDEoY29uZmlkZW5jZSk7XHJcblxyXG4gICAgICBpZiAoY29uZmlkZW5jZSA+PSB0aGlzLk1JTl9TVFJJUF9DT05GSURFTkNFKSB7XHJcbiAgICAgICAgc3RyaXBzLnB1c2goeyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIGNvbmZpZGVuY2UgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyA0KSBPcHRpb25hbDogSG9yaXpvbnRhbCBiYW5kIGRldGVjdGlvbiAoa2VwdCBlbXB0eSBmb3Igbm93OyBjYW4gaW1wbGVtZW50IHNpbWlsYXIgYmFuZGVkLXggb2NjdXBhbmN5KVxyXG4gICAgY29uc3QgaG9yaXpvbnRhbEJhbmRzOiBIb3Jpem9udGFsQmFuZFtdID0gW107XHJcblxyXG4gICAgLy8gNSkgU29ydCBzdHJpcHMgbGVmdC10by1yaWdodCBhbmQgbWVyZ2Ugb3ZlcmxhcHBpbmcvYWRqYWNlbnQgc2ltaWxhciBzdHJpcHMgZm9yIGNsZWFubGluZXNzXHJcbiAgICBjb25zdCBtZXJnZWRTdHJpcHMgPSB0aGlzLm1lcmdlU2ltaWxhclN0cmlwcyhzdHJpcHMpO1xyXG5cclxuICAgIHJldHVybiB7IHZlcnRpY2FsU3RyaXBzOiBtZXJnZWRTdHJpcHMsIGhvcml6b250YWxCYW5kcyB9O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBtZXJnZVNpbWlsYXJTdHJpcHMoc3RyaXBzOiBWZXJ0aWNhbFN0cmlwW10pOiBWZXJ0aWNhbFN0cmlwW10ge1xyXG4gICAgaWYgKCFzdHJpcHMubGVuZ3RoKSByZXR1cm4gW107XHJcbiAgICBjb25zdCBzb3J0ZWQgPSBbLi4uc3RyaXBzXS5zb3J0KChhLCBiKSA9PiAoYS5sZWZ0ICsgYS5yaWdodCkgLyAyIC0gKGIubGVmdCArIGIucmlnaHQpIC8gMik7XHJcbiAgICBjb25zdCBvdXQ6IFZlcnRpY2FsU3RyaXBbXSA9IFtdO1xyXG4gICAgY29uc3QgeE1lcmdlVG9sID0gMzsgLy8gc21hbGwgcGl4ZWwgdG9sZXJhbmNlIGZvciBtZXJnaW5nIG5lYXJseSBpZGVudGljYWwgc3RyaXBzXHJcblxyXG4gICAgbGV0IGN1ciA9IHsgLi4uc29ydGVkWzBdIH07XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNvcnRlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBzID0gc29ydGVkW2ldO1xyXG4gICAgICBjb25zdCBjZW50ZXJzQ2xvc2UgPSBNYXRoLmFicygoKGN1ci5sZWZ0ICsgY3VyLnJpZ2h0KSAvIDIpIC0gKChzLmxlZnQgKyBzLnJpZ2h0KSAvIDIpKSA8PSB4TWVyZ2VUb2w7XHJcbiAgICAgIGNvbnN0IHZlcnRpY2FsT3ZlcmxhcCA9IE1hdGgubWluKGN1ci5ib3R0b20sIHMuYm90dG9tKSAtIE1hdGgubWF4KGN1ci50b3AsIHMudG9wKSA+IDA7XHJcblxyXG4gICAgICBpZiAoY2VudGVyc0Nsb3NlICYmIHZlcnRpY2FsT3ZlcmxhcCkge1xyXG4gICAgICAgIC8vIE1lcmdlIHJhbmdlcyBhbmQgYXZlcmFnZSBjb25maWRlbmNlXHJcbiAgICAgICAgY3VyLmxlZnQgPSBNYXRoLm1pbihjdXIubGVmdCwgcy5sZWZ0KTtcclxuICAgICAgICBjdXIucmlnaHQgPSBNYXRoLm1heChjdXIucmlnaHQsIHMucmlnaHQpO1xyXG4gICAgICAgIGN1ci50b3AgPSBNYXRoLm1pbihjdXIudG9wLCBzLnRvcCk7XHJcbiAgICAgICAgY3VyLmJvdHRvbSA9IE1hdGgubWF4KGN1ci5ib3R0b20sIHMuYm90dG9tKTtcclxuICAgICAgICBjdXIuY29uZmlkZW5jZSA9IE1hdGgubWF4KGN1ci5jb25maWRlbmNlLCBzLmNvbmZpZGVuY2UpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG91dC5wdXNoKGN1cik7XHJcbiAgICAgICAgY3VyID0geyAuLi5zIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIG91dC5wdXNoKGN1cik7XHJcbiAgICByZXR1cm4gb3V0O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjcmVhdGVDb2x1bW5zRnJvbUJvdW5kYXJpZXMoYm91bmRhcmllczogR2FwQm91bmRhcnlbXSwgcGFnZVJlY3Q6IERPTVJlY3QpOiBTaW1wbGVSZWN0W10ge1xyXG4gICAgaWYgKCFib3VuZGFyaWVzPy5sZW5ndGgpIHJldHVybiBbe1xyXG4gICAgICBsZWZ0OiBwYWdlUmVjdC5sZWZ0LFxyXG4gICAgICB0b3A6IHBhZ2VSZWN0LnRvcCxcclxuICAgICAgcmlnaHQ6IHBhZ2VSZWN0LnJpZ2h0LFxyXG4gICAgICBib3R0b206IHBhZ2VSZWN0LmJvdHRvbSxcclxuICAgICAgd2lkdGg6IHBhZ2VSZWN0LndpZHRoLFxyXG4gICAgICBoZWlnaHQ6IHBhZ2VSZWN0LmhlaWdodFxyXG4gICAgfV07XHJcblxyXG4gICAgY29uc3Qgc29ydGVkID0gWy4uLmJvdW5kYXJpZXNdLnNvcnQoKGEsIGIpID0+IGEueCAtIGIueCk7XHJcbiAgICBjb25zdCBjb2xzOiBTaW1wbGVSZWN0W10gPSBbXTtcclxuXHJcbiAgICBsZXQgcHJldlggPSBwYWdlUmVjdC5sZWZ0O1xyXG4gICAgZm9yIChjb25zdCBiIG9mIHNvcnRlZCkge1xyXG4gICAgICBjb25zdCB4ID0gTWF0aC5tYXgocGFnZVJlY3QubGVmdCwgTWF0aC5taW4ocGFnZVJlY3QucmlnaHQsIGIueCkpO1xyXG4gICAgICBpZiAoeCA+IHByZXZYKSB7XHJcbiAgICAgICAgY29scy5wdXNoKHtcclxuICAgICAgICAgIGxlZnQ6IHByZXZYLFxyXG4gICAgICAgICAgdG9wOiBwYWdlUmVjdC50b3AsXHJcbiAgICAgICAgICByaWdodDogeCxcclxuICAgICAgICAgIGJvdHRvbTogcGFnZVJlY3QuYm90dG9tLFxyXG4gICAgICAgICAgd2lkdGg6IHggLSBwcmV2WCxcclxuICAgICAgICAgIGhlaWdodDogcGFnZVJlY3QuaGVpZ2h0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcHJldlggPSB4O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByZXZYIDwgcGFnZVJlY3QucmlnaHQpIHtcclxuICAgICAgY29scy5wdXNoKHtcclxuICAgICAgICBsZWZ0OiBwcmV2WCxcclxuICAgICAgICB0b3A6IHBhZ2VSZWN0LnRvcCxcclxuICAgICAgICByaWdodDogcGFnZVJlY3QucmlnaHQsXHJcbiAgICAgICAgYm90dG9tOiBwYWdlUmVjdC5ib3R0b20sXHJcbiAgICAgICAgd2lkdGg6IHBhZ2VSZWN0LnJpZ2h0IC0gcHJldlgsXHJcbiAgICAgICAgaGVpZ2h0OiBwYWdlUmVjdC5oZWlnaHRcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbHMuc2xpY2UoMCwgdGhpcy5NQVhfQ09MVU1OUyk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBTbWFsbCBoZWxwZXJzXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5mdW5jdGlvbiBjbGFtcDAxKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHgpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWVkaWFuKGE6IG51bWJlcltdKTogbnVtYmVyIHtcclxuICBpZiAoIWEubGVuZ3RoKSByZXR1cm4gMDtcclxuICBjb25zdCBzID0gWy4uLmFdLnNvcnQoKHgsIHkpID0+IHggLSB5KTtcclxuICBjb25zdCBtID0gTWF0aC5mbG9vcihzLmxlbmd0aCAvIDIpO1xyXG4gIHJldHVybiBzLmxlbmd0aCAlIDIgPyBzW21dIDogKHNbbSAtIDFdICsgc1ttXSkgLyAyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdGRkZXYoYTogbnVtYmVyW10pOiBudW1iZXIge1xyXG4gIGlmICghYS5sZW5ndGgpIHJldHVybiAwO1xyXG4gIGlmIChhLmxlbmd0aCA9PT0gMSkgcmV0dXJuIDA7XHJcbiAgY29uc3QgbWVhbiA9IGEucmVkdWNlKChzLCB2KSA9PiBzICsgdiwgMCkgLyBhLmxlbmd0aDtcclxuICBjb25zdCB2YXJpYW5jZSA9IGEucmVkdWNlKChzLCB2KSA9PiBzICsgKHYgLSBtZWFuKSAqICh2IC0gbWVhbiksIDApIC8gKGEubGVuZ3RoIC0gMSk7XHJcbiAgcmV0dXJuIE1hdGguc3FydCh2YXJpYW5jZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcHJveFVuaXF1ZUJhbmRDb3VudCh5MXM6IG51bWJlcltdKTogbnVtYmVyIHtcclxuICAvLyBDb3VudCBhcHByb3hpbWF0ZSB1bmlxdWUgYmFuZHMgYnkgcm91bmRpbmcgZWFjaCB5MSB0byBpbnRlZ2VyIGFuZCB1c2luZyBhIHNldFxyXG4gIGNvbnN0IHMgPSBuZXcgU2V0PG51bWJlcj4oKTtcclxuICBmb3IgKGNvbnN0IHkgb2YgeTFzKSBzLmFkZChNYXRoLnJvdW5kKHkpKTtcclxuICByZXR1cm4gcy5zaXplO1xyXG59IiwgIi8vIGdyaWQtZGV0ZWN0b3IudHNcclxuXHJcbmltcG9ydCB7IEJvdW5kaW5nUmVjdCB9IGZyb20gJy4vbGF5b3V0LWRldGVjdG9yJzsgLy8gQXNzdW1lcyBCb3VuZGluZ1JlY3QgaXMgZXhwb3J0ZWRcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgZGV0ZWN0ZWQgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBsaW5lIGluIGEgZ3JpZC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgR3JpZExpbmUge1xyXG4gIHBvc2l0aW9uOiBudW1iZXI7IC8vIFRoZSB5LWNvb3JkaW5hdGUgZm9yIGhvcml6b250YWwgbGluZXMsIG9yIHgtY29vcmRpbmF0ZSBmb3IgdmVydGljYWwgbGluZXMuXHJcbiAgc3RhcnQ6IG51bWJlcjsgICAgLy8gVGhlIHN0YXJ0aW5nIGNvb3JkaW5hdGUgb2YgdGhlIGxpbmUgKGUuZy4sIHBhZ2VSZWN0LmxlZnQpLlxyXG4gIGVuZDogbnVtYmVyOyAgICAgIC8vIFRoZSBlbmRpbmcgY29vcmRpbmF0ZSBvZiB0aGUgbGluZSAoZS5nLiwgcGFnZVJlY3QucmlnaHQpLlxyXG59XHJcblxyXG4vKipcclxuICogQ29udGFpbnMgdGhlIHJlc3VsdHMgb2YgdGhlIGdyaWQgZGV0ZWN0aW9uIGFuYWx5c2lzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBHcmlkQW5hbHlzaXMge1xyXG4gIGhvcml6b250YWxMaW5lczogR3JpZExpbmVbXTtcclxuICB2ZXJ0aWNhbExpbmVzOiBHcmlkTGluZVtdO1xyXG59XHJcblxyXG4vKipcclxuICogQ29uZmlndXJhdGlvbiBzZXR0aW5ncyBmb3IgdGhlIEdyaWREZXRlY3Rvci5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgR3JpZFNldHRpbmdzIHtcclxuICAvLyBUaGUgbWluaW11bSBoZWlnaHQgb2YgYSBob3Jpem9udGFsIGdhcCwgYXMgYSBtdWx0aXBsaWVyIG9mIHRoZSBkb2N1bWVudCdzIGxpbmUgaGVpZ2h0LlxyXG4gIG1pbkhvcml6b250YWxHYXBMaW5lSGVpZ2h0TXVsdGlwbGllcjogbnVtYmVyO1xyXG4gIC8vIFRoZSB0aHJlc2hvbGQgKG51bWJlciBvZiBwaXhlbHMpIHRvIGNvbnNpZGVyIGEgcHJvamVjdGlvbiBwcm9maWxlIHZhbHVlIGFzIFwiZW1wdHlcIi5cclxuICBwcm9qZWN0aW9uUHJvZmlsZVRocmVzaG9sZDogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZGVmYXVsdEdyaWRTZXR0aW5nczogR3JpZFNldHRpbmdzID0ge1xyXG4gIG1pbkhvcml6b250YWxHYXBMaW5lSGVpZ2h0TXVsdGlwbGllcjogMS41LFxyXG4gIHByb2plY3Rpb25Qcm9maWxlVGhyZXNob2xkOiAxLCAvLyBBIHZlcnkgbG93IHRocmVzaG9sZDsgYW55IHBpeGVsIHByZXNlbmNlIGNvdW50cy5cclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBHcmlkRGV0ZWN0b3Ige1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgc2V0dGluZ3M6IEdyaWRTZXR0aW5ncztcclxuXHJcbiAgY29uc3RydWN0b3Iob3B0aW9uczogUGFydGlhbDxHcmlkU2V0dGluZ3M+ID0ge30pIHtcclxuICAgIHRoaXMuc2V0dGluZ3MgPSB7IC4uLmRlZmF1bHRHcmlkU2V0dGluZ3MsIC4uLm9wdGlvbnMgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuYWx5emVzIGEgc2V0IG9mIHJlY3RhbmdsZXMgdG8gZGV0ZWN0IGdyaWQtbGlrZSBzdHJ1Y3R1cmVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHJlY3RzIC0gVGhlIGJvdW5kaW5nIHJlY3RhbmdsZXMgb2YgYWxsIHRleHQgc3BhbnMgb24gdGhlIHBhZ2UuXHJcbiAgICogQHBhcmFtIHBhZ2VSZWN0IC0gVGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBmb3IgdGhlIGVudGlyZSBwYWdlLlxyXG4gICAqIEBwYXJhbSBlc3RpbWF0ZWRMaW5lSGVpZ2h0IC0gVGhlIGVzdGltYXRlZCBsaW5lIGhlaWdodCwgdXNlZCBmb3IgZHluYW1pYyB0aHJlc2hvbGRpbmcuXHJcbiAgICogQHJldHVybnMgQSBHcmlkQW5hbHlzaXMgb2JqZWN0LCBvciBudWxsIGlmIG5vIGdyaWQgaXMgZGV0ZWN0ZWQuXHJcbiAgICovXHJcbiAgcHVibGljIGRldGVjdEdyaWQoXHJcbiAgICByZWN0czogQm91bmRpbmdSZWN0W10sXHJcbiAgICBwYWdlUmVjdDogRE9NUmVjdCxcclxuICAgIGVzdGltYXRlZExpbmVIZWlnaHQ6IG51bWJlclxyXG4gICk6IEdyaWRBbmFseXNpcyB8IG51bGwge1xyXG4gICAgaWYgKCFyZWN0cyB8fCByZWN0cy5sZW5ndGggPCAyKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDEuIENyZWF0ZSBwcm9qZWN0aW9uIHByb2ZpbGVzIHRvIGZpbmQgd2hpdGVzcGFjZS5cclxuICAgIGNvbnN0IGhvcml6b250YWxQcm9maWxlID0gdGhpcy5jcmVhdGVQcm9qZWN0aW9uUHJvZmlsZShyZWN0cywgcGFnZVJlY3QsICdob3Jpem9udGFsJyk7XHJcbiAgICBjb25zdCB2ZXJ0aWNhbFByb2ZpbGUgPSB0aGlzLmNyZWF0ZVByb2plY3Rpb25Qcm9maWxlKHJlY3RzLCBwYWdlUmVjdCwgJ3ZlcnRpY2FsJyk7XHJcblxyXG4gICAgLy8gMi4gSWRlbnRpZnkgc2lnbmlmaWNhbnQgZ2FwcyBpbiB0aGUgcHJvZmlsZXMuXHJcbiAgICBjb25zdCBtaW5HYXBIZWlnaHQgPSBlc3RpbWF0ZWRMaW5lSGVpZ2h0ICogdGhpcy5zZXR0aW5ncy5taW5Ib3Jpem9udGFsR2FwTGluZUhlaWdodE11bHRpcGxpZXI7XHJcbiAgICBjb25zdCBob3Jpem9udGFsR2FwcyA9IHRoaXMuZmluZEdhcHNJblByb2ZpbGUoaG9yaXpvbnRhbFByb2ZpbGUsIG1pbkdhcEhlaWdodCk7XHJcbiAgICBcclxuICAgIC8vIEZvciB2ZXJ0aWNhbCBnYXBzLCB3ZSBjYW4gdXNlIGEgc2ltcGxlciB0aHJlc2hvbGQsIGxpa2UgdGhlIGxpbmUgaGVpZ2h0IGl0c2VsZi5cclxuICAgIGNvbnN0IHZlcnRpY2FsR2FwcyA9IHRoaXMuZmluZEdhcHNJblByb2ZpbGUodmVydGljYWxQcm9maWxlLCBlc3RpbWF0ZWRMaW5lSGVpZ2h0KTtcclxuXHJcbiAgICAvLyAzLiBDb252ZXJ0IHRoZXNlIGdhcHMgaW50byBncmlkIGxpbmUgcmVwcmVzZW50YXRpb25zLlxyXG4gICAgY29uc3QgaG9yaXpvbnRhbExpbmVzOiBHcmlkTGluZVtdID0gaG9yaXpvbnRhbEdhcHMubWFwKGdhcCA9PiAoe1xyXG4gICAgICBwb3NpdGlvbjogcGFnZVJlY3QudG9wICsgZ2FwLnN0YXJ0ICsgZ2FwLmxlbmd0aCAvIDIsIC8vIE1pZHBvaW50IG9mIHRoZSBnYXBcclxuICAgICAgc3RhcnQ6IHBhZ2VSZWN0LmxlZnQsXHJcbiAgICAgIGVuZDogcGFnZVJlY3QucmlnaHQsXHJcbiAgICB9KSk7XHJcblxyXG4gICAgY29uc3QgdmVydGljYWxMaW5lczogR3JpZExpbmVbXSA9IHZlcnRpY2FsR2Fwcy5tYXAoZ2FwID0+ICh7XHJcbiAgICAgIHBvc2l0aW9uOiBwYWdlUmVjdC5sZWZ0ICsgZ2FwLnN0YXJ0ICsgZ2FwLmxlbmd0aCAvIDIsIC8vIE1pZHBvaW50XHJcbiAgICAgIHN0YXJ0OiBwYWdlUmVjdC50b3AsXHJcbiAgICAgIGVuZDogcGFnZVJlY3QuYm90dG9tLFxyXG4gICAgfSkpO1xyXG5cclxuICAgIC8vIEEgc2ltcGxlIGhldXJpc3RpYzogaWYgdGhlcmUgYXJlIG5vIGhvcml6b250YWwgbGluZXMsIGl0J3Mgbm90IGEgZ3JpZCB3ZSdyZSBsb29raW5nIGZvci5cclxuICAgIGlmIChob3Jpem9udGFsTGluZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IGhvcml6b250YWxMaW5lcywgdmVydGljYWxMaW5lcyB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIHByb2plY3Rpb24gcHJvZmlsZSAoYSBoaXN0b2dyYW0gb2YgcGl4ZWwgb2NjdXBhbmN5KS5cclxuICAgKiBAcGFyYW0gcmVjdHMgLSBUaGUgcmVjdGFuZ2xlcyB0byBwcm9qZWN0LlxyXG4gICAqIEBwYXJhbSBwYWdlUmVjdCAtIFRoZSBib3VuZHMgb2YgdGhlIHBhZ2UuXHJcbiAgICogQHBhcmFtIG9yaWVudGF0aW9uIC0gJ2hvcml6b250YWwnIHRvIHNjYW4gcm93cywgJ3ZlcnRpY2FsJyB0byBzY2FuIGNvbHVtbnMuXHJcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgdGhlIHByb2ZpbGUuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjcmVhdGVQcm9qZWN0aW9uUHJvZmlsZShcclxuICAgIHJlY3RzOiBCb3VuZGluZ1JlY3RbXSxcclxuICAgIHBhZ2VSZWN0OiBET01SZWN0LFxyXG4gICAgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCdcclxuICApOiBudW1iZXJbXSB7XHJcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnO1xyXG4gICAgY29uc3QgcHJvZmlsZVNpemUgPSBNYXRoLmNlaWwoaXNIb3Jpem9udGFsID8gcGFnZVJlY3QuaGVpZ2h0IDogcGFnZVJlY3Qud2lkdGgpO1xyXG4gICAgY29uc3QgcHJvZmlsZSA9IG5ldyBBcnJheShwcm9maWxlU2l6ZSkuZmlsbCgwKTtcclxuICAgIGNvbnN0IG9mZnNldCA9IGlzSG9yaXpvbnRhbCA/IHBhZ2VSZWN0LnRvcCA6IHBhZ2VSZWN0LmxlZnQ7XHJcblxyXG4gICAgZm9yIChjb25zdCByZWN0IG9mIHJlY3RzKSB7XHJcbiAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5mbG9vcigoaXNIb3Jpem9udGFsID8gcmVjdC50b3AgOiByZWN0LmxlZnQpIC0gb2Zmc2V0KTtcclxuICAgICAgY29uc3QgZW5kID0gTWF0aC5jZWlsKChpc0hvcml6b250YWwgPyByZWN0LmJvdHRvbSA6IHJlY3QucmlnaHQpIC0gb2Zmc2V0KTtcclxuICAgICAgY29uc3QgdmFsdWUgPSBpc0hvcml6b250YWwgPyByZWN0LndpZHRoIDogcmVjdC5oZWlnaHQ7XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xyXG4gICAgICAgIGlmIChpID49IDAgJiYgaSA8IHByb2ZpbGVTaXplKSB7XHJcbiAgICAgICAgICBwcm9maWxlW2ldICs9IHZhbHVlOyAvLyBXZSBjYW4gd2VpZ2h0IGJ5IHNpemUgZm9yIG1vcmUgcm9idXN0bmVzc1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb2ZpbGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaW5kcyBjb250aW51b3VzIHNlcXVlbmNlcyBvZiBuZWFyLXplcm8gdmFsdWVzIGluIGEgcHJvZmlsZS5cclxuICAgKiBAcGFyYW0gcHJvZmlsZSAtIFRoZSBwcm9qZWN0aW9uIHByb2ZpbGUgYXJyYXkuXHJcbiAgICogQHBhcmFtIG1pbkdhcFNpemUgLSBUaGUgbWluaW11bSBsZW5ndGggZm9yIGEgZ2FwIHRvIGJlIGNvbnNpZGVyZWQgc2lnbmlmaWNhbnQuXHJcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgZGV0ZWN0ZWQgZ2FwcyB3aXRoIHRoZWlyIHN0YXJ0IGFuZCBsZW5ndGguXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBmaW5kR2Fwc0luUHJvZmlsZShwcm9maWxlOiBudW1iZXJbXSwgbWluR2FwU2l6ZTogbnVtYmVyKTogeyBzdGFydDogbnVtYmVyOyBsZW5ndGg6IG51bWJlciB9W10ge1xyXG4gICAgY29uc3QgZ2FwczogeyBzdGFydDogbnVtYmVyOyBsZW5ndGg6IG51bWJlciB9W10gPSBbXTtcclxuICAgIGxldCBnYXBTdGFydCA9IC0xO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvZmlsZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAocHJvZmlsZVtpXSA8IHRoaXMuc2V0dGluZ3MucHJvamVjdGlvblByb2ZpbGVUaHJlc2hvbGQpIHtcclxuICAgICAgICBpZiAoZ2FwU3RhcnQgPT09IC0xKSB7XHJcbiAgICAgICAgICBnYXBTdGFydCA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChnYXBTdGFydCAhPT0gLTEpIHtcclxuICAgICAgICAgIGNvbnN0IGdhcExlbmd0aCA9IGkgLSBnYXBTdGFydDtcclxuICAgICAgICAgIGlmIChnYXBMZW5ndGggPj0gbWluR2FwU2l6ZSkge1xyXG4gICAgICAgICAgICBnYXBzLnB1c2goeyBzdGFydDogZ2FwU3RhcnQsIGxlbmd0aDogZ2FwTGVuZ3RoIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZ2FwU3RhcnQgPSAtMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBIYW5kbGUgYSBnYXAgdGhhdCBtaWdodCBleHRlbmQgdG8gdGhlIGVuZCBvZiB0aGUgcHJvZmlsZVxyXG4gICAgaWYgKGdhcFN0YXJ0ICE9PSAtMSkge1xyXG4gICAgICBjb25zdCBnYXBMZW5ndGggPSBwcm9maWxlLmxlbmd0aCAtIGdhcFN0YXJ0O1xyXG4gICAgICBpZiAoZ2FwTGVuZ3RoID49IG1pbkdhcFNpemUpIHtcclxuICAgICAgICBnYXBzLnB1c2goeyBzdGFydDogZ2FwU3RhcnQsIGxlbmd0aDogZ2FwTGVuZ3RoIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2FwcztcclxuICB9XHJcbn0iLCAiLy8gUGFyYWdyYXBoTWVyZ2VyLnRzXHJcbmltcG9ydCB0eXBlIHsgVmVydGljYWxTdHJpcCwgSG9yaXpvbnRhbEJhbmQgfSBmcm9tICcuL0dhcERldGVjdG9yJztcclxuaW1wb3J0IHR5cGUgeyBTcGFuSW5mbyB9IGZyb20gJy4vU25hcHNob3QnO1xyXG5pbXBvcnQgdHlwZSB7IExheW91dFNldHRpbmdzIH0gZnJvbSAnLi9sYXlvdXQtbW9kYWwnO1xyXG5cclxuaW50ZXJmYWNlIFJlY3RMaWtlIHtcclxuICBsZWZ0OiBudW1iZXI7XHJcbiAgdG9wOiBudW1iZXI7XHJcbiAgcmlnaHQ6IG51bWJlcjtcclxuICBib3R0b206IG51bWJlcjtcclxuICB3aWR0aDogbnVtYmVyO1xyXG4gIGhlaWdodDogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgUGFyYWdyYXBoTWVyZ2VyIHtcclxuICAvLyBVc2UgdGhlIHNldHRpbmdzIGZyb20gTGF5b3V0U2V0dGluZ3NcclxuICBwcml2YXRlIGxpbmVIZWlnaHRNdWx0aXBsaWVyOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBkZWJ1Z1ZhbGlkYXRpb246IGJvb2xlYW47XHJcbiAgXHJcbiAgLy8gTmV3IEZsYWdcclxuICBwcml2YXRlIGZvcmNlTGluZWFyTWVyZ2U6IGJvb2xlYW47XHJcblxyXG4gIHByaXZhdGUgbWluU3RyaXBDb25maWRlbmNlU3BsaXQ6IG51bWJlcjtcclxuICBwcml2YXRlIG1pblN0cmlwV2lkdGhQeDogbnVtYmVyO1xyXG4gIHByaXZhdGUgbWluU3RyaXBPdmVybGFwRnJhYzogbnVtYmVyO1xyXG4gIHByaXZhdGUgaW5pdGlhbE1lcmdlQmFzZWxpbmVUb2xOb25NYXRoOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBpbml0aWFsTWVyZ2VCYXNlbGluZVRvbE1hdGg6IG51bWJlcjtcclxuICBwcml2YXRlIGluaXRpYWxNZXJnZUtlcm5Ub2xOb25NYXRoOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBpbml0aWFsTWVyZ2VLZXJuVG9sTWF0aDogbnVtYmVyO1xyXG4gIHByaXZhdGUgaHlwaGVuQ29udGludWF0aW9uVG9sOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBpbml0aWFsTWVyZ2VBbGlnblRvbE5vbk1hdGg6IG51bWJlcjtcclxuICBwcml2YXRlIGluaXRpYWxNZXJnZUFsaWduVG9sTWF0aDogbnVtYmVyO1xyXG4gIHByaXZhdGUgaW5pdGlhbE1lcmdlVmVydGljYWxHYXBNdWx0aXBsaWVyOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBpbml0aWFsTWVyZ2VWZXJ0aWNhbEdhcE1heE11bHRpcGxpZXI6IG51bWJlcjtcclxuICBwcml2YXRlIHN0YWNrZWRNZXJnZUFsaWduVG9sOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBzdGFja2VkTWVyZ2VPdmVybGFwRnJhYzogbnVtYmVyO1xyXG4gIHByaXZhdGUgc3RhY2tlZE1lcmdlVmVydGljYWxHYXBNdWx0aXBsaWVyOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBzdGFja2VkTWVyZ2VWZXJ0aWNhbEdhcE1heE11bHRpcGxpZXI6IG51bWJlcjtcclxuICBwcml2YXRlIGdlbmVyYWxNZXJnZUFsaWduVG9sOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBnZW5lcmFsTWVyZ2VPdmVybGFwRnJhYzogbnVtYmVyO1xyXG4gIHByaXZhdGUgZ2VuZXJhbE1lcmdlVmVydGljYWxHYXBNdWx0aXBsaWVyOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBnZW5lcmFsTWVyZ2VWZXJ0aWNhbEdhcE1heE11bHRpcGxpZXI6IG51bWJlcjtcclxuICBwcml2YXRlIG5lc3RlZE1lcmdlT3ZlcmxhcEZyYWM6IG51bWJlcjtcclxuICBwcml2YXRlIHN0aXRjaEJhc2VsaW5lVG9sTm9uTWF0aDogbnVtYmVyO1xyXG4gIHByaXZhdGUgc3RpdGNoQmFzZWxpbmVUb2xNYXRoOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBzdGl0Y2hLZXJuVG9sTm9uTWF0aDogbnVtYmVyO1xyXG4gIHByaXZhdGUgc3RpdGNoS2VyblRvbE1hdGg6IG51bWJlcjtcclxuICBwcml2YXRlIGlubGluZVNwYW5CYXNlbGluZVRvbDogbnVtYmVyO1xyXG4gIHByaXZhdGUgaW5saW5lU3Bhbktlcm5Ub2w6IG51bWJlcjtcclxuICBwcml2YXRlIHNhbWVDb2x1bW5Db3ZlcmFnZVJhdGlvOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBtYXRoTWVyZ2VCYXNlbGluZVRvbDogbnVtYmVyO1xyXG4gIHByaXZhdGUgbWF0aE1lcmdlSG9yaXpUb2w6IG51bWJlcjtcclxuICBwcml2YXRlIG1hdGhNZXJnZUNlbnRlclRvbDogbnVtYmVyO1xyXG4gIHByaXZhdGUgc3BsaXRMaW5lSGVpZ2h0VG9sOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBzcGxpdEJvdW5kYXJ5RGVkdXBUb2w6IG51bWJlcjtcclxuICBwcml2YXRlIHNwbGl0SW50ZXJXb3JkR2FwVG9sOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBzcGxpdENvbHVtbkdhcFRvbDogbnVtYmVyO1xyXG5cclxuICAvLyBDb25maWd1cmFibGUgcHJvcGVydGllcyBmb3IgaW5saW5lIHNwYW4gbWVyZ2luZ1xyXG4gIHByaXZhdGUgaW5saW5lU3Bhbk1heFdlaWdodERpZmY6IG51bWJlcjtcclxuICBwcml2YXRlIGlubGluZVNwYW5BbGxvd01peGVkU3R5bGU6IGJvb2xlYW47XHJcblxyXG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzOiBMYXlvdXRTZXR0aW5ncykge1xyXG4gICAgLy8gQXNzaWduIHNldHRpbmdzIGZyb20gdGhlIHBhc3NlZCBvYmplY3RcclxuICAgIHRoaXMubGluZUhlaWdodE11bHRpcGxpZXIgPSBzZXR0aW5ncy5saW5lSGVpZ2h0TXVsdGlwbGllcjtcclxuICAgIHRoaXMuZGVidWdWYWxpZGF0aW9uID0gc2V0dGluZ3MuZGVidWdWYWxpZGF0aW9uO1xyXG4gICAgXHJcbiAgICAvLyBORVc6IENhcHR1cmUgdGhlIGZvcmNlIGxpbmVhciBtZXJnZSBmbGFnXHJcbiAgICB0aGlzLmZvcmNlTGluZWFyTWVyZ2UgPSBzZXR0aW5ncy5wbUZvcmNlTGluZWFyTWVyZ2U7XHJcblxyXG4gICAgdGhpcy5taW5TdHJpcENvbmZpZGVuY2VTcGxpdCA9IHNldHRpbmdzLnBtTWluU3RyaXBDb25maWRlbmNlU3BsaXQ7XHJcbiAgICB0aGlzLm1pblN0cmlwV2lkdGhQeCA9IHNldHRpbmdzLnBtTWluU3RyaXBXaWR0aFB4O1xyXG4gICAgdGhpcy5taW5TdHJpcE92ZXJsYXBGcmFjID0gc2V0dGluZ3MucG1NaW5TdHJpcE92ZXJsYXBGcmFjO1xyXG4gICAgdGhpcy5pbml0aWFsTWVyZ2VCYXNlbGluZVRvbE5vbk1hdGggPSBzZXR0aW5ncy5wbUluaXRpYWxNZXJnZUJhc2VsaW5lVG9sTm9uTWF0aDtcclxuICAgIHRoaXMuaW5pdGlhbE1lcmdlQmFzZWxpbmVUb2xNYXRoID0gc2V0dGluZ3MucG1Jbml0aWFsTWVyZ2VCYXNlbGluZVRvbE1hdGg7XHJcbiAgICB0aGlzLmluaXRpYWxNZXJnZUtlcm5Ub2xOb25NYXRoID0gc2V0dGluZ3MucG1Jbml0aWFsTWVyZ2VLZXJuVG9sTm9uTWF0aDtcclxuICAgIHRoaXMuaW5pdGlhbE1lcmdlS2VyblRvbE1hdGggPSBzZXR0aW5ncy5wbUluaXRpYWxNZXJnZUtlcm5Ub2xNYXRoO1xyXG4gICAgdGhpcy5oeXBoZW5Db250aW51YXRpb25Ub2wgPSBzZXR0aW5ncy5wbUh5cGhlbkNvbnRpbnVhdGlvblRvbDtcclxuICAgIHRoaXMuaW5pdGlhbE1lcmdlQWxpZ25Ub2xOb25NYXRoID0gc2V0dGluZ3MucG1Jbml0aWFsTWVyZ2VBbGlnblRvbE5vbk1hdGg7XHJcbiAgICB0aGlzLmluaXRpYWxNZXJnZUFsaWduVG9sTWF0aCA9IHNldHRpbmdzLnBtSW5pdGlhbE1lcmdlQWxpZ25Ub2xNYXRoO1xyXG4gICAgdGhpcy5pbml0aWFsTWVyZ2VWZXJ0aWNhbEdhcE11bHRpcGxpZXIgPSBzZXR0aW5ncy5wbUluaXRpYWxNZXJnZVZlcnRpY2FsR2FwTXVsdGlwbGllcjtcclxuICAgIHRoaXMuaW5pdGlhbE1lcmdlVmVydGljYWxHYXBNYXhNdWx0aXBsaWVyID0gc2V0dGluZ3MucG1Jbml0aWFsTWVyZ2VWZXJ0aWNhbEdhcE1heE11bHRpcGxpZXI7XHJcbiAgICB0aGlzLnN0YWNrZWRNZXJnZUFsaWduVG9sID0gc2V0dGluZ3MucG1TdGFja2VkTWVyZ2VBbGlnblRvbDtcclxuICAgIHRoaXMuc3RhY2tlZE1lcmdlT3ZlcmxhcEZyYWMgPSBzZXR0aW5ncy5wbVN0YWNrZWRNZXJnZU92ZXJsYXBGcmFjO1xyXG4gICAgdGhpcy5zdGFja2VkTWVyZ2VWZXJ0aWNhbEdhcE11bHRpcGxpZXIgPSBzZXR0aW5ncy5wbVN0YWNrZWRNZXJnZVZlcnRpY2FsR2FwTXVsdGlwbGllcjtcclxuICAgIHRoaXMuc3RhY2tlZE1lcmdlVmVydGljYWxHYXBNYXhNdWx0aXBsaWVyID0gc2V0dGluZ3MucG1TdGFja2VkTWVyZ2VWZXJ0aWNhbEdhcE1heE11bHRpcGxpZXI7XHJcbiAgICB0aGlzLmdlbmVyYWxNZXJnZUFsaWduVG9sID0gc2V0dGluZ3MucG1HZW5lcmFsTWVyZ2VBbGlnblRvbDtcclxuICAgIHRoaXMuZ2VuZXJhbE1lcmdlT3ZlcmxhcEZyYWMgPSBzZXR0aW5ncy5wbUdlbmVyYWxNZXJnZU92ZXJsYXBGcmFjO1xyXG4gICAgdGhpcy5nZW5lcmFsTWVyZ2VWZXJ0aWNhbEdhcE11bHRpcGxpZXIgPSBzZXR0aW5ncy5wbUdlbmVyYWxNZXJnZVZlcnRpY2FsR2FwTXVsdGlwbGllcjtcclxuICAgIHRoaXMuZ2VuZXJhbE1lcmdlVmVydGljYWxHYXBNYXhNdWx0aXBsaWVyID0gc2V0dGluZ3MucG1HZW5lcmFsTWVyZ2VWZXJ0aWNhbEdhcE1heE11bHRpcGxpZXI7XHJcbiAgICB0aGlzLm5lc3RlZE1lcmdlT3ZlcmxhcEZyYWMgPSBzZXR0aW5ncy5wbU5lc3RlZE1lcmdlT3ZlcmxhcEZyYWM7XHJcbiAgICB0aGlzLnN0aXRjaEJhc2VsaW5lVG9sTm9uTWF0aCA9IHNldHRpbmdzLnBtU3RpdGNoQmFzZWxpbmVUb2xOb25NYXRoO1xyXG4gICAgdGhpcy5zdGl0Y2hCYXNlbGluZVRvbE1hdGggPSBzZXR0aW5ncy5wbVN0aXRjaEJhc2VsaW5lVG9sTWF0aDtcclxuICAgIHRoaXMuc3RpdGNoS2VyblRvbE5vbk1hdGggPSBzZXR0aW5ncy5wbVN0aXRjaEtlcm5Ub2xOb25NYXRoO1xyXG4gICAgdGhpcy5zdGl0Y2hLZXJuVG9sTWF0aCA9IHNldHRpbmdzLnBtU3RpdGNoS2VyblRvbE1hdGg7XHJcbiAgICB0aGlzLmlubGluZVNwYW5CYXNlbGluZVRvbCA9IHNldHRpbmdzLnBtSW5saW5lU3BhbkJhc2VsaW5lVG9sO1xyXG4gICAgdGhpcy5pbmxpbmVTcGFuS2VyblRvbCA9IHNldHRpbmdzLnBtSW5saW5lU3Bhbktlcm5Ub2w7XHJcbiAgICB0aGlzLnNhbWVDb2x1bW5Db3ZlcmFnZVJhdGlvID0gc2V0dGluZ3MucG1TYW1lQ29sdW1uQ292ZXJhZ2VSYXRpbztcclxuICAgIHRoaXMubWF0aE1lcmdlQmFzZWxpbmVUb2wgPSBzZXR0aW5ncy5wbU1hdGhNZXJnZUJhc2VsaW5lVG9sO1xyXG4gICAgdGhpcy5tYXRoTWVyZ2VIb3JpelRvbCA9IHNldHRpbmdzLnBtTWF0aE1lcmdlSG9yaXpUb2w7XHJcbiAgICB0aGlzLm1hdGhNZXJnZUNlbnRlclRvbCA9IHNldHRpbmdzLnBtTWF0aE1lcmdlQ2VudGVyVG9sO1xyXG4gICAgdGhpcy5zcGxpdExpbmVIZWlnaHRUb2wgPSBzZXR0aW5ncy5wbVNwbGl0TGluZUhlaWdodFRvbDtcclxuICAgIHRoaXMuc3BsaXRCb3VuZGFyeURlZHVwVG9sID0gc2V0dGluZ3MucG1TcGxpdEJvdW5kYXJ5RGVkdXBUb2w7XHJcbiAgICB0aGlzLnNwbGl0SW50ZXJXb3JkR2FwVG9sID0gc2V0dGluZ3MucG1TcGxpdEludGVyV29yZEdhcFRvbDtcclxuICAgIHRoaXMuc3BsaXRDb2x1bW5HYXBUb2wgPSBzZXR0aW5ncy5wbVNwbGl0Q29sdW1uR2FwVG9sO1xyXG5cclxuICAgIHRoaXMuaW5saW5lU3Bhbk1heFdlaWdodERpZmYgPSBzZXR0aW5ncy5wbUlubGluZVNwYW5NYXhXZWlnaHREaWZmO1xyXG4gICAgdGhpcy5pbmxpbmVTcGFuQWxsb3dNaXhlZFN0eWxlID0gc2V0dGluZ3MucG1JbmxpbmVTcGFuQWxsb3dNaXhlZFN0eWxlO1xyXG4gIH1cclxuXHJcbiAgLy8gMSkgSW5pdGlhbCBzcGFuLXRvLXBhcmFncmFwaCBncm91cGluZyAobWF0aC1hd2FyZSksIG5vIERPTSBjYWxsc1xyXG4gIHB1YmxpYyBtZXJnZUludG9QYXJhZ3JhcGhzRnJvbUluZm9zKHNwYW5JbmZvczogTWFwPEhUTUxTcGFuRWxlbWVudCwgU3BhbkluZm8+KTogSFRNTFNwYW5FbGVtZW50W11bXSB7XHJcbiAgICBjb25zdCBzcGFucyA9IFsuLi5zcGFuSW5mb3Mua2V5cygpXTtcclxuICAgIGNvbnN0IG9yZGVyZWQgPSBzcGFucy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgIGNvbnN0IGlhID0gc3BhbkluZm9zLmdldChhKSEucmVjdDtcclxuICAgICAgY29uc3QgaWIgPSBzcGFuSW5mb3MuZ2V0KGIpIS5yZWN0O1xyXG4gICAgICByZXR1cm4gaWEudG9wIC0gaWIudG9wIHx8IGlhLmxlZnQgLSBpYi5sZWZ0O1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgcGFyYWdyYXBoczogSFRNTFNwYW5FbGVtZW50W11bXSA9IFtdO1xyXG4gICAgbGV0IGN1cnJlbnQ6IEhUTUxTcGFuRWxlbWVudFtdID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcmVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGN1ciA9IG9yZGVyZWRbaV07XHJcbiAgICAgIGNvbnN0IGNpID0gc3BhbkluZm9zLmdldChjdXIpITtcclxuXHJcbiAgICAgIGlmICghY3VycmVudC5sZW5ndGgpIHtcclxuICAgICAgICBjdXJyZW50LnB1c2goY3VyKTtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgcHJldiA9IGN1cnJlbnRbY3VycmVudC5sZW5ndGggLSAxXTtcclxuICAgICAgY29uc3QgcGkgPSBzcGFuSW5mb3MuZ2V0KHByZXYpITtcclxuXHJcbiAgICAgIC8vIFVzZSBzdHlsZSBtYXRjaCBsb2dpYyAod2hpY2ggbm93IHJlc3BlY3RzIGZvcmNlTGluZWFyTWVyZ2UpXHJcbiAgICAgIGNvbnN0IHNhbWVTdHlsZSA9IHRoaXMuc3R5bGVzTWF0Y2goY2ksIHBpLCB0cnVlKTtcclxuICAgICAgY29uc3QgbWF4Rm9udFNpemUgPSBNYXRoLm1heChjaS5zdHlsZS5mb250U2l6ZSwgcGkuc3R5bGUuZm9udFNpemUpO1xyXG4gICAgICBjb25zdCBtaW5GID0gTWF0aC5taW4oY2kuc3R5bGUuZm9udFNpemUsIHBpLnN0eWxlLmZvbnRTaXplKTtcclxuXHJcbiAgICAgIGNvbnN0IGJhc2VUb2wgPSBtaW5GICogKGNpLmlzTWF0aEVsZW1lbnQgfHwgcGkuaXNNYXRoRWxlbWVudCA/IHRoaXMuaW5pdGlhbE1lcmdlQmFzZWxpbmVUb2xNYXRoIDogdGhpcy5pbml0aWFsTWVyZ2VCYXNlbGluZVRvbE5vbk1hdGgpO1xyXG4gICAgICBjb25zdCBzYW1lQmFzZWxpbmUgPSBNYXRoLmFicyhjaS5yZWN0LmJvdHRvbSAtIHBpLnJlY3QuYm90dG9tKSA8IGJhc2VUb2w7XHJcblxyXG4gICAgICBjb25zdCBpc1JUTCA9IGNpLnN0eWxlLmRpcmVjdGlvbiA9PT0gJ3J0bCcgfHwgcGkuc3R5bGUuZGlyZWN0aW9uID09PSAncnRsJztcclxuICAgICAgY29uc3QgZHggPSBjaS5yZWN0LmxlZnQgLSBwaS5yZWN0LnJpZ2h0O1xyXG4gICAgICBjb25zdCBrZXJuVG9sID0gbWluRiAqIChjaS5pc01hdGhFbGVtZW50IHx8IHBpLmlzTWF0aEVsZW1lbnQgPyB0aGlzLmluaXRpYWxNZXJnZUtlcm5Ub2xNYXRoIDogdGhpcy5pbml0aWFsTWVyZ2VLZXJuVG9sTm9uTWF0aCk7XHJcbiAgICAgIGNvbnN0IHNtYWxsSW5saW5lS2VybmluZyA9IHNhbWVCYXNlbGluZSAmJlxyXG4gICAgICAgIChpc1JUTCA/IGR4IDw9IDAgJiYgZHggPiAta2VyblRvbCA6IGR4ID49IDAgJiYgZHggPCBrZXJuVG9sKTtcclxuXHJcbiAgICAgIGNvbnN0IHByZXZUZXh0ID0gKHBpLnRleHQgfHwgJycpLnRyaW0oKTtcclxuICAgICAgY29uc3QgZW5kc1dpdGhIeXBoZW4gPSAvW1xcdTAwQUQtXSQvLnRlc3QocHJldlRleHQpO1xyXG5cclxuICAgICAgY29uc3QgaHlwaGVuQ29udGludWF0aW9uID1cclxuICAgICAgICBlbmRzV2l0aEh5cGhlbiAmJlxyXG4gICAgICAgIGNpLnJlY3QudG9wID4gcGkucmVjdC50b3AgJiZcclxuICAgICAgICBNYXRoLmFicyhjaS5yZWN0LmxlZnQgLSBwaS5yZWN0LmxlZnQpIDwgY2kuc3R5bGUuZm9udFNpemUgKiB0aGlzLmh5cGhlbkNvbnRpbnVhdGlvblRvbDtcclxuXHJcbiAgICAgIGNvbnN0IGxlZnRBbGlnblRvbCA9IG1pbkYgKiAoY2kuaXNNYXRoRWxlbWVudCB8fCBwaS5pc01hdGhFbGVtZW50ID8gdGhpcy5pbml0aWFsTWVyZ2VBbGlnblRvbE1hdGggOiB0aGlzLmluaXRpYWxNZXJnZUFsaWduVG9sTm9uTWF0aCk7XHJcbiAgICAgIGNvbnN0IHJpZ2h0QWxpZ25Ub2wgPSBsZWZ0QWxpZ25Ub2w7XHJcbiAgICAgIGNvbnN0IGxlZnRBbGlnbmVkID0gTWF0aC5hYnMoY2kucmVjdC5sZWZ0IC0gcGkucmVjdC5sZWZ0KSA8IGxlZnRBbGlnblRvbDtcclxuICAgICAgY29uc3QgcmlnaHRBbGlnbmVkID0gTWF0aC5hYnMoY2kucmVjdC5yaWdodCAtIHBpLnJlY3QucmlnaHQpIDwgcmlnaHRBbGlnblRvbDtcclxuXHJcbiAgICAgIGNvbnN0IGxpbmVIZWlnaHRHdWVzcyA9IG1heEZvbnRTaXplICogdGhpcy5saW5lSGVpZ2h0TXVsdGlwbGllcjtcclxuICAgICAgY29uc3QgdmVydGljYWxUb2xlcmFuY2UgPSBNYXRoLm1pbihcclxuICAgICAgICBsaW5lSGVpZ2h0R3Vlc3MgKiB0aGlzLmluaXRpYWxNZXJnZVZlcnRpY2FsR2FwTXVsdGlwbGllcixcclxuICAgICAgICBtYXhGb250U2l6ZSAqIHRoaXMuaW5pdGlhbE1lcmdlVmVydGljYWxHYXBNYXhNdWx0aXBsaWVyXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IHZlcnRpY2FsR2FwID0gY2kucmVjdC50b3AgLSBwaS5yZWN0LmJvdHRvbTtcclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICBzYW1lU3R5bGUgJiZcclxuICAgICAgICAoXHJcbiAgICAgICAgICAodmVydGljYWxHYXAgPD0gdmVydGljYWxUb2xlcmFuY2UgJiYgKGxlZnRBbGlnbmVkIHx8IHJpZ2h0QWxpZ25lZCkpIHx8XHJcbiAgICAgICAgICBzbWFsbElubGluZUtlcm5pbmcgfHxcclxuICAgICAgICAgIGh5cGhlbkNvbnRpbnVhdGlvblxyXG4gICAgICAgIClcclxuICAgICAgKSB7XHJcbiAgICAgICAgY3VycmVudC5wdXNoKGN1cik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGFyYWdyYXBocy5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICAgIGN1cnJlbnQgPSBbY3VyXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChjdXJyZW50Lmxlbmd0aCkgcGFyYWdyYXBocy5wdXNoKGN1cnJlbnQpO1xyXG4gICAgcmV0dXJuIHBhcmFncmFwaHM7XHJcbiAgfVxyXG5cclxuICAvLyAyKSBTcGxpdCBwYXJhZ3JhcGhzIGlmIHRoZXkgY3Jvc3MgdmVydGljYWwgc3RyaXBzICh3aXRoIG5vaXNlIGdhdGluZylcclxuICBwdWJsaWMgdmFsaWRhdGVQYXJhZ3JhcGhzQWdhaW5zdFN0cmlwc0Zyb21JbmZvcyhcclxuICAgIHBhcmFncmFwaHM6IEhUTUxTcGFuRWxlbWVudFtdW10sXHJcbiAgICBzcGFuSW5mb3M6IE1hcDxIVE1MU3BhbkVsZW1lbnQsIFNwYW5JbmZvPixcclxuICAgIHZlcnRpY2FsU3RyaXBzOiBWZXJ0aWNhbFN0cmlwW10gPSBbXSxcclxuICAgIGxpbmVIZWlnaHQ6IG51bWJlciA9IDAsXHJcbiAgICB2aWV3cG9ydFdpZHRoOiBudW1iZXJcclxuICApOiBIVE1MU3BhbkVsZW1lbnRbXVtdIHtcclxuICAgIC8vIE9WRVJIQVVMOiBJZiBmb3JjaW5nIGxpbmVhciBtZXJnZSwgc2tpcCBhbGwgY29sdW1uIHNwbGl0dGluZ1xyXG4gICAgaWYgKHRoaXMuZm9yY2VMaW5lYXJNZXJnZSkge1xyXG4gICAgICByZXR1cm4gcGFyYWdyYXBocztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXZlcnRpY2FsU3RyaXBzPy5sZW5ndGgpIHJldHVybiBwYXJhZ3JhcGhzO1xyXG4gICAgY29uc3QgcmVzdWx0czogSFRNTFNwYW5FbGVtZW50W11bXSA9IFtdO1xyXG5cclxuICAgIGNvbnN0IGZpbHRlcmVkU3RyaXBzID0gdGhpcy5maWx0ZXJTdHJpcHModmVydGljYWxTdHJpcHMsIHZpZXdwb3J0V2lkdGgpO1xyXG5cclxuICAgIGlmICghZmlsdGVyZWRTdHJpcHMubGVuZ3RoKSByZXR1cm4gcGFyYWdyYXBocztcclxuXHJcbiAgICBmb3IgKGNvbnN0IHBhcmEgb2YgcGFyYWdyYXBocykge1xyXG4gICAgICBjb25zdCBwYXJ0cyA9IHRoaXMuc3BsaXRQYXJhZ3JhcGhCeVN0cmlwcyhwYXJhLCBzcGFuSW5mb3MsIGZpbHRlcmVkU3RyaXBzLCBsaW5lSGVpZ2h0KTtcclxuICAgICAgcmVzdWx0cy5wdXNoKC4uLnBhcnRzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9XHJcblxyXG4gIC8vIDMpIE1lcmdlIHZlcnRpY2FsbHkgc3RhY2tlZCBwYXJhZ3JhcGhzIHdpdGhpbiB0aGUgc2FtZSBjb2x1bW4gYW5kIHN0eWxlLCByZXNwZWN0aW5nIGdhcHNcclxuICBwdWJsaWMgbWVyZ2VQYXJhZ3JhcGhzRnJvbUluZm9zKFxyXG4gICAgcGFyYWdyYXBoczogSFRNTFNwYW5FbGVtZW50W11bXSxcclxuICAgIHNwYW5JbmZvczogTWFwPEhUTUxTcGFuRWxlbWVudCwgU3BhbkluZm8+LFxyXG4gICAgbGluZUhlaWdodDogbnVtYmVyLFxyXG4gICAgdmVydGljYWxTdHJpcHM6IFZlcnRpY2FsU3RyaXBbXSA9IFtdLFxyXG4gICAgaG9yaXpvbnRhbEJhbmRzOiBIb3Jpem9udGFsQmFuZFtdID0gW10sXHJcbiAgICB2aWV3cG9ydFdpZHRoOiBudW1iZXJcclxuICApOiBIVE1MU3BhbkVsZW1lbnRbXVtdIHtcclxuICAgIGNvbnN0IG1lcmdlZDogSFRNTFNwYW5FbGVtZW50W11bXSA9IFtdO1xyXG4gICAgY29uc3QgdXNlZCA9IG5ldyBTZXQ8bnVtYmVyPigpO1xyXG4gICAgY29uc3QgZmlsdGVyZWRTdHJpcHMgPSB0aGlzLmZpbHRlclN0cmlwcyh2ZXJ0aWNhbFN0cmlwcywgdmlld3BvcnRXaWR0aCk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhZ3JhcGhzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh1c2VkLmhhcyhpKSkgY29udGludWU7XHJcbiAgICAgIGxldCBjdXJyZW50ID0gWy4uLnBhcmFncmFwaHNbaV1dO1xyXG4gICAgICBjb25zdCBjdXJyU3R5bGUgPSBzcGFuSW5mb3MuZ2V0KGN1cnJlbnRbMF0pIS5zdHlsZTtcclxuICAgICAgY29uc3QgY3VyckJib3ggPSB0aGlzLmdldFBhcmFCYm94KGN1cnJlbnQsIHNwYW5JbmZvcyk7XHJcblxyXG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBwYXJhZ3JhcGhzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgaWYgKHVzZWQuaGFzKGopKSBjb250aW51ZTtcclxuICAgICAgICBjb25zdCBuZXh0ID0gcGFyYWdyYXBoc1tqXTtcclxuICAgICAgICBjb25zdCBuZXh0U3R5bGUgPSBzcGFuSW5mb3MuZ2V0KG5leHRbMF0pIS5zdHlsZTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnN0eWxlc01hdGNoU3R5bGUoY3VyclN0eWxlLCBuZXh0U3R5bGUsIHRydWUpKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgY29uc3QgbmV4dEJib3ggPSB0aGlzLmdldFBhcmFCYm94KG5leHQsIHNwYW5JbmZvcyk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrcyBmb3IgY29sdW1uIGFsaWdubWVudCBhbmQgaG9yaXpvbnRhbCBiYW5kcyAoYm90aCBub3cgcmVzcGVjdCBmb3JjZUxpbmVhck1lcmdlKVxyXG4gICAgICAgIGlmICghdGhpcy5zYW1lQ29sdW1uQnlTdHJpcHMoY3VyckJib3gsIG5leHRCYm94LCBmaWx0ZXJlZFN0cmlwcykpIGNvbnRpbnVlO1xyXG4gICAgICAgIGlmICh0aGlzLmhhc0hvcml6b250YWxCYW5kQmV0d2VlbihjdXJyQmJveCwgbmV4dEJib3gsIGhvcml6b250YWxCYW5kcykpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0aWNhbEdhcCA9IG5leHRCYm94LnRvcCAtIGN1cnJCYm94LmJvdHRvbTtcclxuICAgICAgICBjb25zdCBob3Jpem9udGFsT3ZlcmxhcCA9IGN1cnJCYm94LmxlZnQgPCBuZXh0QmJveC5yaWdodCAmJiBjdXJyQmJveC5yaWdodCA+IG5leHRCYm94LmxlZnQ7XHJcbiAgICAgICAgY29uc3Qgb3ZlcmxhcFdpZHRoID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oY3VyckJib3gucmlnaHQsIG5leHRCYm94LnJpZ2h0KSAtIE1hdGgubWF4KGN1cnJCYm94LmxlZnQsIG5leHRCYm94LmxlZnQpKTtcclxuICAgICAgICBjb25zdCBtaW5QYXJhV2lkdGggPSBNYXRoLm1heCgxLCBNYXRoLm1pbihjdXJyQmJveC53aWR0aCwgbmV4dEJib3gud2lkdGgpKTtcclxuICAgICAgICBjb25zdCBvdmVybGFwU3Ryb25nID0gaG9yaXpvbnRhbE92ZXJsYXAgJiYgb3ZlcmxhcFdpZHRoID4gdGhpcy5nZW5lcmFsTWVyZ2VPdmVybGFwRnJhYyAqIG1pblBhcmFXaWR0aDtcclxuXHJcbiAgICAgICAgY29uc3QgbGVmdEFsaWduVG9sID0gY3VyclN0eWxlLmZvbnRTaXplICogdGhpcy5nZW5lcmFsTWVyZ2VBbGlnblRvbDtcclxuICAgICAgICBjb25zdCBsZWZ0QWxpZ25lZCA9IE1hdGguYWJzKGN1cnJCYm94LmxlZnQgLSBuZXh0QmJveC5sZWZ0KSA8IGxlZnRBbGlnblRvbDtcclxuICAgICAgICBjb25zdCByaWdodEFsaWduZWQgPSBNYXRoLmFicyhjdXJyQmJveC5yaWdodCAtIG5leHRCYm94LnJpZ2h0KSA8IGxlZnRBbGlnblRvbDtcclxuICAgICAgICBjb25zdCBhbGlnbmVkID0gbGVmdEFsaWduZWQgfHwgcmlnaHRBbGlnbmVkO1xyXG5cclxuICAgICAgICAvLyBJbiBmb3JjZWQgbW9kZSwgdGhlIGxheW91dC9hbGlnbm1lbnQgY2hlY2tzIG1hdHRlciBsZXNzLCBidXQgd2UgdXN1YWxseSByZWx5IG9uIHZlcnRpY2FsIGdhcFxyXG4gICAgICAgIC8vIHRvIHByZXZlbnQgaGVhZGVyIC0+IGZvb3RlciBtZXJnZXMuIFRoZSBVc2VyIHNob3VsZCBpbmNyZWFzZSBnYXAgbXVsdGlwbGllcnMgaW4gc2V0dGluZ3MgaWZcclxuICAgICAgICAvLyB0aGV5IHdhbnQgdG8gYnJpZGdlIGxhcmdlIGdhcHMuXHJcbiAgICAgICAgY29uc3QgbWVyZ2VUaHJlc2hvbGQgPSBNYXRoLm1pbihsaW5lSGVpZ2h0ICogdGhpcy5nZW5lcmFsTWVyZ2VWZXJ0aWNhbEdhcE11bHRpcGxpZXIsIE1hdGgubWF4KGN1cnJTdHlsZS5mb250U2l6ZSwgbmV4dFN0eWxlLmZvbnRTaXplKSAqIHRoaXMuZ2VuZXJhbE1lcmdlVmVydGljYWxHYXBNYXhNdWx0aXBsaWVyKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBJbiBmb3JjZSBtb2RlLCB3ZSBhcmUgbW9yZSBwZXJtaXNzaXZlIGFib3V0IGFsaWdubWVudCBpZiB0aGUgZ2FwIGlzIHNtYWxsIGVub3VnaFxyXG4gICAgICAgIGNvbnN0IHBlcm1pc3NpdmVBbGlnbm1lbnQgPSB0aGlzLmZvcmNlTGluZWFyTWVyZ2UgfHwgKGFsaWduZWQgfHwgb3ZlcmxhcFN0cm9uZyk7XHJcblxyXG4gICAgICAgIGlmICh2ZXJ0aWNhbEdhcCA8PSBtZXJnZVRocmVzaG9sZCAmJiBwZXJtaXNzaXZlQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICBjdXJyZW50LnB1c2goLi4ubmV4dCk7XHJcbiAgICAgICAgICB1c2VkLmFkZChqKTtcclxuICAgICAgICAgIGNvbnN0IG5ld0Jib3ggPSB0aGlzLmdldFBhcmFCYm94KGN1cnJlbnQsIHNwYW5JbmZvcyk7XHJcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGN1cnJCYm94LCBuZXdCYm94KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG1lcmdlZC5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICB1c2VkLmFkZChpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWVyZ2VkO1xyXG4gIH1cclxuXHJcbiAgLy8gMy41KSBNZXJnZSBzdGFja2VkIGNvbHVtbi1hbGlnbmVkIHBhcmFncmFwaHMgKGZpbmFsIHN0YWNrZWQgcGFzcylcclxuICBwdWJsaWMgbWVyZ2VTdGFja2VkQ29sdW1uUGFyYWdyYXBoc0Zyb21JbmZvcyhcclxuICAgIHBhcmFncmFwaHM6IEhUTUxTcGFuRWxlbWVudFtdW10sXHJcbiAgICBzcGFuSW5mb3M6IE1hcDxIVE1MU3BhbkVsZW1lbnQsIFNwYW5JbmZvPixcclxuICAgIGxpbmVIZWlnaHQ6IG51bWJlcixcclxuICAgIHZlcnRpY2FsU3RyaXBzOiBWZXJ0aWNhbFN0cmlwW10gPSBbXSxcclxuICAgIGhvcml6b250YWxCYW5kczogSG9yaXpvbnRhbEJhbmRbXSA9IFtdLFxyXG4gICAgdmlld3BvcnRXaWR0aDogbnVtYmVyXHJcbiAgKTogSFRNTFNwYW5FbGVtZW50W11bXSB7XHJcbiAgICBpZiAoIXBhcmFncmFwaHMubGVuZ3RoKSByZXR1cm4gcGFyYWdyYXBocztcclxuXHJcbiAgICB0eXBlIFBJbmZvID0ge1xyXG4gICAgICBzcGFuczogSFRNTFNwYW5FbGVtZW50W107XHJcbiAgICAgIGJib3g6IFJlY3RMaWtlO1xyXG4gICAgICBzdHlsZTogU3BhbkluZm9bJ3N0eWxlJ107XHJcbiAgICAgIGlzTWF0aDogYm9vbGVhbjtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZmlsdGVyZWRTdHJpcHMgPSB0aGlzLmZpbHRlclN0cmlwcyh2ZXJ0aWNhbFN0cmlwcywgdmlld3BvcnRXaWR0aCk7XHJcbiAgICBjb25zdCBpbmZvczogUEluZm9bXSA9IHBhcmFncmFwaHMubWFwKHNwYW5zID0+IHtcclxuICAgICAgY29uc3QgYmJveCA9IHRoaXMuZ2V0UGFyYUJib3goc3BhbnMsIHNwYW5JbmZvcyk7XHJcbiAgICAgIGNvbnN0IHN0eWxlID0gc3BhbkluZm9zLmdldChzcGFuc1swXSkhLnN0eWxlO1xyXG4gICAgICBjb25zdCBpc01hdGggPSBzcGFucy5zb21lKHMgPT4gc3BhbkluZm9zLmdldChzKSEuaXNNYXRoRWxlbWVudCk7XHJcbiAgICAgIHJldHVybiB7IHNwYW5zLCBiYm94LCBzdHlsZSwgaXNNYXRoIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICBpbmZvcy5zb3J0KChhLCBiKSA9PiBhLmJib3gudG9wIC0gYi5iYm94LnRvcCB8fCBhLmJib3gubGVmdCAtIGIuYmJveC5sZWZ0KTtcclxuXHJcbiAgICBsZXQgY2hhbmdlZCA9IHRydWU7XHJcbiAgICB3aGlsZSAoY2hhbmdlZCkge1xyXG4gICAgICBjaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgIGNvbnN0IHVzZWQgPSBuZXcgU2V0PG51bWJlcj4oKTtcclxuICAgICAgY29uc3Qgb3V0OiBQSW5mb1tdID0gW107XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZm9zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHVzZWQuaGFzKGkpKSBjb250aW51ZTtcclxuICAgICAgICBsZXQgYmFzZSA9IGluZm9zW2ldO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBpbmZvcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgaWYgKHVzZWQuaGFzKGopKSBjb250aW51ZTtcclxuICAgICAgICAgIGNvbnN0IGNhbmQgPSBpbmZvc1tqXTtcclxuXHJcbiAgICAgICAgICBpZiAoIXRoaXMuc3R5bGVzTWF0Y2hTdHlsZShiYXNlLnN0eWxlLCBjYW5kLnN0eWxlLCB0cnVlKSkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgaWYgKCF0aGlzLnNhbWVDb2x1bW5CeVN0cmlwcyhiYXNlLmJib3gsIGNhbmQuYmJveCwgZmlsdGVyZWRTdHJpcHMpKSBjb250aW51ZTtcclxuICAgICAgICAgIGlmICh0aGlzLmhhc0hvcml6b250YWxCYW5kQmV0d2VlbihiYXNlLmJib3gsIGNhbmQuYmJveCwgaG9yaXpvbnRhbEJhbmRzKSkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgY29uc3QgdmVydGljYWxHYXAgPSBjYW5kLmJib3gudG9wIC0gYmFzZS5iYm94LmJvdHRvbTtcclxuICAgICAgICAgIGlmICh2ZXJ0aWNhbEdhcCA8IDApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGhvcml6b250YWxPdmVybGFwID0gYmFzZS5iYm94LmxlZnQgPCBjYW5kLmJib3gucmlnaHQgJiYgYmFzZS5iYm94LnJpZ2h0ID4gY2FuZC5iYm94LmxlZnQ7XHJcbiAgICAgICAgICBjb25zdCBvdmVybGFwV2lkdGggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihiYXNlLmJib3gucmlnaHQsIGNhbmQuYmJveC5yaWdodCkgLSBNYXRoLm1heChiYXNlLmJib3gubGVmdCwgY2FuZC5iYm94LmxlZnQpKTtcclxuICAgICAgICAgIGNvbnN0IG1pblBhcmFXaWR0aCA9IE1hdGgubWF4KDEsIE1hdGgubWluKGJhc2UuYmJveC53aWR0aCwgY2FuZC5iYm94LndpZHRoKSk7XHJcbiAgICAgICAgICBjb25zdCBvdmVybGFwU3Ryb25nID0gaG9yaXpvbnRhbE92ZXJsYXAgJiYgb3ZlcmxhcFdpZHRoID4gdGhpcy5zdGFja2VkTWVyZ2VPdmVybGFwRnJhYyAqIG1pblBhcmFXaWR0aDtcclxuXHJcbiAgICAgICAgICBjb25zdCBsZWZ0QWxpZ25Ub2wgPSBNYXRoLm1heCgxLCBNYXRoLm1pbihiYXNlLnN0eWxlLmZvbnRTaXplLCBjYW5kLnN0eWxlLmZvbnRTaXplKSAqIHRoaXMuc3RhY2tlZE1lcmdlQWxpZ25Ub2wpO1xyXG4gICAgICAgICAgY29uc3QgbGVmdEFsaWduZWQgPSBNYXRoLmFicyhiYXNlLmJib3gubGVmdCAtIGNhbmQuYmJveC5sZWZ0KSA8IGxlZnRBbGlnblRvbDtcclxuICAgICAgICAgIGNvbnN0IHJpZ2h0QWxpZ25lZCA9IE1hdGguYWJzKGJhc2UuYmJveC5yaWdodCAtIGNhbmQuYmJveC5yaWdodCkgPCBsZWZ0QWxpZ25Ub2w7XHJcbiAgICAgICAgICBjb25zdCBhbGlnbmVkID0gbGVmdEFsaWduZWQgfHwgcmlnaHRBbGlnbmVkO1xyXG5cclxuICAgICAgICAgIGNvbnN0IG1heEZvbnRTaXplID0gTWF0aC5tYXgoYmFzZS5zdHlsZS5mb250U2l6ZSwgY2FuZC5zdHlsZS5mb250U2l6ZSk7XHJcbiAgICAgICAgICBjb25zdCBtZXJnZVRocmVzaG9sZCA9IE1hdGgubWluKGxpbmVIZWlnaHQgKiB0aGlzLnN0YWNrZWRNZXJnZVZlcnRpY2FsR2FwTXVsdGlwbGllciwgbWF4Rm9udFNpemUgKiB0aGlzLnN0YWNrZWRNZXJnZVZlcnRpY2FsR2FwTWF4TXVsdGlwbGllcik7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IHBlcm1pc3NpdmVBbGlnbm1lbnQgPSB0aGlzLmZvcmNlTGluZWFyTWVyZ2UgfHwgKGFsaWduZWQgfHwgb3ZlcmxhcFN0cm9uZyk7XHJcblxyXG4gICAgICAgICAgaWYgKHBlcm1pc3NpdmVBbGlnbm1lbnQgJiYgdmVydGljYWxHYXAgPD0gbWVyZ2VUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgY29uc3QgY29tYmluZWRTcGFucyA9IFsuLi5iYXNlLnNwYW5zLCAuLi5jYW5kLnNwYW5zXVxyXG4gICAgICAgICAgICAgIC5tYXAocyA9PiAoeyBzLCByOiBzcGFuSW5mb3MuZ2V0KHMpIS5yZWN0IH0pKVxyXG4gICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnIudG9wIC0gYi5yLnRvcCB8fCBhLnIubGVmdCAtIGIuci5sZWZ0KVxyXG4gICAgICAgICAgICAgIC5tYXAoeCA9PiB4LnMpO1xyXG5cclxuICAgICAgICAgICAgYmFzZSA9IHtcclxuICAgICAgICAgICAgICBzcGFuczogY29tYmluZWRTcGFucyxcclxuICAgICAgICAgICAgICBiYm94OiB0aGlzLmdldFBhcmFCYm94KGNvbWJpbmVkU3BhbnMsIHNwYW5JbmZvcyksXHJcbiAgICAgICAgICAgICAgc3R5bGU6IGJhc2Uuc3R5bGUsXHJcbiAgICAgICAgICAgICAgaXNNYXRoOiBjb21iaW5lZFNwYW5zLnNvbWUocyA9PiBzcGFuSW5mb3MuZ2V0KHMpIS5pc01hdGhFbGVtZW50KVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdXNlZC5hZGQoaik7XHJcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3V0LnB1c2goYmFzZSk7XHJcbiAgICAgICAgdXNlZC5hZGQoaSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjaGFuZ2VkKSB7XHJcbiAgICAgICAgaW5mb3MubGVuZ3RoID0gMDtcclxuICAgICAgICBpbmZvcy5wdXNoKC4uLm91dC5zb3J0KChhLCBiKSA9PiBhLmJib3gudG9wIC0gYi5iYm94LnRvcCB8fCBhLmJib3gubGVmdCAtIGIuYmJveC5sZWZ0KSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG91dC5tYXAocCA9PiBwLnNwYW5zKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXJhZ3JhcGhzO1xyXG4gIH1cclxuXHJcbiAgLy8gNCkgU2luZ2xlLXBhc3MgbmVzdGVkL292ZXJsYXAgbWVyZ2luZywgbWF0aC1hd2FyZSwgcmVzcGVjdGluZyBzdHJpcHNcclxuICBwdWJsaWMgbWVyZ2VOZXN0ZWRQYXJhZ3JhcGhzT25jZUZyb21JbmZvcyhcclxuICAgIHBhcmFncmFwaHM6IEhUTUxTcGFuRWxlbWVudFtdW10sXHJcbiAgICBzcGFuSW5mb3M6IE1hcDxIVE1MU3BhbkVsZW1lbnQsIFNwYW5JbmZvPixcclxuICAgIHZlcnRpY2FsU3RyaXBzOiBWZXJ0aWNhbFN0cmlwW10gPSBbXSxcclxuICAgIGhvcml6b250YWxCYW5kczogSG9yaXpvbnRhbEJhbmRbXSA9IFtdLFxyXG4gICAgdmlld3BvcnRXaWR0aDogbnVtYmVyXHJcbiAgKTogeyBwYXJhZ3JhcGhzOiBIVE1MU3BhbkVsZW1lbnRbXVtdOyBjaGFuZ2VkOiBib29sZWFuIH0ge1xyXG4gICAgaWYgKCFwYXJhZ3JhcGhzLmxlbmd0aCkgcmV0dXJuIHsgcGFyYWdyYXBocywgY2hhbmdlZDogZmFsc2UgfTtcclxuXHJcbiAgICB0eXBlIFBJbmZvID0ge1xyXG4gICAgICBzcGFuczogSFRNTFNwYW5FbGVtZW50W107XHJcbiAgICAgIGJib3g6IFJlY3RMaWtlO1xyXG4gICAgICBzdHlsZTogU3BhbkluZm9bJ3N0eWxlJ107XHJcbiAgICAgIGlzTWF0aDogYm9vbGVhbjtcclxuICAgICAgdGV4dDogc3RyaW5nO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBmaWx0ZXJlZFN0cmlwcyA9IHRoaXMuZmlsdGVyU3RyaXBzKHZlcnRpY2FsU3RyaXBzLCB2aWV3cG9ydFdpZHRoKTtcclxuICAgIGNvbnN0IGluZm9zOiBQSW5mb1tdID0gcGFyYWdyYXBocy5tYXAocCA9PiB7XHJcbiAgICAgIGNvbnN0IGJib3ggPSB0aGlzLmdldFBhcmFCYm94KHAsIHNwYW5JbmZvcyk7XHJcbiAgICAgIGNvbnN0IHN0eWxlID0gc3BhbkluZm9zLmdldChwWzBdKSEuc3R5bGU7XHJcbiAgICAgIGNvbnN0IGlzTWF0aCA9IHAuc29tZShzID0+IHNwYW5JbmZvcy5nZXQocykhLmlzTWF0aEVsZW1lbnQpO1xyXG4gICAgICBjb25zdCB0ZXh0ID0gcC5tYXAocyA9PiBzcGFuSW5mb3MuZ2V0KHMpIS50ZXh0KS5qb2luKCcnKTtcclxuICAgICAgcmV0dXJuIHsgc3BhbnM6IFsuLi5wXSwgYmJveCwgc3R5bGUsIGlzTWF0aCwgdGV4dCB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcclxuICAgIGNvbnN0IHVzZWQgPSBuZXcgU2V0PG51bWJlcj4oKTtcclxuICAgIGNvbnN0IG91dDogSFRNTFNwYW5FbGVtZW50W11bXSA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5mb3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHVzZWQuaGFzKGkpKSBjb250aW51ZTtcclxuICAgICAgbGV0IGJhc2UgPSBpbmZvc1tpXTtcclxuICAgICAgbGV0IG1lcmdlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmZvcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIGlmIChpID09PSBqIHx8IHVzZWQuaGFzKGopKSBjb250aW51ZTtcclxuICAgICAgICBjb25zdCBjYW5kID0gaW5mb3Nbal07XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5zdHlsZXNNYXRjaFN0eWxlKGJhc2Uuc3R5bGUsIGNhbmQuc3R5bGUsIHRydWUpKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnNhbWVDb2x1bW5CeVN0cmlwcyhiYXNlLmJib3gsIGNhbmQuYmJveCwgZmlsdGVyZWRTdHJpcHMpKSBjb250aW51ZTtcclxuICAgICAgICBpZiAodGhpcy5oYXNIb3Jpem9udGFsQmFuZEJldHdlZW4oYmFzZS5iYm94LCBjYW5kLmJib3gsIGhvcml6b250YWxCYW5kcykpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBjb25zdCBjb250YWluc0lKID0gdGhpcy5yZWN0Q29udGFpbnMoYmFzZS5iYm94LCBjYW5kLmJib3gsIDEpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5zSkkgPSB0aGlzLnJlY3RDb250YWlucyhjYW5kLmJib3gsIGJhc2UuYmJveCwgMSk7XHJcbiAgICAgICAgbGV0IHN0cm9uZ092ZXJsYXAgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKCFjb250YWluc0lKICYmICFjb250YWluc0pJKSB7XHJcbiAgICAgICAgICBjb25zdCBpbnRlciA9IHRoaXMucmVjdEludGVyc2VjdGlvbihiYXNlLmJib3gsIGNhbmQuYmJveCk7XHJcbiAgICAgICAgICBpZiAoaW50ZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgaW50ZXJBcmVhID0gaW50ZXIud2lkdGggKiBpbnRlci5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHNtYWxsZXIgPSBNYXRoLm1pbih0aGlzLmFyZWEoYmFzZS5iYm94KSwgdGhpcy5hcmVhKGNhbmQuYmJveCkpIHx8IDE7XHJcbiAgICAgICAgICAgIHN0cm9uZ092ZXJsYXAgPSBpbnRlckFyZWEgLyBzbWFsbGVyID4gdGhpcy5uZXN0ZWRNZXJnZU92ZXJsYXBGcmFjO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbWF0aE1lcmdlID0gKGJhc2UuaXNNYXRoIHx8IGNhbmQuaXNNYXRoKSAmJiB0aGlzLmlzTWF0aE1lcmdlQ2FuZGlkYXRlKGJhc2UsIGNhbmQsIGZpbHRlcmVkU3RyaXBzKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbnRhaW5zSUogfHwgY29udGFpbnNKSSB8fCBzdHJvbmdPdmVybGFwIHx8IG1hdGhNZXJnZSkge1xyXG4gICAgICAgICAgY29uc3QgYmFzZUxhcmdlciA9IHRoaXMuYXJlYShiYXNlLmJib3gpID49IHRoaXMuYXJlYShjYW5kLmJib3gpO1xyXG4gICAgICAgICAgY29uc3Qga2VlcCA9IGJhc2VMYXJnZXIgPyBiYXNlIDogY2FuZDtcclxuICAgICAgICAgIGNvbnN0IGFkZCA9IGJhc2VMYXJnZXIgPyBjYW5kIDogYmFzZTtcclxuXHJcbiAgICAgICAgICBjb25zdCBjb21iaW5lZCA9IFsuLi5rZWVwLnNwYW5zLCAuLi5hZGQuc3BhbnNdXHJcbiAgICAgICAgICAgIC5tYXAocyA9PiAoeyBzLCByOiBzcGFuSW5mb3MuZ2V0KHMpIS5yZWN0IH0pKVxyXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5yLnRvcCAtIGIuci50b3AgfHwgYS5yLmxlZnQgLSBiLnIubGVmdClcclxuICAgICAgICAgICAgLm1hcCh4ID0+IHgucyk7XHJcblxyXG4gICAgICAgICAgYmFzZSA9IHtcclxuICAgICAgICAgICAgc3BhbnM6IGNvbWJpbmVkLFxyXG4gICAgICAgICAgICBiYm94OiB0aGlzLmdldFBhcmFCYm94KGNvbWJpbmVkLCBzcGFuSW5mb3MpLFxyXG4gICAgICAgICAgICBzdHlsZToga2VlcC5zdHlsZSxcclxuICAgICAgICAgICAgaXNNYXRoOiBjb21iaW5lZC5zb21lKHMgPT4gc3BhbkluZm9zLmdldChzKSEuaXNNYXRoRWxlbWVudCksXHJcbiAgICAgICAgICAgIHRleHQ6IGNvbWJpbmVkLm1hcChzID0+IHNwYW5JbmZvcy5nZXQocykhLnRleHQpLmpvaW4oJycpXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHVzZWQuYWRkKGkpO1xyXG4gICAgICAgICAgdXNlZC5hZGQoaik7XHJcbiAgICAgICAgICBtZXJnZWQgPSB0cnVlO1xyXG4gICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG91dC5wdXNoKGJhc2Uuc3BhbnMpO1xyXG4gICAgICBpZiAoIW1lcmdlZCkgdXNlZC5hZGQoaSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgcGFyYWdyYXBoczogb3V0LCBjaGFuZ2VkIH07XHJcbiAgfVxyXG5cclxuICAvLyA1KSBJbmxpbmUgbGlnYXR1cmUvZnJhZ21lbnQgc3RpdGNoaW5nIGF0IHNhbWUgYmFzZWxpbmVcclxuICBwdWJsaWMgc3RpdGNoSW5saW5lTGlnYXR1cmVzRnJvbUluZm9zKFxyXG4gICAgcGFyYWdyYXBoczogSFRNTFNwYW5FbGVtZW50W11bXSxcclxuICAgIHNwYW5JbmZvczogTWFwPEhUTUxTcGFuRWxlbWVudCwgU3BhbkluZm8+XHJcbiAgKTogSFRNTFNwYW5FbGVtZW50W11bXSB7XHJcbiAgICBpZiAoIXBhcmFncmFwaHMubGVuZ3RoKSByZXR1cm4gcGFyYWdyYXBocztcclxuXHJcbiAgICBjb25zdCByZXN1bHRzOiBIVE1MU3BhbkVsZW1lbnRbXVtdID0gW107XHJcblxyXG4gICAgZm9yIChjb25zdCBwIG9mIHBhcmFncmFwaHMpIHtcclxuICAgICAgaWYgKHAubGVuZ3RoIDwgMikgeyByZXN1bHRzLnB1c2gocCk7IGNvbnRpbnVlOyB9XHJcblxyXG4gICAgICBjb25zdCBvcmRlcmVkID0gcFxyXG4gICAgICAgIC5tYXAocyA9PiAoeyBzLCBpbmZvOiBzcGFuSW5mb3MuZ2V0KHMpISB9KSlcclxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5pbmZvLnJlY3QudG9wIC0gYi5pbmZvLnJlY3QudG9wIHx8IGEuaW5mby5yZWN0LmxlZnQgLSBiLmluZm8ucmVjdC5sZWZ0KTtcclxuXHJcbiAgICAgIGNvbnN0IHN0aXRjaGVkOiBIVE1MU3BhbkVsZW1lbnRbXSA9IFtdO1xyXG4gICAgICBsZXQgZ3JvdXA6IEhUTUxTcGFuRWxlbWVudFtdID0gW29yZGVyZWRbMF0uc107XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG9yZGVyZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwcmV2SSA9IG9yZGVyZWRbaSAtIDFdLmluZm87XHJcbiAgICAgICAgY29uc3QgY3VySSA9IG9yZGVyZWRbaV0uaW5mbztcclxuXHJcbiAgICAgICAgY29uc3Qgc2FtZVN0eWxlID0gdGhpcy5zdHlsZXNNYXRjaChwcmV2SSwgY3VySSwgdHJ1ZSk7XHJcbiAgICAgICAgY29uc3QgbWluRiA9IE1hdGgubWluKHByZXZJLnN0eWxlLmZvbnRTaXplLCBjdXJJLnN0eWxlLmZvbnRTaXplKTtcclxuXHJcbiAgICAgICAgY29uc3QgYmFzZVRvbCA9IG1pbkYgKiAocHJldkkuaXNNYXRoRWxlbWVudCB8fCBjdXJJLmlzTWF0aEVsZW1lbnQgPyB0aGlzLnN0aXRjaEJhc2VsaW5lVG9sTWF0aCA6IHRoaXMuc3RpdGNoQmFzZWxpbmVUb2xOb25NYXRoKTtcclxuICAgICAgICBjb25zdCBiYXNlbGluZUNsb3NlID0gTWF0aC5hYnMocHJldkkucmVjdC5ib3R0b20gLSBjdXJJLnJlY3QuYm90dG9tKSA8IGJhc2VUb2w7XHJcblxyXG4gICAgICAgIGNvbnN0IGR4ID0gY3VySS5yZWN0LmxlZnQgLSBwcmV2SS5yZWN0LnJpZ2h0O1xyXG4gICAgICAgIGNvbnN0IGtlcm5Ub2wgPSBtaW5GICogKHByZXZJLmlzTWF0aEVsZW1lbnQgfHwgY3VySS5pc01hdGhFbGVtZW50ID8gdGhpcy5zdGl0Y2hLZXJuVG9sTWF0aCA6IHRoaXMuc3RpdGNoS2VyblRvbE5vbk1hdGgpO1xyXG5cclxuICAgICAgICBpZiAoc2FtZVN0eWxlICYmIGJhc2VsaW5lQ2xvc2UgJiYgZHggPj0gMCAmJiBkeCA8IGtlcm5Ub2wpIHtcclxuICAgICAgICAgIGdyb3VwLnB1c2gob3JkZXJlZFtpXS5zKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3RpdGNoZWQucHVzaCguLi5ncm91cCk7XHJcbiAgICAgICAgICBncm91cCA9IFtvcmRlcmVkW2ldLnNdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgc3RpdGNoZWQucHVzaCguLi5ncm91cCk7XHJcbiAgICAgIHJlc3VsdHMucHVzaChzdGl0Y2hlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNZXJnZSBuZXN0ZWQgaW5saW5lIHNwYW5zIChjdXJzaXZlL2JvbGQpIHRoYXQgc2hhcmUgdGhlIHNhbWUgbGluZSBhbmQgZm9udCBmYW1pbHlcclxuICAgKiBiYWNrIGludG8gdGhlaXIgcGFyZW50IHBhcmFncmFwaHMuXHJcbiAgICovXHJcbiAgcHVibGljIG1lcmdlTmVzdGVkSW5saW5lU3BhbnNGcm9tSW5mb3MoXHJcbiAgICBwYXJhZ3JhcGhzOiBIVE1MU3BhbkVsZW1lbnRbXVtdLFxyXG4gICAgc3BhbkluZm9zOiBNYXA8SFRNTFNwYW5FbGVtZW50LCBTcGFuSW5mbz5cclxuICApOiBIVE1MU3BhbkVsZW1lbnRbXVtdIHtcclxuICAgIGlmICghcGFyYWdyYXBocy5sZW5ndGgpIHJldHVybiBwYXJhZ3JhcGhzO1xyXG5cclxuICAgIGNvbnN0IHJlc3VsdHM6IEhUTUxTcGFuRWxlbWVudFtdW10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHBhcmFncmFwaCBvZiBwYXJhZ3JhcGhzKSB7XHJcbiAgICAgIGlmIChwYXJhZ3JhcGgubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICByZXN1bHRzLnB1c2goWy4uLnBhcmFncmFwaF0pO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBwYXJhU3R5bGUgPSBzcGFuSW5mb3MuZ2V0KHBhcmFncmFwaFswXSkhLnN0eWxlO1xyXG5cclxuICAgICAgY29uc3Qgc29ydGVkU3BhbnMgPSBbLi4ucGFyYWdyYXBoXS5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVjdEEgPSBzcGFuSW5mb3MuZ2V0KGEpIS5yZWN0O1xyXG4gICAgICAgIGNvbnN0IHJlY3RCID0gc3BhbkluZm9zLmdldChiKSEucmVjdDtcclxuICAgICAgICByZXR1cm4gcmVjdEEudG9wIC0gcmVjdEIudG9wIHx8IHJlY3RBLmxlZnQgLSByZWN0Qi5sZWZ0O1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGxpbmVzOiBIVE1MU3BhbkVsZW1lbnRbXVtdID0gW107XHJcbiAgICAgIGxldCBjdXJyZW50TGluZTogSFRNTFNwYW5FbGVtZW50W10gPSBbXTtcclxuICAgICAgbGV0IGN1cnJlbnRMaW5lVG9wID0gLUluZmluaXR5O1xyXG4gICAgICBjb25zdCBsaW5lSGVpZ2h0VG9sZXJhbmNlID0gcGFyYVN0eWxlLmZvbnRTaXplICogdGhpcy5zcGxpdExpbmVIZWlnaHRUb2w7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IHNwYW4gb2Ygc29ydGVkU3BhbnMpIHtcclxuICAgICAgICBjb25zdCBzcGFuSW5mbyA9IHNwYW5JbmZvcy5nZXQoc3BhbikhO1xyXG4gICAgICAgIGNvbnN0IHNwYW5Ub3AgPSBzcGFuSW5mby5yZWN0LnRvcDtcclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lLmxlbmd0aCA9PT0gMCB8fCBNYXRoLmFicyhzcGFuVG9wIC0gY3VycmVudExpbmVUb3ApID4gbGluZUhlaWdodFRvbGVyYW5jZSkge1xyXG4gICAgICAgICAgaWYgKGN1cnJlbnRMaW5lLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjdXJyZW50TGluZSA9IFtzcGFuXTtcclxuICAgICAgICAgIGN1cnJlbnRMaW5lVG9wID0gc3BhblRvcDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY3VycmVudExpbmUucHVzaChzcGFuKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjdXJyZW50TGluZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IG1lcmdlZFNwYW5zOiBIVE1MU3BhbkVsZW1lbnRbXSA9IFtdO1xyXG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcclxuICAgICAgICBpZiAobGluZS5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgbWVyZ2VkU3BhbnMucHVzaCguLi5saW5lKTtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbGluZVNwYW5zID0gWy4uLmxpbmVdLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgIHJldHVybiBzcGFuSW5mb3MuZ2V0KGEpIS5yZWN0LmxlZnQgLSBzcGFuSW5mb3MuZ2V0KGIpIS5yZWN0LmxlZnQ7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCBjdXJyZW50R3JvdXA6IEhUTUxTcGFuRWxlbWVudFtdID0gW2xpbmVTcGFuc1swXV07XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGluZVNwYW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCBwcmV2U3BhbiA9IGN1cnJlbnRHcm91cFtjdXJyZW50R3JvdXAubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICBjb25zdCBjdXJyZW50U3BhbiA9IGxpbmVTcGFuc1tpXTtcclxuICAgICAgICAgIGNvbnN0IHByZXZJbmZvID0gc3BhbkluZm9zLmdldChwcmV2U3BhbikhO1xyXG4gICAgICAgICAgY29uc3QgY3VycmVudEluZm8gPSBzcGFuSW5mb3MuZ2V0KGN1cnJlbnRTcGFuKSE7XHJcblxyXG4gICAgICAgICAgLy8gR2VvbWV0cmljIGNoZWNrc1xyXG4gICAgICAgICAgY29uc3QgYmFzZWxpbmVUb2xlcmFuY2UgPSBNYXRoLm1pbihwcmV2SW5mby5zdHlsZS5mb250U2l6ZSwgY3VycmVudEluZm8uc3R5bGUuZm9udFNpemUpICogdGhpcy5pbmxpbmVTcGFuQmFzZWxpbmVUb2w7XHJcbiAgICAgICAgICBjb25zdCBzYW1lQmFzZWxpbmUgPSBNYXRoLmFicyhwcmV2SW5mby5yZWN0LmJvdHRvbSAtIGN1cnJlbnRJbmZvLnJlY3QuYm90dG9tKSA8IGJhc2VsaW5lVG9sZXJhbmNlO1xyXG4gICAgICAgICAgY29uc3QgaG9yaXpvbnRhbEdhcCA9IGN1cnJlbnRJbmZvLnJlY3QubGVmdCAtIHByZXZJbmZvLnJlY3QucmlnaHQ7XHJcbiAgICAgICAgICBjb25zdCBrZXJuaW5nVG9sZXJhbmNlID0gTWF0aC5taW4ocHJldkluZm8uc3R5bGUuZm9udFNpemUsIGN1cnJlbnRJbmZvLnN0eWxlLmZvbnRTaXplKSAqIHRoaXMuaW5saW5lU3Bhbktlcm5Ub2w7XHJcbiAgICAgICAgICBjb25zdCBjbG9zZUhvcml6b250YWxseSA9IE1hdGguYWJzKGhvcml6b250YWxHYXApIDw9IGtlcm5pbmdUb2xlcmFuY2U7XHJcblxyXG4gICAgICAgICAgLy8gU3R5bGUgY2hlY2tcclxuICAgICAgICAgIGNvbnN0IHN0eWxlc0FyZUNvbXBhdGlibGUgPSB0aGlzLnN0eWxlc01hdGNoKHByZXZJbmZvLCBjdXJyZW50SW5mbywgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgaWYgKHNhbWVCYXNlbGluZSAmJiBjbG9zZUhvcml6b250YWxseSAmJiBzdHlsZXNBcmVDb21wYXRpYmxlKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cC5wdXNoKGN1cnJlbnRTcGFuKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1lcmdlZFNwYW5zLnB1c2goLi4udGhpcy5tZXJnZVNwYW5Hcm91cChjdXJyZW50R3JvdXAsIHNwYW5JbmZvcykpO1xyXG4gICAgICAgICAgICBjdXJyZW50R3JvdXAgPSBbY3VycmVudFNwYW5dO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbWVyZ2VkU3BhbnMucHVzaCguLi50aGlzLm1lcmdlU3Bhbkdyb3VwKGN1cnJlbnRHcm91cCwgc3BhbkluZm9zKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlc3VsdHMucHVzaChtZXJnZWRTcGFucyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfVxyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIEludGVybmFsIGhlbHBlcnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICBwcml2YXRlIGdldE51bWVyaWNGb250V2VpZ2h0KHdlaWdodDogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIGlmICh0eXBlb2Ygd2VpZ2h0ID09PSAnbnVtYmVyJykgcmV0dXJuIHdlaWdodDtcclxuICAgIGlmICh3ZWlnaHQgPT09ICdub3JtYWwnKSByZXR1cm4gNDAwO1xyXG4gICAgaWYgKHdlaWdodCA9PT0gJ2JvbGQnKSByZXR1cm4gNzAwO1xyXG4gICAgY29uc3QgbnVtZXJpY1dlaWdodCA9IHBhcnNlSW50KHdlaWdodCwgMTApO1xyXG4gICAgcmV0dXJuIGlzTmFOKG51bWVyaWNXZWlnaHQpID8gNDAwIDogbnVtZXJpY1dlaWdodDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgaXNDdXJzaXZlT3JCb2xkU3BhbihzcGFuSW5mbzogU3BhbkluZm8pOiBib29sZWFuIHtcclxuICAgIGNvbnN0IGlzQ3Vyc2l2ZSA9IHNwYW5JbmZvLnN0eWxlLmZvbnRTdHlsZSA9PT0gJ2l0YWxpYycgfHwgc3BhbkluZm8uc3R5bGUuZm9udFN0eWxlID09PSAnb2JsaXF1ZSc7XHJcbiAgICBjb25zdCBpc0JvbGQgPSBzcGFuSW5mby5zdHlsZS5mb250V2VpZ2h0ID09PSAnYm9sZCcgfHxcclxuICAgICAgICAgICAgICAgICAgICh0eXBlb2Ygc3BhbkluZm8uc3R5bGUuZm9udFdlaWdodCA9PT0gJ251bWJlcicgJiYgc3BhbkluZm8uc3R5bGUuZm9udFdlaWdodCA+PSA2MDApO1xyXG4gICAgcmV0dXJuIGlzQ3Vyc2l2ZSB8fCBpc0JvbGQ7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG1lcmdlU3Bhbkdyb3VwKFxyXG4gICAgc3BhbnM6IEhUTUxTcGFuRWxlbWVudFtdLFxyXG4gICAgc3BhbkluZm9zOiBNYXA8SFRNTFNwYW5FbGVtZW50LCBTcGFuSW5mbz5cclxuICApOiBIVE1MU3BhbkVsZW1lbnRbXSB7XHJcbiAgICByZXR1cm4gc3BhbnMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICBjb25zdCByZWN0QSA9IHNwYW5JbmZvcy5nZXQoYSkhLnJlY3Q7XHJcbiAgICAgIGNvbnN0IHJlY3RCID0gc3BhbkluZm9zLmdldChiKSEucmVjdDtcclxuICAgICAgcmV0dXJuIHJlY3RBLnRvcCAtIHJlY3RCLnRvcCB8fCByZWN0QS5sZWZ0IC0gcmVjdEIubGVmdDtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdHlsZXNNYXRjaChhOiBTcGFuSW5mbywgYjogU3BhbkluZm8sIG1hdGhBd2FyZSA9IHRydWUpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLnN0eWxlc01hdGNoU3R5bGUoYS5zdHlsZSwgYi5zdHlsZSwgbWF0aEF3YXJlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9WRVJIQVVMRUQ6IE1hdGNoZXMgc3R5bGVzLCBidXQgc3RyaWN0bHkgcmV0dXJucyBUUlVFIGlmIGZvcmNlTGluZWFyTWVyZ2UgaXMgb24uXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzdHlsZXNNYXRjaFN0eWxlKFxyXG4gICAgYTogU3BhbkluZm9bJ3N0eWxlJ10sXHJcbiAgICBiOiBTcGFuSW5mb1snc3R5bGUnXSxcclxuICAgIG1hdGhBd2FyZSA9IHRydWVcclxuICApOiBib29sZWFuIHtcclxuICAgIC8vIE9WRVJIQVVMOiBGb3JjZSBsaW5lYXIgbWVyZ2UgYnlwYXNzXHJcbiAgICBpZiAodGhpcy5mb3JjZUxpbmVhck1lcmdlKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICBpZiAobWF0aEF3YXJlICYmIChhLmlzTWF0aEVsZW1lbnQgfHwgYi5pc01hdGhFbGVtZW50KSkge1xyXG4gICAgICBpZiAoYS5mb250RmFtaWx5ICE9PSBiLmZvbnRGYW1pbHkpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKGEuZm9udFN0eWxlICE9PSBiLmZvbnRTdHlsZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoYS5mb250V2VpZ2h0ICE9PSBiLmZvbnRXZWlnaHQpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKE1hdGguYWJzKGEuZm9udFNpemUgLSBiLmZvbnRTaXplKSA+IDEuMCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBjb25zdCBkaXN0ID0gTWF0aC5oeXBvdChcclxuICAgICAgICBhLmNvbG9yUkdCWzBdIC0gYi5jb2xvclJHQlswXSxcclxuICAgICAgICBhLmNvbG9yUkdCWzFdIC0gYi5jb2xvclJHQlsxXSxcclxuICAgICAgICBhLmNvbG9yUkdCWzJdIC0gYi5jb2xvclJHQlsyXVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gZGlzdCA8IDEwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvcmUgcHJvcGVydGllcyBjaGVja1xyXG4gICAgaWYgKGEuZm9udEZhbWlseSAhPT0gYi5mb250RmFtaWx5KSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAoTWF0aC5hYnMoYS5mb250U2l6ZSAtIGIuZm9udFNpemUpID4gMS4wKSByZXR1cm4gZmFsc2U7XHJcbiAgICBjb25zdCBjb2xvckRpc3QgPSBNYXRoLmh5cG90KFxyXG4gICAgICBhLmNvbG9yUkdCWzBdIC0gYi5jb2xvclJHQlswXSxcclxuICAgICAgYS5jb2xvclJHQlsxXSAtIGIuY29sb3JSR0JbMV0sXHJcbiAgICAgIGEuY29sb3JSR0JbMl0gLSBiLmNvbG9yUkdCWzJdXHJcbiAgICApO1xyXG4gICAgaWYgKGNvbG9yRGlzdCA+PSAxMCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIC8vIEZsZXhpYmxlIHdlaWdodCBjaGVja1xyXG4gICAgY29uc3Qgd2VpZ2h0RGlmZiA9IE1hdGguYWJzKFxyXG4gICAgICB0aGlzLmdldE51bWVyaWNGb250V2VpZ2h0KGEuZm9udFdlaWdodCkgLVxyXG4gICAgICB0aGlzLmdldE51bWVyaWNGb250V2VpZ2h0KGIuZm9udFdlaWdodClcclxuICAgICk7XHJcbiAgICBpZiAod2VpZ2h0RGlmZiA+IHRoaXMuaW5saW5lU3Bhbk1heFdlaWdodERpZmYpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZsZXhpYmxlIHN0eWxlIGNoZWNrXHJcbiAgICBpZiAoIXRoaXMuaW5saW5lU3BhbkFsbG93TWl4ZWRTdHlsZSAmJiBhLmZvbnRTdHlsZSAhPT0gYi5mb250U3R5bGUpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXRQYXJhQmJveChzcGFuczogSFRNTFNwYW5FbGVtZW50W10sIGluZm9zOiBNYXA8SFRNTFNwYW5FbGVtZW50LCBTcGFuSW5mbz4pOiBSZWN0TGlrZSB7XHJcbiAgICBsZXQgbGVmdCA9IEluZmluaXR5LCB0b3AgPSBJbmZpbml0eSwgcmlnaHQgPSAtSW5maW5pdHksIGJvdHRvbSA9IC1JbmZpbml0eTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHMgb2Ygc3BhbnMpIHtcclxuICAgICAgY29uc3QgciA9IGluZm9zLmdldChzKSEucmVjdDtcclxuICAgICAgaWYgKHIubGVmdCA8IGxlZnQpIGxlZnQgPSByLmxlZnQ7XHJcbiAgICAgIGlmIChyLnRvcCA8IHRvcCkgdG9wID0gci50b3A7XHJcbiAgICAgIGlmIChyLnJpZ2h0ID4gcmlnaHQpIHJpZ2h0ID0gci5yaWdodDtcclxuICAgICAgaWYgKHIuYm90dG9tID4gYm90dG9tKSBib3R0b20gPSByLmJvdHRvbTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobGVmdCA9PT0gSW5maW5pdHkpIHJldHVybiB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xyXG4gICAgcmV0dXJuIHsgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tLCB3aWR0aDogcmlnaHQgLSBsZWZ0LCBoZWlnaHQ6IGJvdHRvbSAtIHRvcCB9O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzYW1lQ29sdW1uQnlTdHJpcHMoYTogUmVjdExpa2UsIGI6IFJlY3RMaWtlLCBzdHJpcHM6IFZlcnRpY2FsU3RyaXBbXSk6IGJvb2xlYW4ge1xyXG4gICAgLy8gT1ZFUkhBVUw6IElmIGZvcmNlZCwgd2UgaWdub3JlIGNvbHVtbiBib3VuZGFyaWVzXHJcbiAgICBpZiAodGhpcy5mb3JjZUxpbmVhck1lcmdlKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICBpZiAoIXN0cmlwcz8ubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IGhvcml6b250YWxPdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYS5yaWdodCwgYi5yaWdodCkgLSBNYXRoLm1heChhLmxlZnQsIGIubGVmdCkpO1xyXG4gICAgICBjb25zdCBtaW5XaWR0aCA9IE1hdGgubWluKGEud2lkdGgsIGIud2lkdGgpICogMC4zO1xyXG4gICAgICBjb25zdCBtYXhSZWFzb25hYmxlQ29sdW1uV2lkdGggPSBNYXRoLm1heChhLndpZHRoLCBiLndpZHRoKSAqIDM7XHJcbiAgICAgIGNvbnN0IGhvcml6b250YWxEaXN0YW5jZSA9IE1hdGguYWJzKChhLmxlZnQgKyBhLnJpZ2h0KS8yIC0gKGIubGVmdCArIGIucmlnaHQpLzIpO1xyXG4gICAgICByZXR1cm4gaG9yaXpvbnRhbE92ZXJsYXAgPiBtaW5XaWR0aCAmJiBob3Jpem9udGFsRGlzdGFuY2UgPCBtYXhSZWFzb25hYmxlQ29sdW1uV2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeVRvcCA9IE1hdGgubWluKGEudG9wLCBiLnRvcCk7XHJcbiAgICBjb25zdCB5Qm90ID0gTWF0aC5tYXgoYS5ib3R0b20sIGIuYm90dG9tKTtcclxuICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0geUJvdCAtIHlUb3A7XHJcblxyXG4gICAgaWYgKHRvdGFsSGVpZ2h0IDw9IDApIHJldHVybiB0cnVlO1xyXG5cclxuICAgIGNvbnN0IFtsZWZ0UGFyYSwgcmlnaHRQYXJhXSA9IGEubGVmdCA8IGIubGVmdCA/IFthLCBiXSA6IFtiLCBhXTtcclxuICAgIGNvbnN0IGhvcml6b250YWxPdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYS5yaWdodCwgYi5yaWdodCkgLSBNYXRoLm1heChhLmxlZnQsIGIubGVmdCkpO1xyXG4gICAgY29uc3QgbWluV2lkdGhPdmVybGFwID0gTWF0aC5taW4oYS53aWR0aCwgYi53aWR0aCkgKiAwLjM7XHJcbiAgICBpZiAoaG9yaXpvbnRhbE92ZXJsYXAgPiBtaW5XaWR0aE92ZXJsYXApIHJldHVybiB0cnVlO1xyXG5cclxuICAgIGNvbnN0IGdhcExlZnQgPSBsZWZ0UGFyYS5yaWdodDtcclxuICAgIGNvbnN0IGdhcFJpZ2h0ID0gcmlnaHRQYXJhLmxlZnQ7XHJcbiAgICBjb25zdCBnYXBXaWR0aCA9IGdhcFJpZ2h0IC0gZ2FwTGVmdDtcclxuXHJcbiAgICBpZiAoZ2FwV2lkdGggPD0gMCkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgbGV0IHRvdGFsU3RyaXBDb3ZlcmFnZSA9IDA7XHJcbiAgICBjb25zdCBtaW5TdHJpcENvdmVyYWdlID0gTWF0aC5tYXgoMywgZ2FwV2lkdGggKiAwLjEpO1xyXG4gICAgY29uc3QgbWluVmVydGljYWxBbGlnbm1lbnQgPSB0aGlzLm1pblN0cmlwT3ZlcmxhcEZyYWM7XHJcblxyXG4gICAgZm9yIChjb25zdCBzIG9mIHN0cmlwcykge1xyXG4gICAgICBpZiAocy5jb25maWRlbmNlIDwgdGhpcy5taW5TdHJpcENvbmZpZGVuY2VTcGxpdCkgY29udGludWU7XHJcbiAgICAgIGlmIChzLnJpZ2h0IC0gcy5sZWZ0IDwgdGhpcy5taW5TdHJpcFdpZHRoUHgpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgY29uc3Qgc3RyaXBIZWlnaHQgPSBzLmJvdHRvbSAtIHMudG9wO1xyXG4gICAgICBjb25zdCB5T3ZlcmxhcCA9IE1hdGgubWluKHlCb3QsIHMuYm90dG9tKSAtIE1hdGgubWF4KHlUb3AsIHMudG9wKTtcclxuICAgICAgY29uc3QgdmVydGljYWxBbGlnbm1lbnQgPSB5T3ZlcmxhcCAvIHN0cmlwSGVpZ2h0O1xyXG4gICAgICBpZiAodmVydGljYWxBbGlnbm1lbnQgPCBtaW5WZXJ0aWNhbEFsaWdubWVudCkgY29udGludWU7XHJcblxyXG4gICAgICBjb25zdCBzdHJpcEluR2FwID0gTWF0aC5tYXgoMCxcclxuICAgICAgICBNYXRoLm1pbihzLnJpZ2h0LCBnYXBSaWdodCkgLSBNYXRoLm1heChzLmxlZnQsIGdhcExlZnQpXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAoc3RyaXBJbkdhcCA+PSBtaW5TdHJpcENvdmVyYWdlKSB7XHJcbiAgICAgICAgdG90YWxTdHJpcENvdmVyYWdlICs9IHN0cmlwSW5HYXA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb3ZlcmFnZVJhdGlvID0gdG90YWxTdHJpcENvdmVyYWdlIC8gZ2FwV2lkdGg7XHJcbiAgICByZXR1cm4gY292ZXJhZ2VSYXRpbyA8IHRoaXMuc2FtZUNvbHVtbkNvdmVyYWdlUmF0aW87XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGhhc0hvcml6b250YWxCYW5kQmV0d2VlbihhOiBSZWN0TGlrZSwgYjogUmVjdExpa2UsIGJhbmRzOiBIb3Jpem9udGFsQmFuZFtdID0gW10pOiBib29sZWFuIHtcclxuICAgIC8vIE9WRVJIQVVMOiBJZiBmb3JjZWQsIGlnbm9yZSBiYW5kc1xyXG4gICAgaWYgKHRoaXMuZm9yY2VMaW5lYXJNZXJnZSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIGlmICghYmFuZHM/Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgY29uc3QgdG9wID0gTWF0aC5taW4oYS5ib3R0b20sIGIuYm90dG9tKTtcclxuICAgIGNvbnN0IGJvdHRvbSA9IE1hdGgubWF4KGEudG9wLCBiLnRvcCk7XHJcblxyXG4gICAgZm9yIChjb25zdCBiYW5kIG9mIGJhbmRzKSB7XHJcbiAgICAgIGlmIChiYW5kLmNvbmZpZGVuY2UgPCAwLjYpIGNvbnRpbnVlO1xyXG4gICAgICBjb25zdCB3aXRoaW4gPSBiYW5kLnkgPiB0b3AgJiYgKGJhbmQueSArIGJhbmQuaGVpZ2h0KSA8IGJvdHRvbTtcclxuICAgICAgaWYgKHdpdGhpbikgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZWN0Q29udGFpbnMoYTogUmVjdExpa2UsIGI6IFJlY3RMaWtlLCB0b2wgPSAxKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gYS5sZWZ0IC0gdG9sIDw9IGIubGVmdCAmJiBhLnJpZ2h0ICsgdG9sID49IGIucmlnaHQgJiYgYS50b3AgLSB0b2wgPD0gYi50b3AgJiYgYS5ib3R0b20gKyB0b2wgPj0gYi5ib3R0b207XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlY3RJbnRlcnNlY3Rpb24oYTogUmVjdExpa2UsIGI6IFJlY3RMaWtlKTogUmVjdExpa2UgfCBudWxsIHtcclxuICAgIGNvbnN0IGxlZnQgPSBNYXRoLm1heChhLmxlZnQsIGIubGVmdCk7XHJcbiAgICBjb25zdCB0b3AgPSBNYXRoLm1heChhLnRvcCwgYi50b3ApO1xyXG4gICAgY29uc3QgcmlnaHQgPSBNYXRoLm1pbihhLnJpZ2h0LCBiLnJpZ2h0KTtcclxuICAgIGNvbnN0IGJvdHRvbSA9IE1hdGgubWluKGEuYm90dG9tLCBiLmJvdHRvbSk7XHJcblxyXG4gICAgaWYgKHJpZ2h0IDw9IGxlZnQgfHwgYm90dG9tIDw9IHRvcCkgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4geyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20sIHdpZHRoOiByaWdodCAtIGxlZnQsIGhlaWdodDogYm90dG9tIC0gdG9wIH07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFyZWEocjogUmVjdExpa2UpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIHIud2lkdGgpICogTWF0aC5tYXgoMCwgci5oZWlnaHQpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBpc01hdGhNZXJnZUNhbmRpZGF0ZShcclxuICAgIGE6IHsgYmJveDogUmVjdExpa2U7IHN0eWxlOiBTcGFuSW5mb1snc3R5bGUnXTsgaXNNYXRoPzogYm9vbGVhbjsgdGV4dD86IHN0cmluZyB9LFxyXG4gICAgYjogeyBiYm94OiBSZWN0TGlrZTsgc3R5bGU6IFNwYW5JbmZvWydzdHlsZSddOyBpc01hdGg/OiBib29sZWFuOyB0ZXh0Pzogc3RyaW5nIH0sXHJcbiAgICBzdHJpcHM6IFZlcnRpY2FsU3RyaXBbXVxyXG4gICk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgZm9udFNpemUgPSBNYXRoLm1heChhLnN0eWxlLmZvbnRTaXplLCBiLnN0eWxlLmZvbnRTaXplKSB8fCAxMjtcclxuICAgIGNvbnN0IHZlcnRpY2FsUHJveGltaXR5ID0gTWF0aC5hYnMoYS5iYm94LnRvcCAtIGIuYmJveC50b3ApIDwgZm9udFNpemUgKiB0aGlzLm1hdGhNZXJnZUJhc2VsaW5lVG9sO1xyXG4gICAgY29uc3QgaG9yaXpvbnRhbFByb3hpbWl0eSA9IE1hdGguYWJzKGEuYmJveC5sZWZ0IC0gYi5iYm94LmxlZnQpIDwgZm9udFNpemUgKiB0aGlzLm1hdGhNZXJnZUhvcml6VG9sO1xyXG5cclxuICAgIGlmICghdGhpcy5zYW1lQ29sdW1uQnlTdHJpcHMoYS5iYm94LCBiLmJib3gsIHN0cmlwcykpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICBjb25zdCBvcFJlID0gL1s9K1xcLVx1MjIxMlx1MDBEN1x1MDBGN1x1MjIxQVx1MjIyQlx1MjIxMVx1MjI2MFx1MjI2NFx1MjI2NVx1MjI0OFx1MDBCMVx1MjIxRV0vO1xyXG4gICAgY29uc3QgYUlzT3AgPSAhIShhLnRleHQgJiYgb3BSZS50ZXN0KGEudGV4dCkpO1xyXG4gICAgY29uc3QgYklzT3AgPSAhIShiLnRleHQgJiYgb3BSZS50ZXN0KGIudGV4dCkpO1xyXG5cclxuICAgIGlmIChhSXNPcCB8fCBiSXNPcCkgcmV0dXJuIHZlcnRpY2FsUHJveGltaXR5ICYmIGhvcml6b250YWxQcm94aW1pdHk7XHJcblxyXG4gICAgY29uc3QgY2VudGVyQSA9IChhLmJib3gubGVmdCArIGEuYmJveC5yaWdodCkgLyAyO1xyXG4gICAgY29uc3QgY2VudGVyQiA9IChiLmJib3gubGVmdCArIGIuYmJveC5yaWdodCkgLyAyO1xyXG4gICAgcmV0dXJuIHZlcnRpY2FsUHJveGltaXR5ICYmIE1hdGguYWJzKGNlbnRlckEgLSBjZW50ZXJCKSA8IGZvbnRTaXplICogdGhpcy5tYXRoTWVyZ2VDZW50ZXJUb2w7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHNwbGl0UGFyYWdyYXBoQnlTdHJpcHMoXHJcbiAgICBwYXJhZ3JhcGg6IEhUTUxTcGFuRWxlbWVudFtdLFxyXG4gICAgaW5mb3M6IE1hcDxIVE1MU3BhbkVsZW1lbnQsIFNwYW5JbmZvPixcclxuICAgIHN0cmlwczogVmVydGljYWxTdHJpcFtdLFxyXG4gICAgbGluZUhlaWdodDogbnVtYmVyID0gMFxyXG4gICk6IEhUTUxTcGFuRWxlbWVudFtdW10ge1xyXG4gICAgaWYgKCFwYXJhZ3JhcGgubGVuZ3RoIHx8ICFzdHJpcHMubGVuZ3RoKSByZXR1cm4gW3BhcmFncmFwaF07XHJcblxyXG4gICAgY29uc3QgcGFyYUJib3ggPSB0aGlzLmdldFBhcmFCYm94KHBhcmFncmFwaCwgaW5mb3MpO1xyXG4gICAgY29uc3Qgc29ydGVkID0gWy4uLnBhcmFncmFwaF0uc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICBjb25zdCByYSA9IGluZm9zLmdldChhKSEucmVjdDtcclxuICAgICAgY29uc3QgcmIgPSBpbmZvcy5nZXQoYikhLnJlY3Q7XHJcbiAgICAgIHJldHVybiByYS50b3AgLSByYi50b3AgfHwgcmEubGVmdCAtIHJiLmxlZnQ7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBjb2x1bW5Cb3VuZGFyaWVzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgbGV0IGN1cnJlbnRMaW5lVG9wID0gLUluZmluaXR5O1xyXG4gICAgbGV0IGN1cnJlbnRMaW5lU3BhbnM6IHsgc3BhbjogSFRNTFNwYW5FbGVtZW50OyByZWN0OiBSZWN0TGlrZSB9W10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHNwYW4gb2Ygc29ydGVkKSB7XHJcbiAgICAgIGNvbnN0IHJlY3QgPSBpbmZvcy5nZXQoc3BhbikhLnJlY3Q7XHJcblxyXG4gICAgICBpZiAoY3VycmVudExpbmVUb3AgPT09IC1JbmZpbml0eSB8fCBNYXRoLmFicyhyZWN0LnRvcCAtIGN1cnJlbnRMaW5lVG9wKSA+IGxpbmVIZWlnaHQgKiB0aGlzLnNwbGl0TGluZUhlaWdodFRvbCkge1xyXG4gICAgICAgIGlmIChjdXJyZW50TGluZVNwYW5zLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgIHRoaXMucHJvY2Vzc0xpbmVGb3JDb2x1bW5Cb3VuZGFyaWVzKGN1cnJlbnRMaW5lU3BhbnMsIGNvbHVtbkJvdW5kYXJpZXMsIGxpbmVIZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50TGluZVRvcCA9IHJlY3QudG9wO1xyXG4gICAgICAgIGN1cnJlbnRMaW5lU3BhbnMgPSBbeyBzcGFuLCByZWN0IH1dO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN1cnJlbnRMaW5lU3BhbnMucHVzaCh7IHNwYW4sIHJlY3QgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoY3VycmVudExpbmVTcGFucy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIHRoaXMucHJvY2Vzc0xpbmVGb3JDb2x1bW5Cb3VuZGFyaWVzKGN1cnJlbnRMaW5lU3BhbnMsIGNvbHVtbkJvdW5kYXJpZXMsIGxpbmVIZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb2x1bW5Cb3VuZGFyaWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtwYXJhZ3JhcGhdO1xyXG5cclxuICAgIGNvbHVtbkJvdW5kYXJpZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG4gICAgY29uc3QgdW5pcXVlQm91bmRhcmllcyA9IFtjb2x1bW5Cb3VuZGFyaWVzWzBdXTtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY29sdW1uQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoY29sdW1uQm91bmRhcmllc1tpXSAtIHVuaXF1ZUJvdW5kYXJpZXNbdW5pcXVlQm91bmRhcmllcy5sZW5ndGggLSAxXSA+IGxpbmVIZWlnaHQgKiB0aGlzLnNwbGl0Qm91bmRhcnlEZWR1cFRvbCkge1xyXG4gICAgICAgIHVuaXF1ZUJvdW5kYXJpZXMucHVzaChjb2x1bW5Cb3VuZGFyaWVzW2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGJvdW5kYXJpZXMgPSBbcGFyYUJib3gubGVmdCwgLi4udW5pcXVlQm91bmRhcmllcywgcGFyYUJib3gucmlnaHRdO1xyXG4gICAgY29uc3QgcmVnaW9uczogQXJyYXk8eyBsZWZ0OiBudW1iZXI7IHJpZ2h0OiBudW1iZXIgfT4gPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm91bmRhcmllcy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgcmVnaW9ucy5wdXNoKHsgbGVmdDogYm91bmRhcmllc1tpXSwgcmlnaHQ6IGJvdW5kYXJpZXNbaSArIDFdIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGJ1Y2tldHM6IEhUTUxTcGFuRWxlbWVudFtdW10gPSByZWdpb25zLm1hcCgoKSA9PiBbXSk7XHJcbiAgICBmb3IgKGNvbnN0IHNwYW4gb2Ygc29ydGVkKSB7XHJcbiAgICAgIGNvbnN0IHJlY3QgPSBpbmZvcy5nZXQoc3BhbikhLnJlY3Q7XHJcbiAgICAgIGNvbnN0IGN4ID0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMjtcclxuICAgICAgbGV0IHJlZ2lvbkluZGV4ID0gcmVnaW9ucy5maW5kSW5kZXgociA9PiBjeCA+PSByLmxlZnQgJiYgY3ggPCByLnJpZ2h0KTtcclxuICAgICAgaWYgKHJlZ2lvbkluZGV4ID09PSAtMSkge1xyXG4gICAgICAgIHJlZ2lvbkluZGV4ID0gY3ggPCByZWdpb25zWzBdLmxlZnQgPyAwIDogcmVnaW9ucy5sZW5ndGggLSAxO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZWdpb25JbmRleCA+PSAwICYmIHJlZ2lvbkluZGV4IDwgcmVnaW9ucy5sZW5ndGgpIHtcclxuICAgICAgICBidWNrZXRzW3JlZ2lvbkluZGV4XS5wdXNoKHNwYW4pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZ3JvdXBzOiBIVE1MU3BhbkVsZW1lbnRbXVtdID0gW107XHJcbiAgICBmb3IgKGNvbnN0IGJ1Y2tldCBvZiBidWNrZXRzKSB7XHJcbiAgICAgIGlmIChidWNrZXQubGVuZ3RoID09PSAwKSBjb250aW51ZTtcclxuICAgICAgYnVja2V0LnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICBjb25zdCByYSA9IGluZm9zLmdldChhKSEucmVjdDtcclxuICAgICAgICBjb25zdCByYiA9IGluZm9zLmdldChiKSEucmVjdDtcclxuICAgICAgICByZXR1cm4gcmEudG9wIC0gcmIudG9wIHx8IHJhLmxlZnQgLSByYi5sZWZ0O1xyXG4gICAgICB9KTtcclxuICAgICAgZ3JvdXBzLnB1c2goYnVja2V0KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZ3JvdXBzLmxlbmd0aCA+IDEgPyBncm91cHMgOiBbcGFyYWdyYXBoXTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcHJvY2Vzc0xpbmVGb3JDb2x1bW5Cb3VuZGFyaWVzKFxyXG4gICAgbGluZVNwYW5zOiB7IHNwYW46IEhUTUxTcGFuRWxlbWVudDsgcmVjdDogUmVjdExpa2UgfVtdLFxyXG4gICAgY29sdW1uQm91bmRhcmllczogbnVtYmVyW10sXHJcbiAgICBsaW5lSGVpZ2h0OiBudW1iZXJcclxuICApIHtcclxuICAgIGxpbmVTcGFucy5zb3J0KChhLCBiKSA9PiBhLnJlY3QubGVmdCAtIGIucmVjdC5sZWZ0KTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVTcGFucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBwcmV2ID0gbGluZVNwYW5zW2kgLSAxXS5yZWN0O1xyXG4gICAgICBjb25zdCBjdXJyID0gbGluZVNwYW5zW2ldLnJlY3Q7XHJcbiAgICAgIGNvbnN0IGdhcCA9IGN1cnIubGVmdCAtIHByZXYucmlnaHQ7XHJcbiAgICAgIGNvbnN0IGZvbnRTaXplID0gTWF0aC5taW4ocHJldi5oZWlnaHQsIGN1cnIuaGVpZ2h0KSAqIDAuODtcclxuICAgICAgY29uc3QgbWF4SW50ZXJXb3JkR2FwID0gZm9udFNpemUgKiB0aGlzLnNwbGl0SW50ZXJXb3JkR2FwVG9sO1xyXG4gICAgICBjb25zdCBtaW5Db2x1bW5HYXAgPSBmb250U2l6ZSAqIHRoaXMuc3BsaXRDb2x1bW5HYXBUb2w7XHJcblxyXG4gICAgICBpZiAoZ2FwID4gbWluQ29sdW1uR2FwICYmIGdhcCA+IG1heEludGVyV29yZEdhcCkge1xyXG4gICAgICAgIGNvbnN0IGdhcENlbnRlciA9IChwcmV2LnJpZ2h0ICsgY3Vyci5sZWZ0KSAvIDI7XHJcbiAgICAgICAgY29sdW1uQm91bmRhcmllcy5wdXNoKGdhcENlbnRlcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcHJpdmF0ZSBmaWx0ZXJTdHJpcHMoc3RyaXBzOiBWZXJ0aWNhbFN0cmlwW10sIHZpZXdwb3J0V2lkdGg6IG51bWJlcik6IFZlcnRpY2FsU3RyaXBbXSB7XHJcbiAgICBpZiAoIXN0cmlwcz8ubGVuZ3RoKSByZXR1cm4gW107XHJcbiAgICByZXR1cm4gc3RyaXBzLmZpbHRlcihzID0+IHtcclxuICAgICAgY29uc3Qgd2lkdGggPSBzLnJpZ2h0IC0gcy5sZWZ0O1xyXG4gICAgICBjb25zdCBoZWlnaHQgPSBzLmJvdHRvbSAtIHMudG9wO1xyXG4gICAgICBpZiAod2lkdGggPCB2aWV3cG9ydFdpZHRoICogMC4wMDMpIHJldHVybiBmYWxzZTtcclxuICAgICAgY29uc3QgbWluSGVpZ2h0ID0gTWF0aC5tYXgoMTIsIGhlaWdodCAqIDAuNyk7XHJcbiAgICAgIGlmIChoZWlnaHQgPCBtaW5IZWlnaHQpIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHMuY29uZmlkZW5jZSA+PSB0aGlzLm1pblN0cmlwQ29uZmlkZW5jZVNwbGl0ICYmXHJcbiAgICAgICAgICAgICB3aWR0aCA+PSB0aGlzLm1pblN0cmlwV2lkdGhQeCAmJlxyXG4gICAgICAgICAgICAgaGVpZ2h0ID4gMDtcclxuICAgIH0pO1xyXG4gIH1cclxufSIsICIvLyBTbmFwc2hvdC50c1xyXG5leHBvcnQgaW50ZXJmYWNlIE5vcm1hbGl6ZWRTdHlsZSB7XHJcbiAgZm9udEZhbWlseTogc3RyaW5nO1xyXG4gIGZvbnRTaXplOiBudW1iZXI7ICAgIC8vIG5vcm1hbGl6ZWQgYnkgRFBSXHJcbiAgZm9udFdlaWdodDogbnVtYmVyOyAgLy8gbm9ybWFsaXplZCBudW1lcmljXHJcbiAgZm9udFN0eWxlOiBzdHJpbmc7XHJcbiAgY29sb3I6IHN0cmluZzsgICAgICAgLy8gb3JpZ2luYWwgQ1NTIGNvbG9yIHN0cmluZ1xyXG4gIGNvbG9yUkdCOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XHJcbiAgc3R5bGVTaWc6IHN0cmluZzsgICAgLy8gXCJmYW1pbHl8Zm9udFNpemVSb3VuZGVkfHdlaWdodHxzdHlsZXxyLGcsYlwiXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3BhbkluZm8ge1xyXG4gIHNwYW46IEhUTUxTcGFuRWxlbWVudDtcclxuICByZWN0OiBET01SZWN0OyAgICAgICAvLyBub3JtYWxpemVkIGJ5IERQUlxyXG4gIHN0eWxlOiBOb3JtYWxpemVkU3R5bGU7XHJcbiAgaXNNYXRoRWxlbWVudDogYm9vbGVhbjtcclxuICBtYXRoQ29udGV4dDogJ2VxdWF0aW9uJyB8ICdpbmxpbmUnIHwgJ25vbmUnO1xyXG4gIHRleHQ6IHN0cmluZztcclxufVxyXG5cclxuY29uc3QgTUFUSF9GT05UX1JFID0gL21hdGh8Y2FtYnJpYXxzdGl4fGFzYW5hfGV1bGVyfGxhdGluIG1vZGVybi9pO1xyXG4vLyBFeHRlbmRlZCBtYXRoL3N5bWJvbCByYW5nZXNcclxuLy8gR3JlZWs6IFxcdTAzNzAtXFx1MDNGRiwgU3VwZXJzY3JpcHRzL1N1YnNjcmlwdHM6IFxcdTIwNzAtXFx1MjA5RiwgYXJyb3dzL29wZXJhdG9ycyAmIG1pc2MgY29tbW9uIG1hdGhcclxuY29uc3QgTUFUSF9DSEFSX1JFID0gL1s9K1xcLVx1MjIxMlx1MDBEN1x1MDBGN1x1MjIxQVx1MjIyQlx1MjIxMVx1MjIwRlx1MjIxRVx1MDM5NFx1MDNCMVx1MDNCMlx1MDNCM1x1MDNCNFx1MDNCOFx1MDNCQlx1MDNCQ1x1MDNDMVx1MDNDM1x1MDNDNFx1MDNDNlx1MDNDOFx1MDNDOVx1MDBCMVx1MjI2NFx1MjI2NVx1MjI2MFx1MjI0OFx1MjI2MSVcdTIwMzBcdTIyMDBcdTIyMDNcdTIyMDhcdTIyMEJcdTIyMjlcdTIyMkFcdTIyODJcdTIyODNcdTIyODZcdTIyODdcdTIyOTVcdTIyOTdcdTIyQTVcdTIxRDJcdTIxRDRcdTIxOTJcdTIxOTBcdTIxOTFcdTIxOTNcdTIxOTRcdTIyMzRcdTIyNDVcdTIyQTJcdTIyQThdfFtcXHUwMzcwLVxcdTAzRkZcXHUyMDcwLVxcdTIwOUZdLztcclxuXHJcbmZ1bmN0aW9uIHBhcnNlQ29sb3JUb1JHQihjb2xvcjogc3RyaW5nKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcclxuICBpZiAoIWNvbG9yKSByZXR1cm4gWzAsIDAsIDBdO1xyXG4gIGNvbnN0IG0gPSBjb2xvci5tYXRjaCgvcmdiYT9cXChcXHMqKFxcZCspWyxcXHNdKyhcXGQrKVssXFxzXSsoXFxkKykvaSk7XHJcbiAgaWYgKG0pIHJldHVybiBbcGFyc2VJbnQobVsxXSksIHBhcnNlSW50KG1bMl0pLCBwYXJzZUludChtWzNdKV07XHJcbiAgY29uc3QgaGV4ID0gY29sb3IudHJpbSgpLnRvTG93ZXJDYXNlKCk7XHJcbiAgaWYgKC9eIyhbMC05YS1mXXszfSl7MSwyfSQvaS50ZXN0KGhleCkpIHtcclxuICAgIGlmIChoZXgubGVuZ3RoID09PSA0KSB7XHJcbiAgICAgIHJldHVybiBbXHJcbiAgICAgICAgcGFyc2VJbnQoaGV4WzFdICsgaGV4WzFdLCAxNiksXHJcbiAgICAgICAgcGFyc2VJbnQoaGV4WzJdICsgaGV4WzJdLCAxNiksXHJcbiAgICAgICAgcGFyc2VJbnQoaGV4WzNdICsgaGV4WzNdLCAxNilcclxuICAgICAgXTtcclxuICAgIH1cclxuICAgIHJldHVybiBbXHJcbiAgICAgIHBhcnNlSW50KGhleC5zbGljZSgxLCAzKSwgMTYpLFxyXG4gICAgICBwYXJzZUludChoZXguc2xpY2UoMywgNSksIDE2KSxcclxuICAgICAgcGFyc2VJbnQoaGV4LnNsaWNlKDUsIDcpLCAxNilcclxuICAgIF07XHJcbiAgfVxyXG4gIHJldHVybiBbMCwgMCwgMF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVdlaWdodCh3ZWlnaHQ6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgY29uc3QgbnVtID0gcGFyc2VJbnQod2VpZ2h0IGFzIGFueSwgMTApO1xyXG4gIGlmICghaXNOYU4obnVtKSkgcmV0dXJuIG51bTtcclxuICBjb25zdCB3ID0gKHdlaWdodCB8fCAnJykudG9Mb3dlckNhc2UoKTtcclxuICBpZiAodyA9PT0gJ2JvbGQnKSByZXR1cm4gNzAwO1xyXG4gIGlmICh3ID09PSAnbm9ybWFsJykgcmV0dXJuIDQwMDtcclxuICByZXR1cm4gNDAwO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNNYXRoQ29udGVudEZvbnQoZm9udEZhbWlseTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIE1BVEhfRk9OVF9SRS50ZXN0KGZvbnRGYW1pbHkgfHwgJycpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNNYXRoRWxlbWVudFRleHQodGV4dDogc3RyaW5nLCBmb250RmFtaWx5OiBzdHJpbmcpOiBib29sZWFuIHtcclxuICBpZiAoIXRleHQpIHJldHVybiBmYWxzZTtcclxuICBpZiAoaXNNYXRoQ29udGVudEZvbnQoZm9udEZhbWlseSkpIHJldHVybiB0cnVlO1xyXG4gIHJldHVybiBNQVRIX0NIQVJfUkUudGVzdCh0ZXh0KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZU1hdGhDb250ZXh0KHRleHQ6IHN0cmluZywgZm9udEZhbWlseTogc3RyaW5nKTogJ2VxdWF0aW9uJyB8ICdpbmxpbmUnIHwgJ25vbmUnIHtcclxuICBpZiAoaXNNYXRoRWxlbWVudFRleHQodGV4dCwgZm9udEZhbWlseSkpIHtcclxuICAgIHJldHVybiAodGV4dC5pbmNsdWRlcygnPScpIHx8IHRleHQuaW5jbHVkZXMoJ1x1MjIxMScpKSA/ICdlcXVhdGlvbicgOiAnaW5saW5lJztcclxuICB9XHJcbiAgcmV0dXJuICdub25lJztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU25hcHNob3Qoc3BhbnM6IEhUTUxTcGFuRWxlbWVudFtdKTogTWFwPEhUTUxTcGFuRWxlbWVudCwgU3BhbkluZm8+IHtcclxuICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xyXG4gIGNvbnN0IG1hcCA9IG5ldyBNYXA8SFRNTFNwYW5FbGVtZW50LCBTcGFuSW5mbz4oKTtcclxuXHJcbiAgZm9yIChjb25zdCBzIG9mIHNwYW5zKSB7XHJcbiAgICBjb25zdCByZWN0UmF3ID0gcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGNvbnN0IHJlY3QgPSBuZXcgRE9NUmVjdChcclxuICAgICAgcmVjdFJhdy5sZWZ0IC8gZHByLFxyXG4gICAgICByZWN0UmF3LnRvcCAvIGRwcixcclxuICAgICAgcmVjdFJhdy53aWR0aCAvIGRwcixcclxuICAgICAgcmVjdFJhdy5oZWlnaHQgLyBkcHJcclxuICAgICk7XHJcbiAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHMpO1xyXG4gICAgY29uc3QgZm9udFNpemUgPSAocGFyc2VGbG9hdChzdHlsZS5mb250U2l6ZSkgfHwgMTIpIC8gZHByO1xyXG4gICAgY29uc3QgZm9udFdlaWdodCA9IG5vcm1hbGl6ZVdlaWdodChzdHlsZS5mb250V2VpZ2h0KTtcclxuICAgIGNvbnN0IGNvbG9yUkdCID0gcGFyc2VDb2xvclRvUkdCKHN0eWxlLmNvbG9yKTtcclxuICAgIGNvbnN0IHRleHQgPSBzLnRleHRDb250ZW50IHx8ICcnO1xyXG4gICAgY29uc3QgaXNNYXRoID0gaXNNYXRoRWxlbWVudFRleHQodGV4dCwgc3R5bGUuZm9udEZhbWlseSk7XHJcbiAgICBjb25zdCBtYXRoQ29udGV4dCA9IGRldGVybWluZU1hdGhDb250ZXh0KHRleHQsIHN0eWxlLmZvbnRGYW1pbHkpO1xyXG4gICAgY29uc3QgZm9udFNpemVSb3VuZGVkID0gTWF0aC5yb3VuZChmb250U2l6ZSAqIDIpIC8gMjsgLy8gMC41cHggcm91bmRpbmdcclxuICAgIGNvbnN0IHN0eWxlU2lnID0gW1xyXG4gICAgICBzdHlsZS5mb250RmFtaWx5LFxyXG4gICAgICBmb250U2l6ZVJvdW5kZWQudG9GaXhlZCgxKSxcclxuICAgICAgZm9udFdlaWdodCxcclxuICAgICAgc3R5bGUuZm9udFN0eWxlLFxyXG4gICAgICBgJHtjb2xvclJHQlswXX0sJHtjb2xvclJHQlsxXX0sJHtjb2xvclJHQlsyXX1gXHJcbiAgICBdLmpvaW4oJ3wnKTtcclxuXHJcbiAgICBjb25zdCBub3JtU3R5bGU6IE5vcm1hbGl6ZWRTdHlsZSA9IHtcclxuICAgICAgZm9udEZhbWlseTogc3R5bGUuZm9udEZhbWlseSxcclxuICAgICAgZm9udFNpemUsXHJcbiAgICAgIGZvbnRXZWlnaHQsXHJcbiAgICAgIGZvbnRTdHlsZTogc3R5bGUuZm9udFN0eWxlLFxyXG4gICAgICBjb2xvcjogc3R5bGUuY29sb3IsXHJcbiAgICAgIGNvbG9yUkdCLFxyXG4gICAgICBzdHlsZVNpZ1xyXG4gICAgfTtcclxuXHJcbiAgICBtYXAuc2V0KHMsIHtcclxuICAgICAgc3BhbjogcyxcclxuICAgICAgcmVjdCxcclxuICAgICAgc3R5bGU6IG5vcm1TdHlsZSxcclxuICAgICAgaXNNYXRoRWxlbWVudDogaXNNYXRoLFxyXG4gICAgICBtYXRoQ29udGV4dCxcclxuICAgICAgdGV4dFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBtYXA7XHJcbn0iLCAiLy8gbGF5b3V0LW1vZGFsLnRzXHJcblxyXG4vLyBDb25maWd1cmF0aW9uIHNldHRpbmdzIGZvciBMYXlvdXREZXRlY3RvciBtYWdpY2FsIG51bWJlcnMgYW5kIGNvbnN0YW50cy5cclxuZXhwb3J0IGludGVyZmFjZSBMYXlvdXRTZXR0aW5ncyB7XHJcbiAgLyoqIE11bHRpcGxpZXIgZm9yIGxpbmUgaGVpZ2h0IGNhbGN1bGF0aW9ucyAoZGVmYXVsdDogMS42KSAqL1xyXG4gIGxpbmVIZWlnaHRNdWx0aXBsaWVyOiBudW1iZXI7XHJcbiAgLyoqIE1pbmltdW0gY29uZmlkZW5jZSBmb3IgdmVydGljYWwgc3RyaXBzIChkZWZhdWx0OiAwLjcpICovXHJcbiAgbWluU3RyaXBDb25maWRlbmNlOiBudW1iZXI7XHJcbiAgLyoqIE1pbmltdW0gd2lkdGggaW4gcGl4ZWxzIGZvciB2ZXJ0aWNhbCBzdHJpcHMgKGRlZmF1bHQ6IDQpICovXHJcbiAgbWluU3RyaXBXaWR0aFB4OiBudW1iZXI7XHJcbiAgLyoqIEVuYWJsZSBkZWJ1ZyB2YWxpZGF0aW9uIGxvZ2dpbmcgKGRlZmF1bHQ6IGZhbHNlKSAqL1xyXG4gIGRlYnVnVmFsaWRhdGlvbjogYm9vbGVhbjtcclxuICAvKiogTWF4aW11bSBpdGVyYXRpb25zIGZvciBwYXJhZ3JhcGggbWVyZ2luZyAoZGVmYXVsdDogMTApICovXHJcbiAgbWF4SXRlck1lcmdlczogbnVtYmVyO1xyXG4gIC8qKiBNaW5pbXVtIGNvbmZpZGVuY2UgZm9yIGhvcml6b250YWwgYmFuZHMgKGRlZmF1bHQ6IDAuNikgKi9cclxuICBtaW5CYW5kQ29uZmlkZW5jZTogbnVtYmVyO1xyXG4gIC8qKiBUaHJlc2hvbGQgbXVsdGlwbGllciBmb3IgYmFuZCB0b3AvYm90dG9tIGluZmVyZW5jZSByZWxhdGl2ZSB0byBsaW5lIGhlaWdodCAoZGVmYXVsdDogMC43NSkgKi9cclxuICBiYW5kVG9wQm90dG9tVGhyZXNob2xkTXVsdGlwbGllcjogbnVtYmVyO1xyXG4gIC8qKiBDb25maWRlbmNlIGZvciBpbmZlcnJlZCBob3Jpem9udGFsIGJhbmRzIGZyb20gc3RyaXBzIChkZWZhdWx0OiAwLjgpICovXHJcbiAgaW5mZXJyZWRCYW5kQ29uZmlkZW5jZTogbnVtYmVyO1xyXG4gIC8qKiBNaW5pbXVtIHBpeGVsIGdhcCBmb3IgbWVyZ2luZyBhZGphY2VudCBiYW5kcyAoZGVmYXVsdDogMikgKi9cclxuICBiYW5kTWVyZ2VHYXBQeDogbnVtYmVyO1xyXG4gIC8qKiBMaW5lIGhlaWdodCBtdWx0aXBsaWVyIGZvciBkeW5hbWljIGJhbmQgbWVyZ2UgZ2FwIChkZWZhdWx0OiAwLjIpICovXHJcbiAgYmFuZE1lcmdlR2FwTGluZUhlaWdodE11bHRpcGxpZXI6IG51bWJlcjtcclxuICAvKiogTWF4aW11bSBnYXAgZnJhY3Rpb24gb2YgcGFnZSBoZWlnaHQgZm9yIGxpbmUgaGVpZ2h0IGVzdGltYXRpb24gKGRlZmF1bHQ6IDAuNSkgKi9cclxuICBtYXhHYXBGcmFjdGlvbk9mUGFnZUhlaWdodDogbnVtYmVyO1xyXG4gIC8qKiBNaW5pbXVtIG51bWJlciBvZiBnYXBzIHJlcXVpcmVkIGZvciB0cmltbWVkIGF2ZXJhZ2UgaW4gbGluZSBoZWlnaHQgZXN0aW1hdGlvbiAoZGVmYXVsdDogNSkgKi9cclxuICBtaW5HYXBzRm9yVHJpbTogbnVtYmVyO1xyXG4gIC8qKiBQZXJjZW50YWdlIG9mIGdhcHMgdG8gdHJpbSBmcm9tIGVhY2ggZW5kIGZvciByb2J1c3QgYXZlcmFnZSAoZGVmYXVsdDogMC4xNSkgKi9cclxuICB0cmltUGVyY2VudDogbnVtYmVyO1xyXG4gIC8qKiBNdWx0aXBsaWVyIHRvIGNvbnZlcnQgYXZlcmFnZSBnYXAgdG8gbGluZSBoZWlnaHQgKGRlZmF1bHQ6IDEuMjUpICovXHJcbiAgbGluZUhlaWdodEZyb21BdmdNdWx0aXBsaWVyOiBudW1iZXI7XHJcbiAgLyoqIE11bHRpcGxpZXIgZm9yIGZsb29yIHZhbHVlIGluIGxpbmUgaGVpZ2h0IGVzdGltYXRpb24gKGRlZmF1bHQ6IDAuOCkgKi9cclxuICBmbG9vck11bHRpcGxpZXI6IG51bWJlcjtcclxuICAvKiogTWluaW11bSBvdmVybGFwIGZyYWN0aW9uIGZvciBhc3NpZ25pbmcgc3BhbnMgdG8gYmFuZHMgKGRlZmF1bHQ6IDAuNCkgKi9cclxuICBtaW5PdmVybGFwRnJhY0ZvckJhbmQ6IG51bWJlcjtcclxuICAvKiogTWluaW11bSB3aWR0aCBmb3IgY29sdW1uIHJlZ2lvbnMgKGRlZmF1bHQ6IDEpICovXHJcbiAgbWluUmVnaW9uV2lkdGg6IG51bWJlcjtcclxuICAvKiogTXVsdGlwbGllciBmb3IgY29sdW1uIHRocmVzaG9sZCBiYXNlZCBvbiBhdmVyYWdlIGxpbmUgaGVpZ2h0IChkZWZhdWx0OiAyKSAqL1xyXG4gIGNvbHVtblRocmVzaG9sZExpbmVIZWlnaHRNdWx0aXBsaWVyOiBudW1iZXI7XHJcbiAgLyoqIEZhbGxiYWNrIHBpeGVsIHZhbHVlIGZvciBjb2x1bW4gdGhyZXNob2xkIGlmIGxpbmUgaGVpZ2h0IGlzIHVuYXZhaWxhYmxlIChkZWZhdWx0OiAyMCkgKi9cclxuICBjb2x1bW5UaHJlc2hvbGRGYWxsYmFjazogbnVtYmVyO1xyXG5cclxuICAvLyAtLS0gU2V0dGluZ3MgcG90ZW50aWFsbHkgdXNlZCBieSBQYXJhZ3JhcGhNZXJnZXIgLS0tXHJcbiAgXHJcbiAgLyoqIFxyXG4gICAqIElmIHRydWUsIGlnbm9yZXMgY29sdW1uIGFsaWdubWVudCwgaG9yaXpvbnRhbCBiYW5kcywgYW5kIGZvbnQgc3R5bGVzLiBcclxuICAgKiBUcmllcyB0byBtZXJnZSBldmVyeXRoaW5nIGludG8gYSBzaW5nbGUgZmxvdyBiYXNlZCBwdXJlbHkgb24gcmVhZGluZyBvcmRlciBhbmQgdmVydGljYWwgcHJveGltaXR5LlxyXG4gICAqIChkZWZhdWx0OiBmYWxzZSlcclxuICAgKi9cclxuICBwbUZvcmNlTGluZWFyTWVyZ2U6IGJvb2xlYW47XHJcblxyXG4gIC8qKiBNaW5pbXVtIGNvbmZpZGVuY2UgZm9yIHZlcnRpY2FsIHN0cmlwcyB1c2VkIGluIFBhcmFncmFwaE1lcmdlciAoZGVmYXVsdDogMC43KSAqL1xyXG4gIHBtTWluU3RyaXBDb25maWRlbmNlU3BsaXQ6IG51bWJlcjtcclxuICAvKiogTWluaW11bSB3aWR0aCBpbiBwaXhlbHMgZm9yIHZlcnRpY2FsIHN0cmlwcyB1c2VkIGluIFBhcmFncmFwaE1lcmdlciAoZGVmYXVsdDogNikgKi9cclxuICBwbU1pblN0cmlwV2lkdGhQeDogbnVtYmVyO1xyXG4gIC8qKiBNaW5pbXVtIHZlcnRpY2FsIG92ZXJsYXAgZnJhY3Rpb24gcmVxdWlyZWQgZm9yIHNwYW5zIHRvIGJlIGNvbnNpZGVyZWQgaW4gdGhlIHNhbWUgY29sdW1uIChkZWZhdWx0OiAwLjYpICovXHJcbiAgcG1NaW5TdHJpcE92ZXJsYXBGcmFjOiBudW1iZXI7XHJcbiAgLyoqIFRvbGVyYW5jZSBtdWx0aXBsaWVyIGZvciBiYXNlbGluZSBhbGlnbm1lbnQgaW4gaW5pdGlhbCBtZXJnZSAobm9uLW1hdGgpIChkZWZhdWx0OiAwLjQ1KSAqL1xyXG4gIHBtSW5pdGlhbE1lcmdlQmFzZWxpbmVUb2xOb25NYXRoOiBudW1iZXI7XHJcbiAgLyoqIFRvbGVyYW5jZSBtdWx0aXBsaWVyIGZvciBiYXNlbGluZSBhbGlnbm1lbnQgaW4gaW5pdGlhbCBtZXJnZSAobWF0aCkgKGRlZmF1bHQ6IDAuNzUpICovXHJcbiAgcG1Jbml0aWFsTWVyZ2VCYXNlbGluZVRvbE1hdGg6IG51bWJlcjtcclxuICAvKiogVG9sZXJhbmNlIG11bHRpcGxpZXIgZm9yIGlubGluZSBrZXJuaW5nIGluIGluaXRpYWwgbWVyZ2UgKG5vbi1tYXRoKSAoZGVmYXVsdDogMC41NSkgKi9cclxuICBwbUluaXRpYWxNZXJnZUtlcm5Ub2xOb25NYXRoOiBudW1iZXI7XHJcbiAgLyoqIFRvbGVyYW5jZSBtdWx0aXBsaWVyIGZvciBpbmxpbmUga2VybmluZyBpbiBpbml0aWFsIG1lcmdlIChtYXRoKSAoZGVmYXVsdDogMC45KSAqL1xyXG4gIHBtSW5pdGlhbE1lcmdlS2VyblRvbE1hdGg6IG51bWJlcjtcclxuICAvKiogVG9sZXJhbmNlIG11bHRpcGxpZXIgZm9yIGh5cGhlbmF0aW9uIGNvbnRpbnVhdGlvbiAoZGVmYXVsdDogMS44KSAqL1xyXG4gIHBtSHlwaGVuQ29udGludWF0aW9uVG9sOiBudW1iZXI7XHJcbiAgLyoqIFRvbGVyYW5jZSBtdWx0aXBsaWVyIGZvciBsZWZ0L3JpZ2h0IGFsaWdubWVudCBpbiBpbml0aWFsIG1lcmdlIChub24tbWF0aCkgKGRlZmF1bHQ6IDIuMCkgKi9cclxuICBwbUluaXRpYWxNZXJnZUFsaWduVG9sTm9uTWF0aDogbnVtYmVyO1xyXG4gIC8qKiBUb2xlcmFuY2UgbXVsdGlwbGllciBmb3IgbGVmdC9yaWdodCBhbGlnbm1lbnQgaW4gaW5pdGlhbCBtZXJnZSAobWF0aCkgKGRlZmF1bHQ6IDIuMCkgKi9cclxuICBwbUluaXRpYWxNZXJnZUFsaWduVG9sTWF0aDogbnVtYmVyO1xyXG4gIC8qKiBWZXJ0aWNhbCBnYXAgbXVsdGlwbGllciByZWxhdGl2ZSB0byBsaW5lIGhlaWdodCBpbiBpbml0aWFsIG1lcmdlIChkZWZhdWx0OiAxLjMpICovXHJcbiAgcG1Jbml0aWFsTWVyZ2VWZXJ0aWNhbEdhcE11bHRpcGxpZXI6IG51bWJlcjtcclxuICAvKiogTWF4aW11bSB2ZXJ0aWNhbCBnYXAgYXMgYSBtdWx0aXBsaWVyIG9mIGZvbnQgc2l6ZSBpbiBpbml0aWFsIG1lcmdlIChkZWZhdWx0OiAyLjIpICovXHJcbiAgcG1Jbml0aWFsTWVyZ2VWZXJ0aWNhbEdhcE1heE11bHRpcGxpZXI6IG51bWJlcjtcclxuICAvKiogVG9sZXJhbmNlIG11bHRpcGxpZXIgZm9yIGxlZnQvcmlnaHQgYWxpZ25tZW50IGluIHN0YWNrZWQgbWVyZ2UgKGRlZmF1bHQ6IDIuMCkgKi9cclxuICBwbVN0YWNrZWRNZXJnZUFsaWduVG9sOiBudW1iZXI7XHJcbiAgLyoqIEhvcml6b250YWwgb3ZlcmxhcCBmcmFjdGlvbiB0aHJlc2hvbGQgZm9yIHN0cm9uZyBvdmVybGFwIGluIHN0YWNrZWQgbWVyZ2UgKGRlZmF1bHQ6IDAuMjUpICovXHJcbiAgcG1TdGFja2VkTWVyZ2VPdmVybGFwRnJhYzogbnVtYmVyO1xyXG4gIC8qKiBWZXJ0aWNhbCBnYXAgbXVsdGlwbGllciByZWxhdGl2ZSB0byBsaW5lIGhlaWdodCBpbiBzdGFja2VkIG1lcmdlIChkZWZhdWx0OiAxLjM1KSAqL1xyXG4gIHBtU3RhY2tlZE1lcmdlVmVydGljYWxHYXBNdWx0aXBsaWVyOiBudW1iZXI7XHJcbiAgLyoqIE1heGltdW0gdmVydGljYWwgZ2FwIGFzIGEgbXVsdGlwbGllciBvZiBtYXggZm9udCBzaXplIGluIHN0YWNrZWQgbWVyZ2UgKGRlZmF1bHQ6IDIuMCkgKi9cclxuICBwbVN0YWNrZWRNZXJnZVZlcnRpY2FsR2FwTWF4TXVsdGlwbGllcjogbnVtYmVyO1xyXG4gIC8qKiBUb2xlcmFuY2UgbXVsdGlwbGllciBmb3IgbGVmdC9yaWdodCBhbGlnbm1lbnQgaW4gZ2VuZXJhbCBtZXJnZSAoZGVmYXVsdDogMi4wKSAqL1xyXG4gIHBtR2VuZXJhbE1lcmdlQWxpZ25Ub2w6IG51bWJlcjtcclxuICAvKiogSG9yaXpvbnRhbCBvdmVybGFwIGZyYWN0aW9uIHRocmVzaG9sZCBmb3Igc3Ryb25nIG92ZXJsYXAgaW4gZ2VuZXJhbCBtZXJnZSAoZGVmYXVsdDogMC4yNSkgKi9cclxuICBwbUdlbmVyYWxNZXJnZU92ZXJsYXBGcmFjOiBudW1iZXI7XHJcbiAgLyoqIFZlcnRpY2FsIGdhcCBtdWx0aXBsaWVyIHJlbGF0aXZlIHRvIGxpbmUgaGVpZ2h0IGluIGdlbmVyYWwgbWVyZ2UgKGRlZmF1bHQ6IDEuMzUpICovXHJcbiAgcG1HZW5lcmFsTWVyZ2VWZXJ0aWNhbEdhcE11bHRpcGxpZXI6IG51bWJlcjtcclxuICAvKiogTWF4aW11bSB2ZXJ0aWNhbCBnYXAgYXMgYSBtdWx0aXBsaWVyIG9mIG1heCBmb250IHNpemUgaW4gZ2VuZXJhbCBtZXJnZSAoZGVmYXVsdDogMi4wKSAqL1xyXG4gIHBtR2VuZXJhbE1lcmdlVmVydGljYWxHYXBNYXhNdWx0aXBsaWVyOiBudW1iZXI7XHJcbiAgLyoqIE92ZXJsYXAgZnJhY3Rpb24gdGhyZXNob2xkIGZvciBzdHJvbmcgb3ZlcmxhcCBpbiBuZXN0ZWQgbWVyZ2UgKGRlZmF1bHQ6IDAuNykgKi9cclxuICBwbU5lc3RlZE1lcmdlT3ZlcmxhcEZyYWM6IG51bWJlcjtcclxuICAvKiogVG9sZXJhbmNlIG11bHRpcGxpZXIgZm9yIGJhc2VsaW5lIGFsaWdubWVudCBpbiBpbmxpbmUgc3RpdGNoaW5nIChub24tbWF0aCkgKGRlZmF1bHQ6IDAuNDUpICovXHJcbiAgcG1TdGl0Y2hCYXNlbGluZVRvbE5vbk1hdGg6IG51bWJlcjtcclxuICAvKiogVG9sZXJhbmNlIG11bHRpcGxpZXIgZm9yIGJhc2VsaW5lIGFsaWdubWVudCBpbiBpbmxpbmUgc3RpdGNoaW5nIChtYXRoKSAoZGVmYXVsdDogMC43NSkgKi9cclxuICBwbVN0aXRjaEJhc2VsaW5lVG9sTWF0aDogbnVtYmVyO1xyXG4gIC8qKiBUb2xlcmFuY2UgbXVsdGlwbGllciBmb3IgaW5saW5lIGtlcm5pbmcgaW4gaW5saW5lIHN0aXRjaGluZyAobm9uLW1hdGgpIChkZWZhdWx0OiAwLjU1KSAqL1xyXG4gIHBtU3RpdGNoS2VyblRvbE5vbk1hdGg6IG51bWJlcjtcclxuICAvKiogVG9sZXJhbmNlIG11bHRpcGxpZXIgZm9yIGlubGluZSBrZXJuaW5nIGluIGlubGluZSBzdGl0Y2hpbmcgKG1hdGgpIChkZWZhdWx0OiAwLjkpICovXHJcbiAgcG1TdGl0Y2hLZXJuVG9sTWF0aDogbnVtYmVyO1xyXG4gIC8qKiBCYXNlbGluZSB0b2xlcmFuY2UgbXVsdGlwbGllciBmb3IgaW5saW5lIHNwYW4gbWVyZ2luZyAoZGVmYXVsdDogMC4zKSAqL1xyXG4gIHBtSW5saW5lU3BhbkJhc2VsaW5lVG9sOiBudW1iZXI7XHJcbiAgLyoqIEtlcm5pbmcgdG9sZXJhbmNlIG11bHRpcGxpZXIgZm9yIGlubGluZSBzcGFuIG1lcmdpbmcgKGRlZmF1bHQ6IDAuNikgKi9cclxuICBwbUlubGluZVNwYW5LZXJuVG9sOiBudW1iZXI7XHJcbiAgLyoqIE1heGltdW0gZGlmZmVyZW5jZSBpbiBudW1lcmljIGZvbnQgd2VpZ2h0IChlLmcuLCA0MDAgdnMgNzAwKSB0byBhbGxvdyBtZXJnaW5nLiAoZGVmYXVsdDogMzAwKSAqL1xyXG4gIHBtSW5saW5lU3Bhbk1heFdlaWdodERpZmY6IG51bWJlcjtcclxuICAvKiogV2hldGhlciB0byBhbGxvdyBtZXJnaW5nIG9mIHNwYW5zIHdpdGggZGlmZmVyZW50IGZvbnQgc3R5bGVzLiAoZGVmYXVsdDogdHJ1ZSkgKi9cclxuICBwbUlubGluZVNwYW5BbGxvd01peGVkU3R5bGU6IGJvb2xlYW47XHJcbiAgLyoqIENvdmVyYWdlIHJhdGlvIHRocmVzaG9sZCBmb3IgZGV0ZXJtaW5pbmcgaWYgc3RyaXBzIHNlcGFyYXRlIGNvbHVtbnMgKGRlZmF1bHQ6IDAuNjUpICovXHJcbiAgcG1TYW1lQ29sdW1uQ292ZXJhZ2VSYXRpbzogbnVtYmVyO1xyXG4gIC8qKiBCYXNlbGluZSBwcm94aW1pdHkgdG9sZXJhbmNlIG11bHRpcGxpZXIgZm9yIG1hdGggbWVyZ2UgY2FuZGlkYXRlIChkZWZhdWx0OiAyLjApICovXHJcbiAgcG1NYXRoTWVyZ2VCYXNlbGluZVRvbDogbnVtYmVyO1xyXG4gIC8qKiBIb3Jpem9udGFsIHByb3hpbWl0eSB0b2xlcmFuY2UgbXVsdGlwbGllciBmb3IgbWF0aCBtZXJnZSBjYW5kaWRhdGUgKGRlZmF1bHQ6IDEuNSkgKi9cclxuICBwbU1hdGhNZXJnZUhvcml6VG9sOiBudW1iZXI7XHJcbiAgLyoqIENlbnRlciBwcm94aW1pdHkgdG9sZXJhbmNlIG11bHRpcGxpZXIgZm9yIG1hdGggbWVyZ2UgY2FuZGlkYXRlIChkZWZhdWx0OiAyLjUpICovXHJcbiAgcG1NYXRoTWVyZ2VDZW50ZXJUb2w6IG51bWJlcjtcclxuICAvKiogTGluZSBoZWlnaHQgdG9sZXJhbmNlIG11bHRpcGxpZXIgZm9yIGdyb3VwaW5nIHNwYW5zIGJ5IGxpbmUgZHVyaW5nIHNwbGl0dGluZyAoZGVmYXVsdDogMC43KSAqL1xyXG4gIHBtU3BsaXRMaW5lSGVpZ2h0VG9sOiBudW1iZXI7XHJcbiAgLyoqIEJvdW5kYXJ5IGRlZHVwbGljYXRpb24gdG9sZXJhbmNlIG11bHRpcGxpZXIgcmVsYXRpdmUgdG8gbGluZSBoZWlnaHQgKGRlZmF1bHQ6IDAuMykgKi9cclxuICBwbVNwbGl0Qm91bmRhcnlEZWR1cFRvbDogbnVtYmVyO1xyXG4gIC8qKiBJbnRlci13b3JkIGdhcCB0b2xlcmFuY2UgbXVsdGlwbGllciByZWxhdGl2ZSB0byBmb250IHNpemUgKGRlZmF1bHQ6IDEuMikgKi9cclxuICBwbVNwbGl0SW50ZXJXb3JkR2FwVG9sOiBudW1iZXI7XHJcbiAgLyoqIENvbHVtbiBnYXAgdG9sZXJhbmNlIG11bHRpcGxpZXIgcmVsYXRpdmUgdG8gZm9udCBzaXplIChkZWZhdWx0OiAyLjUpICovXHJcbiAgcG1TcGxpdENvbHVtbkdhcFRvbDogbnVtYmVyO1xyXG59XHJcblxyXG4vLyBJbnRlcmZhY2UgZm9yIHByZXNldCBkYXRhXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJlc2V0IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBzZXR0aW5nczogTGF5b3V0U2V0dGluZ3M7XHJcbiAgY3JlYXRlZEF0OiBEYXRlO1xyXG4gIHVwZGF0ZWRBdDogRGF0ZTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGRlZmF1bHRMYXlvdXRTZXR0aW5nczogTGF5b3V0U2V0dGluZ3MgPSB7XHJcbiAgbGluZUhlaWdodE11bHRpcGxpZXI6IDEuNixcclxuICBtaW5TdHJpcENvbmZpZGVuY2U6IDAuNyxcclxuICBtaW5TdHJpcFdpZHRoUHg6IDQsXHJcbiAgZGVidWdWYWxpZGF0aW9uOiBmYWxzZSxcclxuICBtYXhJdGVyTWVyZ2VzOiAxMCxcclxuICBtaW5CYW5kQ29uZmlkZW5jZTogMC42LFxyXG4gIGJhbmRUb3BCb3R0b21UaHJlc2hvbGRNdWx0aXBsaWVyOiAwLjc1LFxyXG4gIGluZmVycmVkQmFuZENvbmZpZGVuY2U6IDAuOCxcclxuICBiYW5kTWVyZ2VHYXBQeDogMixcclxuICBiYW5kTWVyZ2VHYXBMaW5lSGVpZ2h0TXVsdGlwbGllcjogMC4yLFxyXG4gIG1heEdhcEZyYWN0aW9uT2ZQYWdlSGVpZ2h0OiAwLjUsXHJcbiAgbWluR2Fwc0ZvclRyaW06IDUsXHJcbiAgdHJpbVBlcmNlbnQ6IDAuMTUsXHJcbiAgbGluZUhlaWdodEZyb21BdmdNdWx0aXBsaWVyOiAxLjI1LFxyXG4gIGZsb29yTXVsdGlwbGllcjogMC44LFxyXG4gIG1pbk92ZXJsYXBGcmFjRm9yQmFuZDogMC40LFxyXG4gIG1pblJlZ2lvbldpZHRoOiAxLFxyXG4gIGNvbHVtblRocmVzaG9sZExpbmVIZWlnaHRNdWx0aXBsaWVyOiAyLFxyXG4gIGNvbHVtblRocmVzaG9sZEZhbGxiYWNrOiAyMCxcclxuICBcclxuICAvLyAtLSBQYXJhZ3JhcGggTWVyZ2VyIERlZmF1bHRzIC0tXHJcbiAgcG1Gb3JjZUxpbmVhck1lcmdlOiBmYWxzZSwgLy8gRGVmYXVsdDogT2ZmXHJcblxyXG4gIHBtTWluU3RyaXBDb25maWRlbmNlU3BsaXQ6IDAuNyxcclxuICBwbU1pblN0cmlwV2lkdGhQeDogNixcclxuICBwbU1pblN0cmlwT3ZlcmxhcEZyYWM6IDAuNixcclxuICBwbUluaXRpYWxNZXJnZUJhc2VsaW5lVG9sTm9uTWF0aDogMC40NSxcclxuICBwbUluaXRpYWxNZXJnZUJhc2VsaW5lVG9sTWF0aDogMC43NSxcclxuICBwbUluaXRpYWxNZXJnZUtlcm5Ub2xOb25NYXRoOiAwLjU1LFxyXG4gIHBtSW5pdGlhbE1lcmdlS2VyblRvbE1hdGg6IDAuOSxcclxuICBwbUh5cGhlbkNvbnRpbnVhdGlvblRvbDogMS44LFxyXG4gIHBtSW5pdGlhbE1lcmdlQWxpZ25Ub2xOb25NYXRoOiAyLjAsXHJcbiAgcG1Jbml0aWFsTWVyZ2VBbGlnblRvbE1hdGg6IDIuMCxcclxuICBwbUluaXRpYWxNZXJnZVZlcnRpY2FsR2FwTXVsdGlwbGllcjogMS4zLFxyXG4gIHBtSW5pdGlhbE1lcmdlVmVydGljYWxHYXBNYXhNdWx0aXBsaWVyOiAyLjIsXHJcbiAgcG1TdGFja2VkTWVyZ2VBbGlnblRvbDogMi4wLFxyXG4gIHBtU3RhY2tlZE1lcmdlT3ZlcmxhcEZyYWM6IDAuMjUsXHJcbiAgcG1TdGFja2VkTWVyZ2VWZXJ0aWNhbEdhcE11bHRpcGxpZXI6IDEuMzUsXHJcbiAgcG1TdGFja2VkTWVyZ2VWZXJ0aWNhbEdhcE1heE11bHRpcGxpZXI6IDIuMCxcclxuICBwbUdlbmVyYWxNZXJnZUFsaWduVG9sOiAyLjAsXHJcbiAgcG1HZW5lcmFsTWVyZ2VPdmVybGFwRnJhYzogMC4yNSxcclxuICBwbUdlbmVyYWxNZXJnZVZlcnRpY2FsR2FwTXVsdGlwbGllcjogMS4zNSxcclxuICBwbUdlbmVyYWxNZXJnZVZlcnRpY2FsR2FwTWF4TXVsdGlwbGllcjogMi4wLFxyXG4gIHBtTmVzdGVkTWVyZ2VPdmVybGFwRnJhYzogMC43LFxyXG4gIHBtU3RpdGNoQmFzZWxpbmVUb2xOb25NYXRoOiAwLjQ1LFxyXG4gIHBtU3RpdGNoQmFzZWxpbmVUb2xNYXRoOiAwLjc1LFxyXG4gIHBtU3RpdGNoS2VyblRvbE5vbk1hdGg6IDAuNTUsXHJcbiAgcG1TdGl0Y2hLZXJuVG9sTWF0aDogMC45LFxyXG4gIHBtSW5saW5lU3BhbkJhc2VsaW5lVG9sOiAwLjMsXHJcbiAgcG1JbmxpbmVTcGFuS2VyblRvbDogMC42LFxyXG4gIHBtSW5saW5lU3Bhbk1heFdlaWdodERpZmY6IDMwMCxcclxuICBwbUlubGluZVNwYW5BbGxvd01peGVkU3R5bGU6IHRydWUsXHJcbiAgcG1TYW1lQ29sdW1uQ292ZXJhZ2VSYXRpbzogMC42NSxcclxuICBwbU1hdGhNZXJnZUJhc2VsaW5lVG9sOiAyLjAsXHJcbiAgcG1NYXRoTWVyZ2VIb3JpelRvbDogMS41LFxyXG4gIHBtTWF0aE1lcmdlQ2VudGVyVG9sOiAyLjUsXHJcbiAgcG1TcGxpdExpbmVIZWlnaHRUb2w6IDAuNyxcclxuICBwbVNwbGl0Qm91bmRhcnlEZWR1cFRvbDogMC4zLFxyXG4gIHBtU3BsaXRJbnRlcldvcmRHYXBUb2w6IDEuMixcclxuICBwbVNwbGl0Q29sdW1uR2FwVG9sOiAyLjUsXHJcbn07XHJcblxyXG4vLyBTdG9yYWdlIGtleSBmb3IgcHJlc2V0c1xyXG5jb25zdCBQUkVTRVRTX1NUT1JBR0VfS0VZID0gJ2xheW91dFNldHRpbmdzUHJlc2V0cyc7XHJcblxyXG4vKipcclxuICogTWFuYWdlcyBwcmVzZXRzIGluIGxvY2FsU3RvcmFnZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFByZXNldE1hbmFnZXIge1xyXG4gIHN0YXRpYyBnZXRBbGxQcmVzZXRzKCk6IFByZXNldFtdIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFBSRVNFVFNfU1RPUkFHRV9LRVkpO1xyXG4gICAgICBpZiAoIXN0b3JlZCkgcmV0dXJuIFtdO1xyXG4gICAgICBjb25zdCBwcmVzZXRzID0gSlNPTi5wYXJzZShzdG9yZWQpO1xyXG4gICAgICByZXR1cm4gcHJlc2V0cy5tYXAoKHByZXNldDogYW55KSA9PiAoe1xyXG4gICAgICAgIC4uLnByZXNldCxcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKHByZXNldC5jcmVhdGVkQXQpLFxyXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUocHJlc2V0LnVwZGF0ZWRBdClcclxuICAgICAgfSkpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBwcmVzZXRzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIHNhdmVQcmVzZXQocHJlc2V0OiBPbWl0PFByZXNldCwgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ3VwZGF0ZWRBdCc+ICYgeyBpZD86IHN0cmluZyB9KTogUHJlc2V0IHtcclxuICAgIC8vIFJlLXJlYWQgZnJvbSBzdG9yYWdlIHRvIG1pbmltaXplIHJhY2UgY29uZGl0aW9ucyB3aXRoIG90aGVyIHdpbmRvd3NcclxuICAgIGNvbnN0IGFsbFByZXNldHMgPSB0aGlzLmdldEFsbFByZXNldHMoKTtcclxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICBcclxuICAgIGNvbnN0IG5ld1ByZXNldDogUHJlc2V0ID0ge1xyXG4gICAgICBpZDogcHJlc2V0LmlkIHx8IERhdGUubm93KCkudG9TdHJpbmcoKSxcclxuICAgICAgbmFtZTogcHJlc2V0Lm5hbWUsXHJcbiAgICAgIHNldHRpbmdzOiBwcmVzZXQuc2V0dGluZ3MsXHJcbiAgICAgIGNyZWF0ZWRBdDogcHJlc2V0LmNyZWF0ZWRBdCB8fCBub3csXHJcbiAgICAgIHVwZGF0ZWRBdDogbm93XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBhbGxQcmVzZXRzLmZpbmRJbmRleChwID0+IHAuaWQgPT09IG5ld1ByZXNldC5pZCk7XHJcbiAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XHJcbiAgICAgIC8vIFByZXNlcnZlIGNyZWF0aW9uIGRhdGUgaWYgdXBkYXRpbmdcclxuICAgICAgbmV3UHJlc2V0LmNyZWF0ZWRBdCA9IGFsbFByZXNldHNbZXhpc3RpbmdJbmRleF0uY3JlYXRlZEF0O1xyXG4gICAgICBhbGxQcmVzZXRzW2V4aXN0aW5nSW5kZXhdID0gbmV3UHJlc2V0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYWxsUHJlc2V0cy5wdXNoKG5ld1ByZXNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oUFJFU0VUU19TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoYWxsUHJlc2V0cykpO1xyXG4gICAgcmV0dXJuIG5ld1ByZXNldDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBkZWxldGVQcmVzZXQoaWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgYWxsUHJlc2V0cyA9IHRoaXMuZ2V0QWxsUHJlc2V0cygpO1xyXG4gICAgY29uc3QgZmlsdGVyZWRQcmVzZXRzID0gYWxsUHJlc2V0cy5maWx0ZXIocHJlc2V0ID0+IHByZXNldC5pZCAhPT0gaWQpO1xyXG4gICAgXHJcbiAgICBpZiAoZmlsdGVyZWRQcmVzZXRzLmxlbmd0aCA8IGFsbFByZXNldHMubGVuZ3RoKSB7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFBSRVNFVFNfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KGZpbHRlcmVkUHJlc2V0cykpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRQcmVzZXRCeUlkKGlkOiBzdHJpbmcpOiBQcmVzZXQgfCB1bmRlZmluZWQge1xyXG4gICAgY29uc3QgYWxsUHJlc2V0cyA9IHRoaXMuZ2V0QWxsUHJlc2V0cygpO1xyXG4gICAgcmV0dXJuIGFsbFByZXNldHMuZmluZChwcmVzZXQgPT4gcHJlc2V0LmlkID09PSBpZCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2hvd3MgYSB1c2VyLWZyaWVuZGx5IG1vZGFsIGRpYWxvZyBmb3IgYWRqdXN0aW5nIGxheW91dCBzZXR0aW5ncy5cclxuICogQHBhcmFtIGN1cnJlbnRTZXR0aW5ncyBUaGUgY3VycmVudCBzZXR0aW5ncyB0byBwcmVmaWxsIHRoZSBtb2RhbCB3aXRoLlxyXG4gKiBAcGFyYW0gb25TYXZlIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgc2F2ZWQgc2V0dGluZ3MuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2hvd0xheW91dFNldHRpbmdzTW9kYWwoXHJcbiAgICBjdXJyZW50U2V0dGluZ3M6IExheW91dFNldHRpbmdzID0gZGVmYXVsdExheW91dFNldHRpbmdzLCBcclxuICAgIG9uU2F2ZTogKHNldHRpbmdzOiBMYXlvdXRTZXR0aW5ncykgPT4gdm9pZFxyXG4pOiB2b2lkIHtcclxuICAvLyAxLiBQcmV2ZW50IER1cGxpY2F0ZSBNb2RhbHNcclxuICBjb25zdCBFWElTVElOR19NT0RBTF9JRCA9ICdsYXlvdXQtc2V0dGluZ3MtbW9kYWwtY29udGFpbmVyJztcclxuICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoRVhJU1RJTkdfTU9EQUxfSUQpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyAyLiBHZW5lcmF0ZSBhIHVuaXF1ZSBzY29wZSBJRCBmb3IgdGhpcyBpbnN0YW5jZSB0byBwcmV2ZW50IElEIGNvbGxpc2lvbnMgaW4gRE9NXHJcbiAgY29uc3QgVUlEID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDkpO1xyXG5cclxuICBjb25zdCBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaWFsb2cnKTtcclxuICBkaWFsb2cuaWQgPSBFWElTVElOR19NT0RBTF9JRDtcclxuICBkaWFsb2cuc3R5bGUucGFkZGluZyA9ICcyMHB4JztcclxuICBkaWFsb2cuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCB2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlciwgI2NjYyknO1xyXG4gIGRpYWxvZy5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnOHB4JztcclxuICBkaWFsb2cuc3R5bGUubWF4V2lkdGggPSAnNzAwcHgnO1xyXG4gIGRpYWxvZy5zdHlsZS53aWR0aCA9ICc5MCUnO1xyXG4gIGRpYWxvZy5zdHlsZS5vdmVyZmxvd1kgPSAnYXV0byc7XHJcbiAgZGlhbG9nLnN0eWxlLm1heEhlaWdodCA9ICc4NXZoJztcclxuICBkaWFsb2cuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3ZhcigtLWJhY2tncm91bmQtcHJpbWFyeSwgI2ZmZmZmZiknO1xyXG4gIGRpYWxvZy5zdHlsZS5jb2xvciA9ICd2YXIoLS10ZXh0LW5vcm1hbCwgIzAwMDAwMCknO1xyXG4gIGRpYWxvZy5zdHlsZS5mb250RmFtaWx5ID0gJ3ZhcigtLWZvbnQtaW50ZXJmYWNlLCBzYW5zLXNlcmlmKSc7XHJcbiAgZGlhbG9nLnN0eWxlLmJveFNoYWRvdyA9ICcwIDEwcHggNDBweCByZ2JhKDAsMCwwLDAuMyknO1xyXG4gIGRpYWxvZy5zdHlsZS56SW5kZXggPSAnOTk5OSc7XHJcblxyXG4gIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICBzdHlsZS50ZXh0Q29udGVudCA9IGBcclxuICAgIC50b2dnbGUtc3dpdGNoIHsgcG9zaXRpb246IHJlbGF0aXZlOyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdpZHRoOiA0NHB4OyBoZWlnaHQ6IDI0cHg7IGp1c3RpZnktc2VsZjogc3RhcnQ7IH1cclxuICAgIC50b2dnbGUtc3dpdGNoIGlucHV0IHsgb3BhY2l0eTogMDsgd2lkdGg6IDA7IGhlaWdodDogMDsgfVxyXG4gICAgLnNsaWRlciB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgY3Vyc29yOiBwb2ludGVyOyB0b3A6IDA7IGxlZnQ6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IGJhY2tncm91bmQtY29sb3I6ICNjY2M7IHRyYW5zaXRpb246IC40czsgYm9yZGVyLXJhZGl1czogMjRweDsgfVxyXG4gICAgLnNsaWRlcjpiZWZvcmUgeyBwb3NpdGlvbjogYWJzb2x1dGU7IGNvbnRlbnQ6IFwiXCI7IGhlaWdodDogMThweDsgd2lkdGg6IDE4cHg7IGxlZnQ6IDNweDsgYm90dG9tOiAzcHg7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlOyB0cmFuc2l0aW9uOiAuNHM7IGJvcmRlci1yYWRpdXM6IDUwJTsgfVxyXG4gICAgaW5wdXQ6Y2hlY2tlZCArIC5zbGlkZXIgeyBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1pbnRlcmFjdGl2ZS1hY2NlbnQsICMwMDdhY2MpOyB9XHJcbiAgICBpbnB1dDpmb2N1cyArIC5zbGlkZXIgeyBib3gtc2hhZG93OiAwIDAgMXB4IHZhcigtLWludGVyYWN0aXZlLWFjY2VudCwgIzAwN2FjYyk7IH1cclxuICAgIGlucHV0OmNoZWNrZWQgKyAuc2xpZGVyOmJlZm9yZSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlWCgyMHB4KTsgfVxyXG4gIGA7XHJcbiAgZGlhbG9nLmFwcGVuZENoaWxkKHN0eWxlKTtcclxuXHJcbiAgY29uc3QgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcclxuICBmb3JtLnN0eWxlLmRpc3BsYXkgPSAnZ3JpZCc7XHJcbiAgZm9ybS5zdHlsZS5nYXAgPSAnMTBweCc7XHJcbiAgLy8gUHJldmVudCBkZWZhdWx0IGZvcm0gc3VibWlzc2lvbiAod2hpY2ggY2F1c2VzIHBhZ2UgcmVsb2FkKVxyXG4gIGZvcm0ub25zdWJtaXQgPSAoZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gyJyk7XHJcbiAgdGl0bGUudGV4dENvbnRlbnQgPSAnQWRqdXN0IExheW91dCBTZXR0aW5ncyc7XHJcbiAgdGl0bGUuc3R5bGUubWFyZ2luVG9wID0gJzAnO1xyXG4gIGZvcm0uYXBwZW5kQ2hpbGQodGl0bGUpO1xyXG5cclxuICAvLyAtLS0gUHJlc2V0IFNlY3Rpb24gLS0tXHJcbiAgY29uc3QgcHJlc2V0U2VjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIHByZXNldFNlY3Rpb24uc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCB2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlciwgI2RkZCknO1xyXG4gIHByZXNldFNlY3Rpb24uc3R5bGUuYm9yZGVyUmFkaXVzID0gJzRweCc7XHJcbiAgcHJlc2V0U2VjdGlvbi5zdHlsZS5wYWRkaW5nID0gJzE1cHgnO1xyXG4gIHByZXNldFNlY3Rpb24uc3R5bGUubWFyZ2luQm90dG9tID0gJzE1cHgnO1xyXG4gIHByZXNldFNlY3Rpb24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3ZhcigtLWJhY2tncm91bmQtc2Vjb25kYXJ5LCAjZjlmOWY5KSc7XHJcblxyXG4gIGNvbnN0IHByZXNldFRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDMnKTtcclxuICBwcmVzZXRUaXRsZS50ZXh0Q29udGVudCA9ICdQcmVzZXRzJztcclxuICBwcmVzZXRUaXRsZS5zdHlsZS5tYXJnaW5Ub3AgPSAnMCc7XHJcbiAgcHJlc2V0VGl0bGUuc3R5bGUubWFyZ2luQm90dG9tID0gJzEwcHgnO1xyXG4gIHByZXNldFNlY3Rpb24uYXBwZW5kQ2hpbGQocHJlc2V0VGl0bGUpO1xyXG5cclxuICAvLyBIZWxwZXIgdG8gZXh0cmFjdCB2YWx1ZXMgZnJvbSBmb3JtIHNhZmVseVxyXG4gIGNvbnN0IGdldEN1cnJlbnRGb3JtVmFsdWVzID0gKCk6IExheW91dFNldHRpbmdzID0+IHtcclxuICAgIGNvbnN0IG5ld1NldHRpbmdzOiBQYXJ0aWFsPExheW91dFNldHRpbmdzPiA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdExheW91dFNldHRpbmdzKSB7XHJcbiAgICAgICAgY29uc3QgaW5wdXQgPSBmb3JtLmVsZW1lbnRzLm5hbWVkSXRlbShrZXkpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGlucHV0KSB7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC50eXBlID09PSAnY2hlY2tib3gnKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdTZXR0aW5nc1trZXkgYXMga2V5b2YgTGF5b3V0U2V0dGluZ3NdID0gaW5wdXQuY2hlY2tlZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VGbG9hdChpbnB1dC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlZFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1NldHRpbmdzW2tleSBhcyBrZXlvZiBMYXlvdXRTZXR0aW5nc10gPSBwYXJzZWRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2V0dGluZ3Nba2V5IGFzIGtleW9mIExheW91dFNldHRpbmdzXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyAuLi5jdXJyZW50U2V0dGluZ3MsIC4uLm5ld1NldHRpbmdzIH0gYXMgTGF5b3V0U2V0dGluZ3M7XHJcbiAgfTtcclxuXHJcbiAgLy8gUHJlc2V0IGRyb3Bkb3duXHJcbiAgY29uc3QgcHJlc2V0U2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XHJcbiAgcHJlc2V0U2VsZWN0LnN0eWxlLm1hcmdpblJpZ2h0ID0gJzEwcHgnO1xyXG4gIHByZXNldFNlbGVjdC5zdHlsZS5wYWRkaW5nID0gJzVweCc7XHJcbiAgcHJlc2V0U2VsZWN0LnN0eWxlLm1hcmdpbkJvdHRvbSA9ICcxMHB4JztcclxuICBwcmVzZXRTZWxlY3Quc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcbiAgcHJlc2V0U2VsZWN0LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWZvcm0tZmllbGQsICNmZmZmZmYpJztcclxuICBwcmVzZXRTZWxlY3Quc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCB2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlciwgI2RkZCknO1xyXG4gIFxyXG4gIGNvbnN0IGRlZmF1bHRPcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcclxuICBkZWZhdWx0T3B0aW9uLnZhbHVlID0gJyc7XHJcbiAgZGVmYXVsdE9wdGlvbi50ZXh0Q29udGVudCA9ICdTZWxlY3QgYSBwcmVzZXQuLi4nO1xyXG4gIHByZXNldFNlbGVjdC5hcHBlbmRDaGlsZChkZWZhdWx0T3B0aW9uKTtcclxuXHJcbiAgY29uc3QgcmVmcmVzaFByZXNldERyb3Bkb3duID0gKHNlbGVjdElkOiBzdHJpbmcpID0+IHtcclxuICAgIHByZXNldFNlbGVjdC5pbm5lckhUTUwgPSAnJztcclxuICAgIHByZXNldFNlbGVjdC5hcHBlbmRDaGlsZChkZWZhdWx0T3B0aW9uKTtcclxuICAgIFByZXNldE1hbmFnZXIuZ2V0QWxsUHJlc2V0cygpLmZvckVhY2gocCA9PiB7XHJcbiAgICAgICAgY29uc3Qgb3B0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XHJcbiAgICAgICAgb3B0LnZhbHVlID0gcC5pZDtcclxuICAgICAgICBvcHQudGV4dENvbnRlbnQgPSBwLm5hbWU7XHJcbiAgICAgICAgcHJlc2V0U2VsZWN0LmFwcGVuZENoaWxkKG9wdCk7XHJcbiAgICB9KTtcclxuICAgIHByZXNldFNlbGVjdC52YWx1ZSA9IHNlbGVjdElkO1xyXG4gIH07XHJcblxyXG4gIHJlZnJlc2hQcmVzZXREcm9wZG93bignJyk7XHJcblxyXG4gIC8vIFByZXNldCBuYW1lIGlucHV0XHJcbiAgY29uc3QgcHJlc2V0TmFtZUlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuICBwcmVzZXROYW1lSW5wdXQudHlwZSA9ICd0ZXh0JztcclxuICBwcmVzZXROYW1lSW5wdXQucGxhY2Vob2xkZXIgPSAnUHJlc2V0IE5hbWUgKHJlcXVpcmVkIGZvciBcIlNhdmUgTmV3XCIpJztcclxuICBwcmVzZXROYW1lSW5wdXQuY2xhc3NMaXN0LmFkZCgnbW91c2V0cmFwJyk7XHJcbiAgcHJlc2V0TmFtZUlucHV0LnN0eWxlLm1hcmdpblJpZ2h0ID0gJzEwcHgnO1xyXG4gIHByZXNldE5hbWVJbnB1dC5zdHlsZS5wYWRkaW5nID0gJzVweCc7XHJcbiAgcHJlc2V0TmFtZUlucHV0LnN0eWxlLm1hcmdpbkJvdHRvbSA9ICcxMHB4JztcclxuICBwcmVzZXROYW1lSW5wdXQuc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcbiAgcHJlc2V0TmFtZUlucHV0LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWZvcm0tZmllbGQsICNmZmZmZmYpJztcclxuICBwcmVzZXROYW1lSW5wdXQuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCB2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlciwgI2RkZCknO1xyXG4gIFxyXG4gIC8vIEZpeDogU3RvcCBBTEwgcHJvcGFnYXRpb24gdG8gcHJldmVudCBPYnNpZGlhbiBpbnRlcmZlcmVuY2VcclxuICBbJ2tleWRvd24nLCAna2V5dXAnLCAna2V5cHJlc3MnXS5mb3JFYWNoKGV2dCA9PiB7XHJcbiAgICAgIHByZXNldE5hbWVJbnB1dC5hZGRFdmVudExpc3RlbmVyKGV2dCwgKGUpID0+IHtcclxuICAgICAgICAgIGlmICgoZSBhcyBLZXlib2FyZEV2ZW50KS5rZXkgPT09ICdFc2NhcGUnKSByZXR1cm47XHJcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgLy8gQnV0dG9ucyBjb250YWluZXJcclxuICBjb25zdCBwcmVzZXRCdXR0b25zRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgcHJlc2V0QnV0dG9uc0Rpdi5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xyXG4gIHByZXNldEJ1dHRvbnNEaXYuc3R5bGUuZ2FwID0gJzhweCc7XHJcbiAgcHJlc2V0QnV0dG9uc0Rpdi5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcic7XHJcbiAgcHJlc2V0QnV0dG9uc0Rpdi5zdHlsZS5mbGV4V3JhcCA9ICd3cmFwJztcclxuXHJcbiAgLy8gU3RhdHVzIExhYmVsXHJcbiAgY29uc3Qgc3RhdHVzTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgc3RhdHVzTGFiZWwuc3R5bGUubWFyZ2luTGVmdCA9ICc4cHgnO1xyXG4gIHN0YXR1c0xhYmVsLnN0eWxlLmNvbG9yID0gJ3ZhcigtLXRleHQtc3VjY2VzcywgZ3JlZW4pJztcclxuICBzdGF0dXNMYWJlbC5zdHlsZS5mb250V2VpZ2h0ID0gJ2JvbGQnO1xyXG4gIHN0YXR1c0xhYmVsLnN0eWxlLm9wYWNpdHkgPSAnMCc7XHJcbiAgc3RhdHVzTGFiZWwuc3R5bGUudHJhbnNpdGlvbiA9ICdvcGFjaXR5IDAuNXMnO1xyXG4gIHN0YXR1c0xhYmVsLnRleHRDb250ZW50ID0gJ1NhdmVkISc7XHJcblxyXG4gIGNvbnN0IHNob3dTdGF0dXMgPSAobXNnOiBzdHJpbmcpID0+IHtcclxuICAgICAgc3RhdHVzTGFiZWwudGV4dENvbnRlbnQgPSBtc2c7XHJcbiAgICAgIHN0YXR1c0xhYmVsLnN0eWxlLm9wYWNpdHkgPSAnMSc7XHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4geyBzdGF0dXNMYWJlbC5zdHlsZS5vcGFjaXR5ID0gJzAnOyB9LCAyMDAwKTtcclxuICB9O1xyXG5cclxuICAvLyAxLiBTYXZlIE5ldyBQcmVzZXRcclxuICBjb25zdCBzYXZlTmV3UHJlc2V0QnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcbiAgc2F2ZU5ld1ByZXNldEJ0bi50eXBlID0gJ2J1dHRvbic7XHJcbiAgc2F2ZU5ld1ByZXNldEJ0bi50ZXh0Q29udGVudCA9ICdcdUQ4M0RcdURDQkUgU2F2ZSBOZXcnO1xyXG4gIHNhdmVOZXdQcmVzZXRCdG4udGl0bGUgPSBcIlNhdmUgY3VycmVudCBzZXR0aW5ncyBhcyBhIE5FVyBwcmVzZXRcIjtcclxuICBzYXZlTmV3UHJlc2V0QnRuLm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICBjb25zdCBwcmVzZXROYW1lID0gcHJlc2V0TmFtZUlucHV0LnZhbHVlLnRyaW0oKTtcclxuICAgIGlmICghcHJlc2V0TmFtZSkge1xyXG4gICAgICBhbGVydCgnUGxlYXNlIGVudGVyIGEgbmFtZSBmb3IgdGhlIG5ldyBwcmVzZXQuJyk7XHJcbiAgICAgIHByZXNldE5hbWVJbnB1dC5mb2N1cygpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBmdWxsU2V0dGluZ3MgPSBnZXRDdXJyZW50Rm9ybVZhbHVlcygpO1xyXG4gICAgXHJcbiAgICBjb25zdCBzYXZlZFByZXNldCA9IFByZXNldE1hbmFnZXIuc2F2ZVByZXNldCh7XHJcbiAgICAgIG5hbWU6IHByZXNldE5hbWUsXHJcbiAgICAgIHNldHRpbmdzOiBmdWxsU2V0dGluZ3NcclxuICAgIH0pO1xyXG5cclxuICAgIHJlZnJlc2hQcmVzZXREcm9wZG93bihzYXZlZFByZXNldC5pZCk7XHJcbiAgICB1cGRhdGVQcmVzZXRCdG4uZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgIGRlbGV0ZVByZXNldEJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgc2hvd1N0YXR1cyhgU2F2ZWQ6ICR7cHJlc2V0TmFtZX1gKTtcclxuICB9O1xyXG5cclxuICAvLyAyLiBVcGRhdGUgU2VsZWN0ZWQgUHJlc2V0XHJcbiAgY29uc3QgdXBkYXRlUHJlc2V0QnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcbiAgdXBkYXRlUHJlc2V0QnRuLnR5cGUgPSAnYnV0dG9uJztcclxuICB1cGRhdGVQcmVzZXRCdG4udGV4dENvbnRlbnQgPSAnXHVEODNEXHVERDA0IFVwZGF0ZSBTZWxlY3RlZCc7XHJcbiAgdXBkYXRlUHJlc2V0QnRuLmRpc2FibGVkID0gdHJ1ZTtcclxuICB1cGRhdGVQcmVzZXRCdG4ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgY29uc3Qgc2VsZWN0ZWRJZCA9IHByZXNldFNlbGVjdC52YWx1ZTtcclxuICAgICAgaWYgKCFzZWxlY3RlZElkKSByZXR1cm47XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBleGlzdGluZyA9IFByZXNldE1hbmFnZXIuZ2V0UHJlc2V0QnlJZChzZWxlY3RlZElkKTtcclxuICAgICAgaWYgKCFleGlzdGluZykge1xyXG4gICAgICAgICAgYWxlcnQoJ0Vycm9yOiBQcmVzZXQgbm90IGZvdW5kLicpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBwcmVzZXROYW1lID0gcHJlc2V0TmFtZUlucHV0LnZhbHVlLnRyaW0oKSB8fCBleGlzdGluZy5uYW1lO1xyXG5cclxuICAgICAgaWYgKGNvbmZpcm0oYE92ZXJ3cml0ZSBzZXR0aW5ncyBmb3IgcHJlc2V0IFwiJHtleGlzdGluZy5uYW1lfVwiP2ApKSB7XHJcbiAgICAgICAgICBjb25zdCBmdWxsU2V0dGluZ3MgPSBnZXRDdXJyZW50Rm9ybVZhbHVlcygpO1xyXG4gICAgICAgICAgUHJlc2V0TWFuYWdlci5zYXZlUHJlc2V0KHtcclxuICAgICAgICAgICAgICBpZDogc2VsZWN0ZWRJZCxcclxuICAgICAgICAgICAgICBuYW1lOiBwcmVzZXROYW1lLFxyXG4gICAgICAgICAgICAgIHNldHRpbmdzOiBmdWxsU2V0dGluZ3NcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcmVmcmVzaFByZXNldERyb3Bkb3duKHNlbGVjdGVkSWQpO1xyXG4gICAgICAgICAgdXBkYXRlUHJlc2V0QnRuLmRpc2FibGVkID0gZmFsc2U7IFxyXG4gICAgICAgICAgZGVsZXRlUHJlc2V0QnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICBzaG93U3RhdHVzKCdQcmVzZXQgVXBkYXRlZCEnKTtcclxuICAgICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIDMuIERlbGV0ZSBQcmVzZXRcclxuICBjb25zdCBkZWxldGVQcmVzZXRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcclxuICBkZWxldGVQcmVzZXRCdXR0b24udHlwZSA9ICdidXR0b24nO1xyXG4gIGRlbGV0ZVByZXNldEJ1dHRvbi50ZXh0Q29udGVudCA9ICdcdUQ4M0RcdURERDFcdUZFMEYgRGVsZXRlJztcclxuICBkZWxldGVQcmVzZXRCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xyXG4gIGRlbGV0ZVByZXNldEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgY29uc3Qgc2VsZWN0ZWRJZCA9IHByZXNldFNlbGVjdC52YWx1ZTtcclxuICAgIGlmIChzZWxlY3RlZElkICYmIGNvbmZpcm0oJ0RlbGV0ZSB0aGlzIHByZXNldD8nKSkge1xyXG4gICAgICAgIFByZXNldE1hbmFnZXIuZGVsZXRlUHJlc2V0KHNlbGVjdGVkSWQpO1xyXG4gICAgICAgIHJlZnJlc2hQcmVzZXREcm9wZG93bignJyk7XHJcbiAgICAgICAgcHJlc2V0TmFtZUlucHV0LnZhbHVlID0gJyc7XHJcbiAgICAgICAgdXBkYXRlUHJlc2V0QnRuLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICBkZWxldGVQcmVzZXRCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIDQuIFJlc3RvcmUgRGVmYXVsdHNcclxuICBjb25zdCByZXN0b3JlRGVmYXVsdHNCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcclxuICByZXN0b3JlRGVmYXVsdHNCdXR0b24udHlwZSA9ICdidXR0b24nO1xyXG4gIHJlc3RvcmVEZWZhdWx0c0J1dHRvbi50ZXh0Q29udGVudCA9ICdcdTIxQkEgRm9ybSBEZWZhdWx0cyc7XHJcbiAgcmVzdG9yZURlZmF1bHRzQnV0dG9uLnRpdGxlID0gXCJSZXNldCB0aGUgZm9ybSBiZWxvdyB0byBmYWN0b3J5IGRlZmF1bHQgdmFsdWVzXCI7XHJcbiAgcmVzdG9yZURlZmF1bHRzQnV0dG9uLnN0eWxlLm1hcmdpbkxlZnQgPSAnYXV0byc7XHJcbiAgcmVzdG9yZURlZmF1bHRzQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICBpZiAoY29uZmlybSgnUmVzZXQgY3VycmVudCBmb3JtIHRvIGZhY3RvcnkgZGVmYXVsdCBzZXR0aW5ncz8nKSkge1xyXG4gICAgICBPYmplY3QuZW50cmllcyhkZWZhdWx0TGF5b3V0U2V0dGluZ3MpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlucHV0ID0gZm9ybS5lbGVtZW50cy5uYW1lZEl0ZW0oa2V5KSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGlmIChpbnB1dCkge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSBpbnB1dC5jaGVja2VkID0gdmFsdWU7XHJcbiAgICAgICAgICBlbHNlIGlucHV0LnZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHByZXNldFNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICBjb25zdCBzZWxlY3RlZElkID0gcHJlc2V0U2VsZWN0LnZhbHVlO1xyXG4gICAgXHJcbiAgICBpZiAoIXNlbGVjdGVkSWQpIHtcclxuICAgICAgICB1cGRhdGVQcmVzZXRCdG4uZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIGRlbGV0ZVByZXNldEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVByZXNldEJ0bi5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgZGVsZXRlUHJlc2V0QnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3QgcHJlc2V0ID0gUHJlc2V0TWFuYWdlci5nZXRQcmVzZXRCeUlkKHNlbGVjdGVkSWQpO1xyXG4gICAgaWYgKHByZXNldCkge1xyXG4gICAgICBPYmplY3QuZW50cmllcyhwcmVzZXQuc2V0dGluZ3MpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlucHV0ID0gZm9ybS5lbGVtZW50cy5uYW1lZEl0ZW0oa2V5KSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGlmIChpbnB1dCkge1xyXG4gICAgICAgICAgaWYgKGlucHV0LnR5cGUgPT09ICdjaGVja2JveCcpIHtcclxuICAgICAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHZhbHVlIGFzIGJvb2xlYW47XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcHJlc2V0TmFtZUlucHV0LnZhbHVlID0gcHJlc2V0Lm5hbWU7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHByZXNldEJ1dHRvbnNEaXYuYXBwZW5kQ2hpbGQoc2F2ZU5ld1ByZXNldEJ0bik7XHJcbiAgcHJlc2V0QnV0dG9uc0Rpdi5hcHBlbmRDaGlsZCh1cGRhdGVQcmVzZXRCdG4pO1xyXG4gIHByZXNldEJ1dHRvbnNEaXYuYXBwZW5kQ2hpbGQoZGVsZXRlUHJlc2V0QnV0dG9uKTtcclxuICBwcmVzZXRCdXR0b25zRGl2LmFwcGVuZENoaWxkKHJlc3RvcmVEZWZhdWx0c0J1dHRvbik7XHJcbiAgcHJlc2V0QnV0dG9uc0Rpdi5hcHBlbmRDaGlsZChzdGF0dXNMYWJlbCk7XHJcblxyXG4gIHByZXNldFNlY3Rpb24uYXBwZW5kQ2hpbGQocHJlc2V0U2VsZWN0KTtcclxuICBwcmVzZXRTZWN0aW9uLmFwcGVuZENoaWxkKHByZXNldE5hbWVJbnB1dCk7XHJcbiAgcHJlc2V0U2VjdGlvbi5hcHBlbmRDaGlsZChwcmVzZXRCdXR0b25zRGl2KTtcclxuICBmb3JtLmFwcGVuZENoaWxkKHByZXNldFNlY3Rpb24pO1xyXG5cclxuICAvLyAtLS0gU2V0dGluZ3MgQ29udGFpbmVyIC0tLVxyXG4gIGNvbnN0IHNldHRpbmdzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgc2V0dGluZ3NDb250YWluZXIuc3R5bGUubWF4SGVpZ2h0ID0gJzQwMHB4JztcclxuICBzZXR0aW5nc0NvbnRhaW5lci5zdHlsZS5vdmVyZmxvd1kgPSAnYXV0byc7XHJcbiAgc2V0dGluZ3NDb250YWluZXIuc3R5bGUucGFkZGluZyA9ICc1cHgnO1xyXG4gIHNldHRpbmdzQ29udGFpbmVyLnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIsICNkZGQpJztcclxuICBzZXR0aW5nc0NvbnRhaW5lci5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnNHB4JztcclxuICBcclxuICBjb25zdCBhZGRJbnB1dCA9IChrZXk6IGtleW9mIExheW91dFNldHRpbmdzLCBsYWJlbDogc3RyaW5nLCB0eXBlOiAnbnVtYmVyJyB8ICdjaGVja2JveCcgPSAnbnVtYmVyJykgPT4ge1xyXG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBkaXYuc3R5bGUuZGlzcGxheSA9ICdncmlkJztcclxuICAgIGRpdi5zdHlsZS5ncmlkVGVtcGxhdGVDb2x1bW5zID0gJzJmciAxZnInO1xyXG4gICAgZGl2LnN0eWxlLmFsaWduSXRlbXMgPSAnY2VudGVyJztcclxuICAgIGRpdi5zdHlsZS5wYWRkaW5nID0gJzVweCAwJztcclxuICAgIGRpdi5zdHlsZS5ib3JkZXJCb3R0b20gPSAnMXB4IHNvbGlkIHZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItYm9yZGVyLCAjZWVlKSc7XHJcbiAgICBcclxuICAgIGNvbnN0IHNjb3BlZElkID0gYCR7a2V5fV8ke1VJRH1gO1xyXG5cclxuICAgIGNvbnN0IGxibCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XHJcbiAgICBsYmwudGV4dENvbnRlbnQgPSBsYWJlbDtcclxuICAgIGxibC5odG1sRm9yID0gc2NvcGVkSWQ7XHJcbiAgICBkaXYuYXBwZW5kQ2hpbGQobGJsKTtcclxuICAgIFxyXG4gICAgaWYgKHR5cGUgPT09ICdjaGVja2JveCcpIHtcclxuICAgICAgICBjb25zdCB0b2dnbGVTd2l0Y2ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xyXG4gICAgICAgIHRvZ2dsZVN3aXRjaC5jbGFzc05hbWUgPSAndG9nZ2xlLXN3aXRjaCc7XHJcbiAgICAgICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG4gICAgICAgIGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xyXG4gICAgICAgIGlucHV0LmNoZWNrZWQgPSAhIWN1cnJlbnRTZXR0aW5nc1trZXldO1xyXG4gICAgICAgIGlucHV0LmlkID0gc2NvcGVkSWQ7XHJcbiAgICAgICAgaW5wdXQubmFtZSA9IGtleTsgXHJcbiAgICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZCgnbW91c2V0cmFwJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3Qgc2xpZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgICAgIHNsaWRlci5jbGFzc05hbWUgPSAnc2xpZGVyJztcclxuICAgICAgICB0b2dnbGVTd2l0Y2guYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG4gICAgICAgIHRvZ2dsZVN3aXRjaC5hcHBlbmRDaGlsZChzbGlkZXIpO1xyXG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZCh0b2dnbGVTd2l0Y2gpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVXNlIHRleHQrZGVjaW1hbCB0byBhbGxvdyBmcmVlIHR5cGluZ1xyXG4gICAgICAgIGlucHV0LnR5cGUgPSAndGV4dCc7IFxyXG4gICAgICAgIGlucHV0LmlucHV0TW9kZSA9ICdkZWNpbWFsJztcclxuICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCdtb3VzZXRyYXAnKTtcclxuXHJcbiAgICAgICAgaW5wdXQudmFsdWUgPSBjdXJyZW50U2V0dGluZ3Nba2V5XT8udG9TdHJpbmcoKSB8fCAnMCc7XHJcbiAgICAgICAgaW5wdXQuaWQgPSBzY29wZWRJZDtcclxuICAgICAgICBpbnB1dC5uYW1lID0ga2V5OyBcclxuICAgICAgICBpbnB1dC5zdHlsZS53aWR0aCA9ICcxMDAlJztcclxuICAgICAgICBpbnB1dC5zdHlsZS5wYWRkaW5nID0gJzRweCc7XHJcbiAgICAgICAgaW5wdXQuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCB2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlciwgI2RkZCknO1xyXG4gICAgICAgIGlucHV0LnN0eWxlLmJvcmRlclJhZGl1cyA9ICc0cHgnO1xyXG5cclxuICAgICAgICAvLyBGSVg6IFN0b3AgQUxMIHByb3BhZ2F0aW9uIHRvIGVuc3VyZSBPYnNpZGlhbiBob3RrZXlzIGRvbid0IHRyaWdnZXJcclxuICAgICAgICBbJ2tleWRvd24nLCAna2V5dXAnLCAna2V5cHJlc3MnXS5mb3JFYWNoKGV2dCA9PiB7XHJcbiAgICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKChlIGFzIEtleWJvYXJkRXZlbnQpLmtleSA9PT0gJ0VzY2FwZScgfHwgKGUgYXMgS2V5Ym9hcmRFdmVudCkua2V5ID09PSAnVGFiJykgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChpbnB1dCk7XHJcbiAgICB9XHJcbiAgICBzZXR0aW5nc0NvbnRhaW5lci5hcHBlbmRDaGlsZChkaXYpO1xyXG4gIH07XHJcblxyXG4gIC8vIEdlbmVyYWwgLyBCYW5kIFNldHRpbmdzXHJcbiAgYWRkSW5wdXQoJ2xpbmVIZWlnaHRNdWx0aXBsaWVyJywgJ0xpbmUgSGVpZ2h0IE11bHRpcGxpZXInKTtcclxuICBhZGRJbnB1dCgnbWluU3RyaXBDb25maWRlbmNlJywgJ01pbiBTdHJpcCBDb25maWRlbmNlJyk7XHJcbiAgYWRkSW5wdXQoJ21pblN0cmlwV2lkdGhQeCcsICdNaW4gU3RyaXAgV2lkdGggKHB4KScpO1xyXG4gIGFkZElucHV0KCdkZWJ1Z1ZhbGlkYXRpb24nLCAnRGVidWcgVmFsaWRhdGlvbicsICdjaGVja2JveCcpO1xyXG4gIGFkZElucHV0KCdtYXhJdGVyTWVyZ2VzJywgJ01heCBJdGVyIE1lcmdlcycpO1xyXG4gIGFkZElucHV0KCdtaW5CYW5kQ29uZmlkZW5jZScsICdNaW4gQmFuZCBDb25maWRlbmNlJyk7XHJcbiAgYWRkSW5wdXQoJ2JhbmRUb3BCb3R0b21UaHJlc2hvbGRNdWx0aXBsaWVyJywgJ0JhbmQgVG9wL0JvdHRvbSBUaHJlc2hvbGQgTXVsdGlwbGllcicpO1xyXG4gIGFkZElucHV0KCdpbmZlcnJlZEJhbmRDb25maWRlbmNlJywgJ0luZmVycmVkIEJhbmQgQ29uZmlkZW5jZScpO1xyXG4gIGFkZElucHV0KCdiYW5kTWVyZ2VHYXBQeCcsICdCYW5kIE1lcmdlIEdhcCAocHgpJyk7XHJcbiAgYWRkSW5wdXQoJ2JhbmRNZXJnZUdhcExpbmVIZWlnaHRNdWx0aXBsaWVyJywgJ0JhbmQgTWVyZ2UgR2FwIExpbmUgSGVpZ2h0IE11bHRpcGxpZXInKTtcclxuICBhZGRJbnB1dCgnbWF4R2FwRnJhY3Rpb25PZlBhZ2VIZWlnaHQnLCAnTWF4IEdhcCBGcmFjdGlvbiBvZiBQYWdlIEhlaWdodCcpO1xyXG4gIGFkZElucHV0KCdtaW5HYXBzRm9yVHJpbScsICdNaW4gR2FwcyBGb3IgVHJpbScpO1xyXG4gIGFkZElucHV0KCd0cmltUGVyY2VudCcsICdUcmltIFBlcmNlbnQnKTtcclxuICBhZGRJbnB1dCgnbGluZUhlaWdodEZyb21BdmdNdWx0aXBsaWVyJywgJ0xpbmUgSGVpZ2h0IEZyb20gQXZnIE11bHRpcGxpZXInKTtcclxuICBhZGRJbnB1dCgnZmxvb3JNdWx0aXBsaWVyJywgJ0Zsb29yIE11bHRpcGxpZXInKTtcclxuICBhZGRJbnB1dCgnbWluT3ZlcmxhcEZyYWNGb3JCYW5kJywgJ01pbiBPdmVybGFwIEZyYWMgRm9yIEJhbmQnKTtcclxuICBhZGRJbnB1dCgnbWluUmVnaW9uV2lkdGgnLCAnTWluIFJlZ2lvbiBXaWR0aCcpO1xyXG4gIGFkZElucHV0KCdjb2x1bW5UaHJlc2hvbGRMaW5lSGVpZ2h0TXVsdGlwbGllcicsICdDb2x1bW4gVGhyZXNob2xkIExpbmUgSGVpZ2h0IE11bHRpcGxpZXInKTtcclxuICBhZGRJbnB1dCgnY29sdW1uVGhyZXNob2xkRmFsbGJhY2snLCAnQ29sdW1uIFRocmVzaG9sZCBGYWxsYmFjaycpO1xyXG5cclxuICAvLyBQYXJhZ3JhcGggTWVyZ2VyIFNldHRpbmdzXHJcbiAgLy8gUGxhY2UgdGhlIEZPUkNFIG92ZXJyaWRlIGF0IHRoZSB0b3Agb2YgdGhpcyBzZWN0aW9uXHJcbiAgYWRkSW5wdXQoJ3BtRm9yY2VMaW5lYXJNZXJnZScsICdcdUQ4M0RcdUREMjUgRm9yY2UgTGluZWFyIE1lcmdlIChJZ25vcmUgQWxsIExheW91dC9TdHlsZXMpJywgJ2NoZWNrYm94Jyk7XHJcblxyXG4gIGFkZElucHV0KCdwbU1pblN0cmlwQ29uZmlkZW5jZVNwbGl0JywgJ1BNIE1pbiBTdHJpcCBDb25maWRlbmNlIFNwbGl0Jyk7XHJcbiAgYWRkSW5wdXQoJ3BtTWluU3RyaXBXaWR0aFB4JywgJ1BNIE1pbiBTdHJpcCBXaWR0aCBQeCAoZm9yIFBNKScpO1xyXG4gIGFkZElucHV0KCdwbU1pblN0cmlwT3ZlcmxhcEZyYWMnLCAnUE0gTWluIFN0cmlwIE92ZXJsYXAgRnJhYycpO1xyXG4gIGFkZElucHV0KCdwbUluaXRpYWxNZXJnZUJhc2VsaW5lVG9sTm9uTWF0aCcsICdQTSBJbml0IE1lcmdlIEJhc2VsaW5lIFRvbCBOb24tTWF0aCcpO1xyXG4gIGFkZElucHV0KCdwbUluaXRpYWxNZXJnZUJhc2VsaW5lVG9sTWF0aCcsICdQTSBJbml0IE1lcmdlIEJhc2VsaW5lIFRvbCBNYXRoJyk7XHJcbiAgYWRkSW5wdXQoJ3BtSW5pdGlhbE1lcmdlS2VyblRvbE5vbk1hdGgnLCAnUE0gSW5pdCBNZXJnZSBLZXJuIFRvbCBOb24tTWF0aCcpO1xyXG4gIGFkZElucHV0KCdwbUluaXRpYWxNZXJnZUtlcm5Ub2xNYXRoJywgJ1BNIEluaXQgTWVyZ2UgS2VybiBUb2wgTWF0aCcpO1xyXG4gIGFkZElucHV0KCdwbUh5cGhlbkNvbnRpbnVhdGlvblRvbCcsICdQTSBIeXBoZW4gQ29udGludWF0aW9uIFRvbCcpO1xyXG4gIGFkZElucHV0KCdwbUluaXRpYWxNZXJnZUFsaWduVG9sTm9uTWF0aCcsICdQTSBJbml0IE1lcmdlIEFsaWduIFRvbCBOb24tTWF0aCcpO1xyXG4gIGFkZElucHV0KCdwbUluaXRpYWxNZXJnZUFsaWduVG9sTWF0aCcsICdQTSBJbml0IE1lcmdlIEFsaWduIFRvbCBNYXRoJyk7XHJcbiAgYWRkSW5wdXQoJ3BtSW5pdGlhbE1lcmdlVmVydGljYWxHYXBNdWx0aXBsaWVyJywgJ1BNIEluaXQgTWVyZ2UgVmVydGljYWwgR2FwIE11bHRpcGxpZXInKTtcclxuICBhZGRJbnB1dCgncG1Jbml0aWFsTWVyZ2VWZXJ0aWNhbEdhcE1heE11bHRpcGxpZXInLCAnUE0gSW5pdCBNZXJnZSBWZXJ0aWNhbCBHYXAgTWF4IE11bHRpcGxpZXInKTtcclxuICBhZGRJbnB1dCgncG1TdGFja2VkTWVyZ2VBbGlnblRvbCcsICdQTSBTdGFja2VkIE1lcmdlIEFsaWduIFRvbCcpO1xyXG4gIGFkZElucHV0KCdwbVN0YWNrZWRNZXJnZU92ZXJsYXBGcmFjJywgJ1BNIFN0YWNrZWQgTWVyZ2UgT3ZlcmxhcCBGcmFjJyk7XHJcbiAgYWRkSW5wdXQoJ3BtU3RhY2tlZE1lcmdlVmVydGljYWxHYXBNdWx0aXBsaWVyJywgJ1BNIFN0YWNrZWQgTWVyZ2UgVmVydGljYWwgR2FwIE11bHRpcGxpZXInKTtcclxuICBhZGRJbnB1dCgncG1TdGFja2VkTWVyZ2VWZXJ0aWNhbEdhcE1heE11bHRpcGxpZXInLCAnUE0gU3RhY2tlZCBNZXJnZSBWZXJ0aWNhbCBHYXAgTWF4IE11bHRpcGxpZXInKTtcclxuICBhZGRJbnB1dCgncG1HZW5lcmFsTWVyZ2VBbGlnblRvbCcsICdQTSBHZW5lcmFsIE1lcmdlIEFsaWduIFRvbCcpO1xyXG4gIGFkZElucHV0KCdwbUdlbmVyYWxNZXJnZU92ZXJsYXBGcmFjJywgJ1BNIEdlbmVyYWwgTWVyZ2UgT3ZlcmxhcCBGcmFjJyk7XHJcbiAgYWRkSW5wdXQoJ3BtR2VuZXJhbE1lcmdlVmVydGljYWxHYXBNdWx0aXBsaWVyJywgJ1BNIEdlbmVyYWwgTWVyZ2UgVmVydGljYWwgR2FwIE11bHRpcGxpZXInKTtcclxuICBhZGRJbnB1dCgncG1HZW5lcmFsTWVyZ2VWZXJ0aWNhbEdhcE1heE11bHRpcGxpZXInLCAnUE0gR2VuZXJhbCBNZXJnZSBWZXJ0aWNhbCBHYXAgTWF4IE11bHRpcGxpZXInKTtcclxuICBhZGRJbnB1dCgncG1OZXN0ZWRNZXJnZU92ZXJsYXBGcmFjJywgJ1BNIE5lc3RlZCBNZXJnZSBPdmVybGFwIEZyYWMnKTtcclxuICBhZGRJbnB1dCgncG1TdGl0Y2hCYXNlbGluZVRvbE5vbk1hdGgnLCAnUE0gU3RpdGNoIEJhc2VsaW5lIFRvbCBOb24tTWF0aCcpO1xyXG4gIGFkZElucHV0KCdwbVN0aXRjaEJhc2VsaW5lVG9sTWF0aCcsICdQTSBTdGl0Y2ggQmFzZWxpbmUgVG9sIE1hdGgnKTtcclxuICBhZGRJbnB1dCgncG1TdGl0Y2hLZXJuVG9sTm9uTWF0aCcsICdQTSBTdGl0Y2ggS2VybiBUb2wgTm9uLU1hdGgnKTtcclxuICBhZGRJbnB1dCgncG1TdGl0Y2hLZXJuVG9sTWF0aCcsICdQTSBTdGl0Y2ggS2VybiBUb2wgTWF0aCcpO1xyXG4gIGFkZElucHV0KCdwbUlubGluZVNwYW5CYXNlbGluZVRvbCcsICdQTSBJbmxpbmUgU3BhbiBCYXNlbGluZSBUb2wnKTtcclxuICBhZGRJbnB1dCgncG1JbmxpbmVTcGFuS2VyblRvbCcsICdQTSBJbmxpbmUgU3BhbiBLZXJuIFRvbCcpO1xyXG4gIGFkZElucHV0KCdwbUlubGluZVNwYW5NYXhXZWlnaHREaWZmJywgJ1BNIElubGluZSBTcGFuIE1heCBXZWlnaHQgRGlmZicpO1xyXG4gIGFkZElucHV0KCdwbUlubGluZVNwYW5BbGxvd01peGVkU3R5bGUnLCAnUE0gSW5saW5lIFNwYW4gQWxsb3cgTWl4ZWQgU3R5bGUnLCAnY2hlY2tib3gnKTtcclxuICBhZGRJbnB1dCgncG1TYW1lQ29sdW1uQ292ZXJhZ2VSYXRpbycsICdQTSBTYW1lIENvbHVtbiBDb3ZlcmFnZSBSYXRpbycpO1xyXG4gIGFkZElucHV0KCdwbU1hdGhNZXJnZUJhc2VsaW5lVG9sJywgJ1BNIE1hdGggTWVyZ2UgQmFzZWxpbmUgVG9sJyk7XHJcbiAgYWRkSW5wdXQoJ3BtTWF0aE1lcmdlSG9yaXpUb2wnLCAnUE0gTWF0aCBNZXJnZSBIb3JpeiBUb2wnKTtcclxuICBhZGRJbnB1dCgncG1NYXRoTWVyZ2VDZW50ZXJUb2wnLCAnUE0gTWF0aCBNZXJnZSBDZW50ZXIgVG9sJyk7XHJcbiAgYWRkSW5wdXQoJ3BtU3BsaXRMaW5lSGVpZ2h0VG9sJywgJ1BNIFNwbGl0IExpbmUgSGVpZ2h0IFRvbCcpO1xyXG4gIGFkZElucHV0KCdwbVNwbGl0Qm91bmRhcnlEZWR1cFRvbCcsICdQTSBTcGxpdCBCb3VuZGFyeSBEZWR1cCBUb2wnKTtcclxuICBhZGRJbnB1dCgncG1TcGxpdEludGVyV29yZEdhcFRvbCcsICdQTSBTcGxpdCBJbnRlciBXb3JkIEdhcCBUb2wnKTtcclxuICBhZGRJbnB1dCgncG1TcGxpdENvbHVtbkdhcFRvbCcsICdQTSBTcGxpdCBDb2x1bW4gR2FwIFRvbCcpO1xyXG5cclxuICBmb3JtLmFwcGVuZENoaWxkKHNldHRpbmdzQ29udGFpbmVyKTtcclxuXHJcbiAgLy8gLS0tIEFjdGlvbiBCdXR0b25zIChCb3R0b20pIC0tLVxyXG4gIGNvbnN0IGJ1dHRvbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIGJ1dHRvbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xyXG4gIGJ1dHRvbkRpdi5zdHlsZS5qdXN0aWZ5Q29udGVudCA9ICdmbGV4LWVuZCc7XHJcbiAgYnV0dG9uRGl2LnN0eWxlLmdhcCA9ICcxMHB4JztcclxuICBidXR0b25EaXYuc3R5bGUubWFyZ2luVG9wID0gJzIwcHgnO1xyXG4gIGJ1dHRvbkRpdi5zdHlsZS5wYWRkaW5nVG9wID0gJzEwcHgnO1xyXG4gIGJ1dHRvbkRpdi5zdHlsZS5ib3JkZXJUb3AgPSAnMXB4IHNvbGlkIHZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItYm9yZGVyLCAjZGRkKSc7XHJcblxyXG4gIGNvbnN0IGNsb3NlRGlhbG9nID0gKCkgPT4ge1xyXG4gICAgICBkaWFsb2cuY2xvc2UoKTtcclxuICAgICAgaWYgKGRvY3VtZW50LmJvZHkuY29udGFpbnMoZGlhbG9nKSkge1xyXG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaWFsb2cpO1xyXG4gICAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgY2FuY2VsQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcbiAgY2FuY2VsQnV0dG9uLnR5cGUgPSAnYnV0dG9uJztcclxuICBjYW5jZWxCdXR0b24udGV4dENvbnRlbnQgPSAnQ2xvc2UnO1xyXG4gIGNhbmNlbEJ1dHRvbi5vbmNsaWNrID0gY2xvc2VEaWFsb2c7XHJcblxyXG4gIGNvbnN0IHNhdmVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcclxuICBzYXZlQnV0dG9uLnR5cGUgPSAnYnV0dG9uJztcclxuICBzYXZlQnV0dG9uLnRleHRDb250ZW50ID0gJ1NhdmUgJiBDbG9zZSc7XHJcbiAgc2F2ZUJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAndmFyKC0taW50ZXJhY3RpdmUtYWNjZW50LCAjMDA3YWNjKSc7XHJcbiAgc2F2ZUJ1dHRvbi5zdHlsZS5jb2xvciA9ICd3aGl0ZSc7XHJcbiAgc2F2ZUJ1dHRvbi5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XHJcbiAgc2F2ZUJ1dHRvbi5zdHlsZS5wYWRkaW5nID0gJzZweCAxMnB4JztcclxuICBzYXZlQnV0dG9uLnN0eWxlLmJvcmRlclJhZGl1cyA9ICc0cHgnO1xyXG4gIHNhdmVCdXR0b24uc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xyXG4gIHNhdmVCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgIGNvbnN0IHMgPSBnZXRDdXJyZW50Rm9ybVZhbHVlcygpO1xyXG4gICAgb25TYXZlKHMpO1xyXG4gICAgY2xvc2VEaWFsb2coKTtcclxuICB9O1xyXG5cclxuICBidXR0b25EaXYuYXBwZW5kQ2hpbGQoY2FuY2VsQnV0dG9uKTtcclxuICBidXR0b25EaXYuYXBwZW5kQ2hpbGQoc2F2ZUJ1dHRvbik7XHJcbiAgZm9ybS5hcHBlbmRDaGlsZChidXR0b25EaXYpO1xyXG4gIGRpYWxvZy5hcHBlbmRDaGlsZChmb3JtKTtcclxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpYWxvZyk7XHJcbiAgZGlhbG9nLnNob3dNb2RhbCgpO1xyXG5cclxuICAvLyBBbGxvdyBcIkVudGVyXCIgdG8gc3VibWl0IHRoZSBtYWluIGZvcm0gKFNhdmUpIGlmIG5vdCBpbiBhIHRleHQgYXJlYVxyXG4gIGRpYWxvZy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpID0+IHtcclxuICAgICAgY29uc3QgaXNJbnB1dCA9IGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgaWYgKGUua2V5ID09PSAnRW50ZXInICYmICFpc0lucHV0ICYmIGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgZS50YXJnZXQudGFnTmFtZSAhPT0gJ1RFWFRBUkVBJykge1xyXG4gICAgICAgICAgaWYgKGUudGFyZ2V0LnRhZ05hbWUgIT09ICdCVVRUT04nKSB7XHJcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgIHNhdmVCdXR0b24uY2xpY2soKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBDbG9zZSBvbiBCYWNrZHJvcCBjbGlja1xyXG4gIGRpYWxvZy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlY3QgPSBkaWFsb2cuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgIGNvbnN0IGlzSW5EaWFsb2cgPSAocmVjdC50b3AgPD0gZS5jbGllbnRZICYmIGUuY2xpZW50WSA8PSByZWN0LnRvcCArIHJlY3QuaGVpZ2h0ICYmXHJcbiAgICAgICAgcmVjdC5sZWZ0IDw9IGUuY2xpZW50WCAmJiBlLmNsaWVudFggPD0gcmVjdC5sZWZ0ICsgcmVjdC53aWR0aCk7XHJcbiAgICAgIGlmICghaXNJbkRpYWxvZykge1xyXG4gICAgICAgICAgY2xvc2VEaWFsb2coKTtcclxuICAgICAgfVxyXG4gIH0pO1xyXG59IiwgIi8vIGxheW91dC1kZXRlY3Rvci50c1xyXG4vLyBMYXlvdXREZXRlY3RvciB3aXRoIGJhbmQtYXdhcmUsIGNvbHVtbi13aXNlIG9yZGVyaW5nIGFuZCBub2lzZS1yZXNpbGllbnQgc3RyaXAgaGFuZGxpbmcuXHJcbi8vIE5vdyBlbmhhbmNlZCB3aXRoIGEgbW9kdWxhciBHcmlkRGV0ZWN0b3IgZm9yIGltcHJvdmVkIGhvcml6b250YWwgZ2FwIGFuZCBncmlkIGRldGVjdGlvbi5cclxuXHJcbmltcG9ydCB7IEdhcERldGVjdG9yLCBHYXBBbmFseXNpcywgVmVydGljYWxTdHJpcCwgSG9yaXpvbnRhbEJhbmQgfSBmcm9tICcuL0dhcERldGVjdG9yJztcclxuaW1wb3J0IHsgR3JpZERldGVjdG9yLCBHcmlkQW5hbHlzaXMgfSBmcm9tICcuL2dyaWQtZGV0ZWN0b3InOyAvLyA8LS0gTkVXOiBJbXBvcnQgR3JpZERldGVjdG9yXHJcbmltcG9ydCB7IFBhcmFncmFwaE1lcmdlciB9IGZyb20gJy4vUGFyYWdyYXBoTWVyZ2VyJztcclxuaW1wb3J0IHsgYnVpbGRTbmFwc2hvdCwgU3BhbkluZm8gfSBmcm9tICcuL1NuYXBzaG90JztcclxuaW1wb3J0IHsgTGF5b3V0U2V0dGluZ3MsIGRlZmF1bHRMYXlvdXRTZXR0aW5ncyB9IGZyb20gJy4vbGF5b3V0LW1vZGFsJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQm91bmRpbmdSZWN0IHtcclxuICBsZWZ0OiBudW1iZXI7XHJcbiAgdG9wOiBudW1iZXI7XHJcbiAgcmlnaHQ6IG51bWJlcjtcclxuICBib3R0b206IG51bWJlcjtcclxuICB3aWR0aDogbnVtYmVyO1xyXG4gIGhlaWdodDogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIExheW91dFJlc3VsdCB7XHJcbiAgcGFyYWdyYXBoczogSFRNTFNwYW5FbGVtZW50W11bXTtcclxuICBjb2x1bW5BbmFseXNpczoge1xyXG4gICAgY29sdW1uczogQm91bmRpbmdSZWN0W107XHJcbiAgICBlZGdlQ29sczogQm91bmRpbmdSZWN0W107XHJcbiAgICBnYXBDb2xzOiBCb3VuZGluZ1JlY3RbXTtcclxuICAgIHZlcnRpY2FsR2FwczogbnVtYmVyW107XHJcbiAgICBob3Jpem9udGFsR2FwczogbnVtYmVyW107XHJcbiAgfTtcclxuICBsYXlvdXRSZWdpb25zPzogQXJyYXk8eyB0b3A6IG51bWJlcjsgYm90dG9tOiBudW1iZXI7IGxlZnQ6IG51bWJlcjsgcmlnaHQ6IG51bWJlciB9PjtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIExheW91dERldGVjdG9yIHtcclxuICBwcml2YXRlIHJlYWRvbmx5IHNldHRpbmdzOiBMYXlvdXRTZXR0aW5ncztcclxuXHJcbiAgcHJpdmF0ZSBnYXBEZXRlY3RvcjogR2FwRGV0ZWN0b3I7XHJcbiAgcHJpdmF0ZSBwYXJhZ3JhcGhNZXJnZXI6IFBhcmFncmFwaE1lcmdlcjtcclxuICBwcml2YXRlIGdyaWREZXRlY3RvcjogR3JpZERldGVjdG9yOyAvLyA8LS0gTkVXOiBBZGQgR3JpZERldGVjdG9yIGluc3RhbmNlXHJcblxyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFBhcnRpYWw8TGF5b3V0U2V0dGluZ3M+ID0ge30pIHtcclxuICAgIHRoaXMuc2V0dGluZ3MgPSB7IC4uLmRlZmF1bHRMYXlvdXRTZXR0aW5ncywgLi4ub3B0aW9ucyB9O1xyXG4gICAgdGhpcy5nYXBEZXRlY3RvciA9IG5ldyBHYXBEZXRlY3RvcigpO1xyXG4gICAgdGhpcy5wYXJhZ3JhcGhNZXJnZXIgPSBuZXcgUGFyYWdyYXBoTWVyZ2VyKHRoaXMuc2V0dGluZ3MpO1xyXG4gICAgdGhpcy5ncmlkRGV0ZWN0b3IgPSBuZXcgR3JpZERldGVjdG9yKCk7IC8vIDwtLSBORVc6IEluaXRpYWxpemUgR3JpZERldGVjdG9yXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlbW92ZUR1cGxpY2F0ZVNwYW5zKHBhcmFncmFwaHM6IEhUTUxTcGFuRWxlbWVudFtdW10sIGluZm9NYXA6IE1hcDxIVE1MU3BhbkVsZW1lbnQsIFNwYW5JbmZvPik6IEhUTUxTcGFuRWxlbWVudFtdW10ge1xyXG4gICAgY29uc3Qgc2VlblNwYW5zID0gbmV3IFNldDxzdHJpbmc+KCk7IC8vIFVzZSBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciBlYWNoIHNwYW5cclxuICAgIGNvbnN0IHVuaXF1ZVBhcmFncmFwaHM6IEhUTUxTcGFuRWxlbWVudFtdW10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHBhcmFncmFwaCBvZiBwYXJhZ3JhcGhzKSB7XHJcbiAgICAgIGNvbnN0IHVuaXF1ZVNwYW5zOiBIVE1MU3BhbkVsZW1lbnRbXSA9IFtdO1xyXG4gICAgICBcclxuICAgICAgZm9yIChjb25zdCBzcGFuIG9mIHBhcmFncmFwaCkge1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBpZGVudGlmaWVyIGJhc2VkIG9uIHBvc2l0aW9uIGFuZCBjb250ZW50IHRvIGhhbmRsZSBzcGFucyB0aGF0IG1pZ2h0IGJlIHRoZSBzYW1lIGVsZW1lbnRcclxuICAgICAgICBjb25zdCByZWN0ID0gaW5mb01hcC5nZXQoc3Bhbik/LnJlY3Q7XHJcbiAgICAgICAgaWYgKCFyZWN0KSB7XHJcbiAgICAgICAgICAvLyBJZiBubyByZWN0IGluZm8sIHVzZSB0aGUgZWxlbWVudCBpdHNlbGYgYXMgaWRlbnRpZmllciAoZmFsbGJhY2spXHJcbiAgICAgICAgICBpZiAoIXNlZW5TcGFucy5oYXMoc3Bhbi5pZCB8fCBzcGFuLnRleHRDb250ZW50IHx8IHNwYW4ub3V0ZXJIVE1MIHx8IHNwYW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9TdHJpbmcoKSkpIHtcclxuICAgICAgICAgICAgc2VlblNwYW5zLmFkZChzcGFuLmlkIHx8IHNwYW4udGV4dENvbnRlbnQgfHwgc3Bhbi5vdXRlckhUTUwgfHwgc3Bhbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgdW5pcXVlU3BhbnMucHVzaChzcGFuKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgdW5pcXVlIGtleSBiYXNlZCBvbiBjb29yZGluYXRlcyBhbmQgY29udGVudFxyXG4gICAgICAgICAgY29uc3Qgc3BhbktleSA9IGAke3JlY3QubGVmdH0tJHtyZWN0LnRvcH0tJHtyZWN0LnJpZ2h0fS0ke3JlY3QuYm90dG9tfS0ke3NwYW4udGV4dENvbnRlbnQgfHwgJyd9LSR7c3Bhbi5pZCB8fCAnJ31gO1xyXG4gICAgICAgICAgaWYgKCFzZWVuU3BhbnMuaGFzKHNwYW5LZXkpKSB7XHJcbiAgICAgICAgICAgIHNlZW5TcGFucy5hZGQoc3BhbktleSk7XHJcbiAgICAgICAgICAgIHVuaXF1ZVNwYW5zLnB1c2goc3Bhbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAodW5pcXVlU3BhbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHVuaXF1ZVBhcmFncmFwaHMucHVzaCh1bmlxdWVTcGFucyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdW5pcXVlUGFyYWdyYXBocztcclxuICB9XHJcblxyXG4gIC8vIEFsdGVybmF0aXZlIG1ldGhvZDogUmVtb3ZlIGR1cGxpY2F0ZXMgd2l0aGluIGVhY2ggcGFyYWdyYXBoIGFuZCBhY3Jvc3MgYWxsIHBhcmFncmFwaHNcclxuICBwcml2YXRlIGRlZHVwbGljYXRlUGFyYWdyYXBocyhwYXJhZ3JhcGhzOiBIVE1MU3BhbkVsZW1lbnRbXVtdKTogSFRNTFNwYW5FbGVtZW50W11bXSB7XHJcbiAgICBjb25zdCBnbG9iYWxTZWVuID0gbmV3IFNldDxIVE1MU3BhbkVsZW1lbnQ+KCk7XHJcbiAgICBjb25zdCB1bmlxdWVQYXJhZ3JhcGhzOiBIVE1MU3BhbkVsZW1lbnRbXVtdID0gW107XHJcblxyXG4gICAgZm9yIChjb25zdCBwYXJhZ3JhcGggb2YgcGFyYWdyYXBocykge1xyXG4gICAgICBjb25zdCBwYXJhZ3JhcGhTZWVuID0gbmV3IFNldDxIVE1MU3BhbkVsZW1lbnQ+KCk7XHJcbiAgICAgIGNvbnN0IHVuaXF1ZVNwYW5zOiBIVE1MU3BhbkVsZW1lbnRbXSA9IFtdO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBzcGFuIG9mIHBhcmFncmFwaCkge1xyXG4gICAgICAgIC8vIENoZWNrIGJvdGggZ2xvYmFsIGFuZCBwYXJhZ3JhcGgtbGV2ZWwgZHVwbGljYXRlc1xyXG4gICAgICAgIGlmICghZ2xvYmFsU2Vlbi5oYXMoc3BhbikgJiYgIXBhcmFncmFwaFNlZW4uaGFzKHNwYW4pKSB7XHJcbiAgICAgICAgICBnbG9iYWxTZWVuLmFkZChzcGFuKTtcclxuICAgICAgICAgIHBhcmFncmFwaFNlZW4uYWRkKHNwYW4pO1xyXG4gICAgICAgICAgdW5pcXVlU3BhbnMucHVzaChzcGFuKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh1bmlxdWVTcGFucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdW5pcXVlUGFyYWdyYXBocy5wdXNoKHVuaXF1ZVNwYW5zKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1bmlxdWVQYXJhZ3JhcGhzO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGRldGVjdExheW91dChzcGFuczogSFRNTFNwYW5FbGVtZW50W10sIHBhZ2VFbGVtZW50OiBIVE1MRWxlbWVudCk6IExheW91dFJlc3VsdCB7XHJcbiAgICBpZiAoIXNwYW5zIHx8ICFBcnJheS5pc0FycmF5KHNwYW5zKSB8fCAhcGFnZUVsZW1lbnQgfHwgIShwYWdlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xyXG4gICAgICB0aGlzLmxvZ0RlYnVnKCdJbnZhbGlkIGlucHV0OyByZXR1cm5pbmcgZW1wdHkgcmVzdWx0Jyk7XHJcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVtcHR5UmVzdWx0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuXHJcbiAgICAvLyAxKSBCdWlsZCBhIG5vcm1hbGl6ZWQgc25hcHNob3QgZm9yIHRoZSBlbnRpcmUgcnVuXHJcbiAgICBjb25zdCBpbmZvTWFwID0gYnVpbGRTbmFwc2hvdChzcGFucyk7XHJcbiAgICBjb25zdCByZWN0cyA9IFsuLi5pbmZvTWFwLnZhbHVlcygpXS5tYXAoaSA9PiBpLnJlY3QpO1xyXG5cclxuICAgIC8vIE5vcm1hbGl6ZSBwYWdlIHJlY3QgYnkgRFBSXHJcbiAgICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xyXG4gICAgY29uc3QgcHIgPSBwYWdlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGNvbnN0IHBhZ2VSZWN0ID0gbmV3IERPTVJlY3QocHIubGVmdCAvIGRwciwgcHIudG9wIC8gZHByLCBwci53aWR0aCAvIGRwciwgcHIuaGVpZ2h0IC8gZHByKTtcclxuXHJcbiAgICAvLyAyKSBJbml0aWFsIHNwYW4tdG8tcGFyYWdyYXBoIGdyb3VwaW5nIChtYXRoLWF3YXJlKVxyXG4gICAgbGV0IHBhcmFncmFwaHMgPSB0aGlzLnBhcmFncmFwaE1lcmdlci5tZXJnZUludG9QYXJhZ3JhcGhzRnJvbUluZm9zKGluZm9NYXApO1xyXG5cclxuICAgIC8vIDMpIEVzdGltYXRlIGxpbmUgaGVpZ2h0IHJvYnVzdGx5ICh3aXRoIGEgZmxvb3IpXHJcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gdGhpcy5lc3RpbWF0ZUxpbmVIZWlnaHRGcm9tSW5mb3MocGFyYWdyYXBocywgaW5mb01hcCwgcGFnZVJlY3QpO1xyXG5cclxuICAgIC8vIDQpIE9yaWdpbmFsIEdhcCBkZXRlY3Rpb25cclxuICAgIGNvbnN0IGdhcEFuYWx5c2lzID0gdGhpcy5nYXBEZXRlY3Rvci5kZXRlY3RHYXBzRnJvbVJlY3RzKHJlY3RzLCBwYWdlUmVjdCk7XHJcblxyXG4gICAgLy8gNC41KSA8LS0gTkVXOiBHcmlkIERldGVjdGlvbiBTdGVwIC0tPlxyXG4gICAgLy8gVXNlIHByb2plY3Rpb24gcHJvZmlsaW5nIHRvIGZpbmQgbWFqb3IgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgd2hpdGVzcGFjZSBndXR0ZXJzLlxyXG4gICAgY29uc3QgZ3JpZEFuYWx5c2lzID0gdGhpcy5ncmlkRGV0ZWN0b3IuZGV0ZWN0R3JpZChyZWN0cywgcGFnZVJlY3QsIGxpbmVIZWlnaHQpO1xyXG4gICAgXHJcbiAgICAvLyBDb252ZXJ0IGRldGVjdGVkIGhvcml6b250YWwgZ3JpZCBsaW5lcyBpbnRvIGhpZ2gtY29uZmlkZW5jZSBIb3Jpem9udGFsQmFuZHMuXHJcbiAgICBjb25zdCBncmlkQmFuZHM6IEhvcml6b250YWxCYW5kW10gPSBbXTtcclxuICAgIGlmIChncmlkQW5hbHlzaXMgJiYgZ3JpZEFuYWx5c2lzLmhvcml6b250YWxMaW5lcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMubG9nRGVidWcoYEdyaWQgZGV0ZWN0b3IgZm91bmQgJHtncmlkQW5hbHlzaXMuaG9yaXpvbnRhbExpbmVzLmxlbmd0aH0gaG9yaXpvbnRhbCBsaW5lcy5gKTtcclxuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGdyaWRBbmFseXNpcy5ob3Jpem9udGFsTGluZXMpIHtcclxuICAgICAgICAvLyBNb2RlbCB0aGUgZ2FwIGl0c2VsZiBhcyBhIFwiYmFuZFwiIHRoYXQgYWN0cyBhcyBhIGJhcnJpZXIuXHJcbiAgICAgICAgLy8gVGhlIGhlaWdodCBpcyBiYXNlZCBvbiBhIGZyYWN0aW9uIG9mIHRoZSBsaW5lIGhlaWdodCB0byBlbnN1cmUgaXQncyBub3QgdG9vIHRoaWNrLlxyXG4gICAgICAgIGNvbnN0IGdhcEhlaWdodCA9IGxpbmVIZWlnaHQgKiAodGhpcy5zZXR0aW5ncy5iYW5kTWVyZ2VHYXBMaW5lSGVpZ2h0TXVsdGlwbGllciB8fCAxKTtcclxuICAgICAgICBncmlkQmFuZHMucHVzaCh7XHJcbiAgICAgICAgICB5OiBsaW5lLnBvc2l0aW9uIC0gZ2FwSGVpZ2h0IC8gMixcclxuICAgICAgICAgIGhlaWdodDogZ2FwSGVpZ2h0LFxyXG4gICAgICAgICAgY29uZmlkZW5jZTogMC45NSwgLy8gQXNzaWduIGEgdmVyeSBoaWdoIGNvbmZpZGVuY2UgdG8gcmVzcGVjdCB0aGVzZSBnYXBzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gRmlsdGVyIHZlcnRpY2FsIHN0cmlwcyBmcm9tIHRoZSBvcmlnaW5hbCBnYXAgZGV0ZWN0b3IgKG5vaXNlIHJlc2lsaWVuY2UpXHJcbiAgICBjb25zdCB2ZXJ0aWNhbFN0cmlwc0FsbDogVmVydGljYWxTdHJpcFtdID0gZ2FwQW5hbHlzaXMudmVydGljYWxTdHJpcHMgfHwgW107XHJcbiAgICBjb25zdCB2ZXJ0aWNhbFN0cmlwczogVmVydGljYWxTdHJpcFtdID0gdmVydGljYWxTdHJpcHNBbGxcclxuICAgICAgLmZpbHRlcihzID0+IHMuY29uZmlkZW5jZSA+PSB0aGlzLnNldHRpbmdzLm1pblN0cmlwQ29uZmlkZW5jZSAmJiAocy5yaWdodCAtIHMubGVmdCkgPj0gdGhpcy5zZXR0aW5ncy5taW5TdHJpcFdpZHRoUHgpXHJcbiAgICAgIC5zb3J0KChhLCBiKSA9PiAoKGEubGVmdCArIGEucmlnaHQpIC8gMikgLSAoKGIubGVmdCArIGIucmlnaHQpIC8gMikpO1xyXG5cclxuICAgIC8vIENvbWJpbmUgYmFuZHMgZnJvbSB0aGUgb3JpZ2luYWwgZGV0ZWN0b3IgYW5kIHRoZSBuZXcgZ3JpZCBkZXRlY3RvclxyXG4gICAgY29uc3QgaG9yaXpvbnRhbEJhbmRzUmF3OiBIb3Jpem9udGFsQmFuZFtdID0gKGdhcEFuYWx5c2lzLmhvcml6b250YWxCYW5kcyB8fCBbXSlcclxuICAgICAgICAuZmlsdGVyKGIgPT4gYi5jb25maWRlbmNlID49IHRoaXMuc2V0dGluZ3MubWluQmFuZENvbmZpZGVuY2UpO1xyXG4gICAgY29uc3QgY29tYmluZWRCYW5kcyA9IFsuLi5ob3Jpem9udGFsQmFuZHNSYXcsIC4uLmdyaWRCYW5kc107XHJcblxyXG4gICAgLy8gQnVpbGQgcm9idXN0IGhvcml6b250YWwgYmFuZHM6IHVuaW9uIG9mIHJhdyBiYW5kcywgZ3JpZCBiYW5kcywgYW5kIGluZmVycmVkIGJhbmRzIGZyb20gc3RyaXBzXHJcbiAgICBjb25zdCBsYXlvdXRCYW5kcyA9IHRoaXMuYnVpbGRMYXlvdXRCYW5kcyhjb21iaW5lZEJhbmRzLCB2ZXJ0aWNhbFN0cmlwcywgcGFnZVJlY3QsIGxpbmVIZWlnaHQpO1xyXG5cclxuICAgIGlmICh0aGlzLnNldHRpbmdzLmRlYnVnVmFsaWRhdGlvbikge1xyXG4gICAgICBjb25zdCBmaWx0ZXJlZE91dCA9IHZlcnRpY2FsU3RyaXBzQWxsLmxlbmd0aCAtIHZlcnRpY2FsU3RyaXBzLmxlbmd0aDtcclxuICAgICAgdGhpcy5sb2dEZWJ1ZyhgU3RyaXBzIGtlcHQ9JHt2ZXJ0aWNhbFN0cmlwcy5sZW5ndGh9LCBmaWx0ZXJlZD0ke2ZpbHRlcmVkT3V0fSwgYmFuZHM9JHtsYXlvdXRCYW5kcy5sZW5ndGh9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gNSkgVmFsaWRhdGUgcGFyYWdyYXBocyBhZ2FpbnN0IHZlcnRpY2FsIHN0cmlwc1xyXG4gICAgcGFyYWdyYXBocyA9IHRoaXMucGFyYWdyYXBoTWVyZ2VyLnZhbGlkYXRlUGFyYWdyYXBoc0FnYWluc3RTdHJpcHNGcm9tSW5mb3MoXHJcbiAgICAgIHBhcmFncmFwaHMsXHJcbiAgICAgIGluZm9NYXAsXHJcbiAgICAgIHZlcnRpY2FsU3RyaXBzXHJcbiAgICApO1xyXG5cclxuICAgIC8vIDYpIE1lcmdlIHZlcnRpY2FsbHkgc3RhY2tlZCBwYXJhZ3JhcGhzIHdpdGhpbiBzYW1lIGNvbHVtblxyXG4gICAgcGFyYWdyYXBocyA9IHRoaXMucGFyYWdyYXBoTWVyZ2VyLm1lcmdlUGFyYWdyYXBoc0Zyb21JbmZvcyhcclxuICAgICAgcGFyYWdyYXBocyxcclxuICAgICAgaW5mb01hcCxcclxuICAgICAgbGluZUhlaWdodCxcclxuICAgICAgdmVydGljYWxTdHJpcHMsXHJcbiAgICAgIGxheW91dEJhbmRzXHJcbiAgICApO1xyXG5cclxuICAgIC8vIDcpIEl0ZXJhdGl2ZSBuZXN0ZWQgbWVyZ2UgbG9vcCB3aXRoIHBvc3QtbWVyZ2UgdmFsaWRhdGlvblxyXG4gICAgbGV0IGd1YXJkID0gMDtcclxuICAgIHdoaWxlIChndWFyZCsrIDwgdGhpcy5zZXR0aW5ncy5tYXhJdGVyTWVyZ2VzKSB7XHJcbiAgICAgIGNvbnN0IHsgcGFyYWdyYXBoczogbWVyZ2VkT25jZSwgY2hhbmdlZCB9ID0gdGhpcy5wYXJhZ3JhcGhNZXJnZXIubWVyZ2VOZXN0ZWRQYXJhZ3JhcGhzT25jZUZyb21JbmZvcyhcclxuICAgICAgICBwYXJhZ3JhcGhzLFxyXG4gICAgICAgIGluZm9NYXAsXHJcbiAgICAgICAgdmVydGljYWxTdHJpcHMsXHJcbiAgICAgICAgbGF5b3V0QmFuZHNcclxuICAgICAgKTtcclxuICAgICAgcGFyYWdyYXBocyA9IG1lcmdlZE9uY2U7XHJcbiAgICAgIGlmICghY2hhbmdlZCkgYnJlYWs7XHJcblxyXG4gICAgICBwYXJhZ3JhcGhzID0gdGhpcy5wYXJhZ3JhcGhNZXJnZXIudmFsaWRhdGVQYXJhZ3JhcGhzQWdhaW5zdFN0cmlwc0Zyb21JbmZvcyhcclxuICAgICAgICBwYXJhZ3JhcGhzLFxyXG4gICAgICAgIGluZm9NYXAsXHJcbiAgICAgICAgdmVydGljYWxTdHJpcHNcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHBhcmFncmFwaHMgPSB0aGlzLnBhcmFncmFwaE1lcmdlci5tZXJnZVBhcmFncmFwaHNGcm9tSW5mb3MoXHJcbiAgICAgICAgcGFyYWdyYXBocyxcclxuICAgICAgICBpbmZvTWFwLFxyXG4gICAgICAgIGxpbmVIZWlnaHQsXHJcbiAgICAgICAgdmVydGljYWxTdHJpcHMsXHJcbiAgICAgICAgbGF5b3V0QmFuZHNcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyA3LjUpIEZpbmFsIHN0YWNrZWQtY29sdW1uIHBhc3MgdG8gY2F0Y2ggcmVzaWR1YWwgY29sdW1uLWFsaWduZWQgc3BsaXRzXHJcbiAgICBwYXJhZ3JhcGhzID0gdGhpcy5wYXJhZ3JhcGhNZXJnZXIubWVyZ2VTdGFja2VkQ29sdW1uUGFyYWdyYXBoc0Zyb21JbmZvcyhcclxuICAgICAgcGFyYWdyYXBocyxcclxuICAgICAgaW5mb01hcCxcclxuICAgICAgbGluZUhlaWdodCxcclxuICAgICAgdmVydGljYWxTdHJpcHMsXHJcbiAgICAgIGxheW91dEJhbmRzXHJcbiAgICApO1xyXG5cclxuICAgIC8vIDgpIE9wdGlvbmFsIGZpbmFsIGlubGluZS1saWdhdHVyZSBzdGl0Y2hpbmdcclxuICAgIHBhcmFncmFwaHMgPSB0aGlzLnBhcmFncmFwaE1lcmdlci5zdGl0Y2hJbmxpbmVMaWdhdHVyZXNGcm9tSW5mb3MocGFyYWdyYXBocywgaW5mb01hcCk7XHJcblxyXG4gICAgLy8gOC41KSBCYW5kLWF3YXJlLCBjb2x1bW4td2lzZSBvcmRlcmluZyB0byBhdm9pZCBpbnRlcmxlYXZpbmcgd2hlbiBjb2x1bW4gY291bnQgY2hhbmdlcyB2ZXJ0aWNhbGx5XHJcbiAgICBpZiAobGF5b3V0QmFuZHMubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IHBlckJhbmRDb2x1bW5SZWdpb25zID0gdGhpcy5idWlsZFBlckJhbmRDb2x1bW5SZWdpb25zKHZlcnRpY2FsU3RyaXBzLCBwYWdlUmVjdCwgbGF5b3V0QmFuZHMpO1xyXG4gICAgICBwYXJhZ3JhcGhzID0gcGFyYWdyYXBocy5tYXAocGFyYSA9PlxyXG4gICAgICAgIHRoaXMub3JkZXJQYXJhZ3JhcGhCeUJhbmRzQW5kQ29sdW1ucyhwYXJhLCBpbmZvTWFwLCBsYXlvdXRCYW5kcywgcGVyQmFuZENvbHVtblJlZ2lvbnMpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gOSkgRGV0ZXJtaW5pc3RpYyBvcmRlciBvZiBzcGFucyB3aXRoaW4gcGFyYWdyYXBoc1xyXG4gICAgcGFyYWdyYXBocyA9IHBhcmFncmFwaHMubWFwKHBhcmEgPT5cclxuICAgICAgWy4uLnBhcmFdLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICBjb25zdCByYSA9IGluZm9NYXAuZ2V0KGEpIS5yZWN0O1xyXG4gICAgICAgIGNvbnN0IHJiID0gaW5mb01hcC5nZXQoYikhLnJlY3Q7XHJcbiAgICAgICAgcmV0dXJuIHJhLnRvcCAtIHJiLnRvcCB8fCByYS5sZWZ0IC0gcmIubGVmdDtcclxuICAgICAgfSlcclxuICAgICk7XHJcblxyXG4gICAgLy8gOS41KSBSZW1vdmUgZHVwbGljYXRlIHNwYW5zIHRvIHByZXZlbnQgZHVwbGljYXRlcyBhY3Jvc3MgcGFyYWdyYXBoc1xyXG4gICAgcGFyYWdyYXBocyA9IHRoaXMuZGVkdXBsaWNhdGVQYXJhZ3JhcGhzKHBhcmFncmFwaHMpO1xyXG5cclxuICAgIC8vIDEwKSBCdWlsZCBjb2x1bW4gYW5hbHlzaXMgKGJhY2stY29tcGF0KVxyXG4gICAgY29uc3QgY29sdW1uQW5hbHlzaXMgPSB0aGlzLmFuYWx5emVDb2x1bW5zKHBhcmFncmFwaHMsIGluZm9NYXAsIHBhZ2VSZWN0KTtcclxuXHJcbiAgICB0aGlzLmxvZ0RlYnVnKFxyXG4gICAgICBgTGF5b3V0IGRldGVjdGlvbiBkb25lIGluICR7KHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpLnRvRml4ZWQoMil9bXNgLFxyXG4gICAgICB7IHBhcmFncmFwaHM6IHBhcmFncmFwaHMubGVuZ3RoLCBjb2x1bW5zOiBjb2x1bW5BbmFseXNpcy5jb2x1bW5zLmxlbmd0aCB9XHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB7IHBhcmFncmFwaHMsIGNvbHVtbkFuYWx5c2lzLCBsYXlvdXRSZWdpb25zOiBnYXBBbmFseXNpcy5sYXlvdXRTZWdtZW50cyB9O1xyXG4gIH1cclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyBOZXcgQ29sdW1uIEFuYWx5c2lzIEltcGxlbWVudGF0aW9uICh1bmNoYW5nZWQpXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgcHJpdmF0ZSBhdmVyYWdlID0gKGFycjogbnVtYmVyW10pOiBudW1iZXIgPT4gXHJcbiAgICBhcnIucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBhcnIubGVuZ3RoIHx8IDA7XHJcblxyXG4gIHByaXZhdGUgZ2V0QXZlcmFnZUxpbmVIZWlnaHQoXHJcbiAgICBwYXJhZ3JhcGhzOiBIVE1MU3BhbkVsZW1lbnRbXVtdLFxyXG4gICAgaW5mb01hcDogTWFwPEhUTUxTcGFuRWxlbWVudCwgU3BhbkluZm8+XHJcbiAgKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IGxpbmVIZWlnaHRzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBwIG9mIHBhcmFncmFwaHMpIHtcclxuICAgICAgZm9yIChjb25zdCBzcGFuIG9mIHApIHtcclxuICAgICAgICBjb25zdCBpbmZvID0gaW5mb01hcC5nZXQoc3Bhbik7XHJcbiAgICAgICAgaWYgKGluZm8pIHtcclxuICAgICAgICAgIGxpbmVIZWlnaHRzLnB1c2goaW5mby5yZWN0LmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5hdmVyYWdlKGxpbmVIZWlnaHRzKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYW5hbHl6ZUNvbHVtbnMoXHJcbiAgICBwYXJhZ3JhcGhzOiBIVE1MU3BhbkVsZW1lbnRbXVtdLFxyXG4gICAgaW5mb01hcDogTWFwPEhUTUxTcGFuRWxlbWVudCwgU3BhbkluZm8+LFxyXG4gICAgcGFnZVJlY3Q6IERPTVJlY3RcclxuICApOiBMYXlvdXRSZXN1bHRbJ2NvbHVtbkFuYWx5c2lzJ10ge1xyXG4gICAgY29uc3QgYWxsU3BhbnMgPSBwYXJhZ3JhcGhzLmZsYXQoKTtcclxuXHJcbiAgICBpZiAoYWxsU3BhbnMubGVuZ3RoIDwgMikge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbHVtbnM6IFt7XHJcbiAgICAgICAgICBsZWZ0OiBwYWdlUmVjdC5sZWZ0LCB0b3A6IHBhZ2VSZWN0LnRvcCwgcmlnaHQ6IHBhZ2VSZWN0LnJpZ2h0LCBib3R0b206IHBhZ2VSZWN0LmJvdHRvbSxcclxuICAgICAgICAgIHdpZHRoOiBwYWdlUmVjdC53aWR0aCwgaGVpZ2h0OiBwYWdlUmVjdC5oZWlnaHRcclxuICAgICAgICB9XSxcclxuICAgICAgICBlZGdlQ29sczogW10sIGdhcENvbHM6IFtdLCB2ZXJ0aWNhbEdhcHM6IFtdLCBob3Jpem9udGFsR2FwczogW11cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhdmdMaW5lSGVpZ2h0ID0gdGhpcy5nZXRBdmVyYWdlTGluZUhlaWdodChwYXJhZ3JhcGhzLCBpbmZvTWFwKTtcclxuICAgIGNvbnN0IGNvbHVtblRocmVzaG9sZCA9IGF2Z0xpbmVIZWlnaHQgPiAwID8gYXZnTGluZUhlaWdodCAqIHRoaXMuc2V0dGluZ3MuY29sdW1uVGhyZXNob2xkTGluZUhlaWdodE11bHRpcGxpZXIgOiB0aGlzLnNldHRpbmdzLmNvbHVtblRocmVzaG9sZEZhbGxiYWNrO1xyXG5cclxuICAgIGNvbnN0IHNvcnRlZEJ5WCA9IFsuLi5hbGxTcGFuc10uc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICBjb25zdCByZWN0QSA9IGluZm9NYXAuZ2V0KGEpPy5yZWN0O1xyXG4gICAgICBjb25zdCByZWN0QiA9IGluZm9NYXAuZ2V0KGIpPy5yZWN0O1xyXG4gICAgICBpZiAoIXJlY3RBIHx8ICFyZWN0QikgcmV0dXJuIDA7XHJcbiAgICAgIHJldHVybiByZWN0QS5sZWZ0IC0gcmVjdEIubGVmdDtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGNvbHVtbnM6IEhUTUxTcGFuRWxlbWVudFtdW10gPSBbXTtcclxuICAgIGlmIChzb3J0ZWRCeVgubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb2x1bW5zLnB1c2goW3NvcnRlZEJ5WFswXV0pO1xyXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNvcnRlZEJ5WC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTcGFuID0gc29ydGVkQnlYW2ldO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRSZWN0ID0gaW5mb01hcC5nZXQoY3VycmVudFNwYW4pPy5yZWN0O1xyXG4gICAgICAgIGlmICghY3VycmVudFJlY3QpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBjb25zdCBsYXN0Q29sdW1uID0gY29sdW1uc1tjb2x1bW5zLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIGNvbnN0IGxhc3RTcGFuSW5Db2x1bW4gPSBsYXN0Q29sdW1uW2xhc3RDb2x1bW4ubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgY29uc3QgbGFzdFJlY3QgPSBpbmZvTWFwLmdldChsYXN0U3BhbkluQ29sdW1uKT8ucmVjdDtcclxuICAgICAgICBpZiAoIWxhc3RSZWN0KSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGN1cnJlbnRSZWN0LmxlZnQgLSBsYXN0UmVjdC5sZWZ0KSA8IGNvbHVtblRocmVzaG9sZCkge1xyXG4gICAgICAgICAgbGFzdENvbHVtbi5wdXNoKGN1cnJlbnRTcGFuKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29sdW1ucy5wdXNoKFtjdXJyZW50U3Bhbl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvbHVtblJlY3RzOiBCb3VuZGluZ1JlY3RbXSA9IGNvbHVtbnMubWFwKGNvbHVtbiA9PiB7XHJcbiAgICAgIGxldCBsZWZ0ID0gSW5maW5pdHksIHRvcCA9IEluZmluaXR5LCByaWdodCA9IC1JbmZpbml0eSwgYm90dG9tID0gLUluZmluaXR5O1xyXG4gICAgICBmb3IgKGNvbnN0IHNwYW4gb2YgY29sdW1uKSB7XHJcbiAgICAgICAgY29uc3QgcmVjdCA9IGluZm9NYXAuZ2V0KHNwYW4pPy5yZWN0O1xyXG4gICAgICAgIGlmIChyZWN0KSB7XHJcbiAgICAgICAgICBsZWZ0ID0gTWF0aC5taW4obGVmdCwgcmVjdC5sZWZ0KTtcclxuICAgICAgICAgIHRvcCA9IE1hdGgubWluKHRvcCwgcmVjdC50b3ApO1xyXG4gICAgICAgICAgcmlnaHQgPSBNYXRoLm1heChyaWdodCwgcmVjdC5yaWdodCk7XHJcbiAgICAgICAgICBib3R0b20gPSBNYXRoLm1heChib3R0b20sIHJlY3QuYm90dG9tKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGxlZnQgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGxlZnQ6IHBhZ2VSZWN0LmxlZnQsIHRvcDogcGFnZVJlY3QudG9wLCByaWdodDogcGFnZVJlY3QucmlnaHQsIGJvdHRvbTogcGFnZVJlY3QuYm90dG9tLFxyXG4gICAgICAgICAgd2lkdGg6IHBhZ2VSZWN0LndpZHRoLCBoZWlnaHQ6IHBhZ2VSZWN0LmhlaWdodFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHsgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tLCB3aWR0aDogcmlnaHQgLSBsZWZ0LCBoZWlnaHQ6IGJvdHRvbSAtIHRvcCB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgZWRnZUNvbHMgPSBjb2x1bW5SZWN0cy5sZW5ndGggPyBbY29sdW1uUmVjdHNbMF0sIGNvbHVtblJlY3RzW2NvbHVtblJlY3RzLmxlbmd0aCAtIDFdXSA6IFtdO1xyXG4gICAgY29uc3QgZ2FwQ29scyA9IGNvbHVtblJlY3RzLnNsaWNlKDEsIC0xKTtcclxuICAgIGNvbnN0IHZlcnRpY2FsR2FwczogbnVtYmVyW10gPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY29sdW1uUmVjdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmVydGljYWxHYXBzLnB1c2goKGNvbHVtblJlY3RzW2ldLmxlZnQgKyBjb2x1bW5SZWN0c1tpLTFdLnJpZ2h0KSAvIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IGNvbHVtbnM6IGNvbHVtblJlY3RzLCBlZGdlQ29scywgZ2FwQ29scywgdmVydGljYWxHYXBzLCBob3Jpem9udGFsR2FwczogW10gfTtcclxuICB9XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gRXhpc3RpbmcgSGVscGVycyAodW5jaGFuZ2VkKVxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIHByaXZhdGUgZXN0aW1hdGVMaW5lSGVpZ2h0RnJvbUluZm9zKFxyXG4gICAgcGFyYWdyYXBoczogSFRNTFNwYW5FbGVtZW50W11bXSxcclxuICAgIGluZm9NYXA6IE1hcDxIVE1MU3BhbkVsZW1lbnQsIFNwYW5JbmZvPixcclxuICAgIHBhZ2VSZWN0OiBET01SZWN0XHJcbiAgKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IGdhcHM6IG51bWJlcltdID0gW107XHJcbiAgICBmb3IgKGNvbnN0IHAgb2YgcGFyYWdyYXBocykge1xyXG4gICAgICBpZiAocC5sZW5ndGggPCAyKSBjb250aW51ZTtcclxuICAgICAgY29uc3QgbGluZXMgPSBbLi4ucF0ubWFwKHMgPT4gaW5mb01hcC5nZXQocykhLnJlY3QpLnNvcnQoKGEsIGIpID0+IGEudG9wIC0gYi50b3ApO1xyXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZ2FwID0gbGluZXNbaV0udG9wIC0gbGluZXNbaSAtIDFdLmJvdHRvbTtcclxuICAgICAgICBpZiAoZ2FwID4gMCAmJiBnYXAgPCBwYWdlUmVjdC5oZWlnaHQgKiB0aGlzLnNldHRpbmdzLm1heEdhcEZyYWN0aW9uT2ZQYWdlSGVpZ2h0KSBnYXBzLnB1c2goZ2FwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBsaEZyb21HYXBzOiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICBpZiAoZ2Fwcy5sZW5ndGggPj0gdGhpcy5zZXR0aW5ncy5taW5HYXBzRm9yVHJpbSkge1xyXG4gICAgICBnYXBzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcclxuICAgICAgY29uc3QgdHJpbSA9IE1hdGguZmxvb3IoZ2Fwcy5sZW5ndGggKiB0aGlzLnNldHRpbmdzLnRyaW1QZXJjZW50KTtcclxuICAgICAgY29uc3QgdHJpbW1lZCA9IGdhcHMuc2xpY2UodHJpbSwgZ2Fwcy5sZW5ndGggLSB0cmltKTtcclxuICAgICAgaWYgKHRyaW1tZWQubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgYXZnID0gdHJpbW1lZC5yZWR1Y2UoKHMsIHYpID0+IHMgKyB2LCAwKSAvIHRyaW1tZWQubGVuZ3RoO1xyXG4gICAgICAgIGxoRnJvbUdhcHMgPSBhdmcgKiB0aGlzLnNldHRpbmdzLmxpbmVIZWlnaHRGcm9tQXZnTXVsdGlwbGllcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGZvbnRTaXplcyA9IFsuLi5pbmZvTWFwLnZhbHVlcygpXS5tYXAoaSA9PiBpLnN0eWxlLmZvbnRTaXplKS5maWx0ZXIodiA9PiB2ID4gMCk7XHJcbiAgICBpZiAoIWZvbnRTaXplcy5sZW5ndGgpIHJldHVybiAxNjtcclxuICAgIGZvbnRTaXplcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcbiAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKGZvbnRTaXplcy5sZW5ndGggLyAyKTtcclxuICAgIGNvbnN0IG1lZGlhbiA9IGZvbnRTaXplcy5sZW5ndGggJSAyID8gZm9udFNpemVzW21pZF0gOiAoZm9udFNpemVzW21pZCAtIDFdICsgZm9udFNpemVzW21pZF0pIC8gMjtcclxuXHJcbiAgICBjb25zdCBmbG9vciA9IG1lZGlhbiAqIHRoaXMuc2V0dGluZ3MubGluZUhlaWdodE11bHRpcGxpZXIgKiB0aGlzLnNldHRpbmdzLmZsb29yTXVsdGlwbGllcjtcclxuICAgIGNvbnN0IGNob3NlbiA9IE1hdGgubWF4KGxoRnJvbUdhcHMgPz8gMCwgZmxvb3IpO1xyXG4gICAgcmV0dXJuIGNob3NlbiB8fCBtZWRpYW4gKiB0aGlzLnNldHRpbmdzLmxpbmVIZWlnaHRNdWx0aXBsaWVyO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBidWlsZExheW91dEJhbmRzKFxyXG4gICAgYmFuZHM6IEhvcml6b250YWxCYW5kW10sXHJcbiAgICBzdHJpcHM6IFZlcnRpY2FsU3RyaXBbXSxcclxuICAgIHBhZ2VSZWN0OiBET01SZWN0LFxyXG4gICAgbGluZUhlaWdodDogbnVtYmVyXHJcbiAgKTogSG9yaXpvbnRhbEJhbmRbXSB7XHJcbiAgICBjb25zdCBvdXQ6IEhvcml6b250YWxCYW5kW10gPSBbXTtcclxuXHJcbiAgICAvLyBTdGFydCB3aXRoIGdpdmVuIGJhbmRzIChub3cgaW5jbHVkZXMgZ3JpZCBiYW5kcylcclxuICAgIGZvciAoY29uc3QgYiBvZiBiYW5kcykgb3V0LnB1c2goeyAuLi5iIH0pO1xyXG5cclxuICAgIC8vIEluZmVyIGJhbmRzIGZyb20gdmVydGljYWwgc3RyaXBzOiBkZXRlY3QgdG9wIGFuZCBib3R0b20gZXh0ZW50cyBvZiBzdHJpcCBjbHVzdGVyc1xyXG4gICAgaWYgKHN0cmlwcy5sZW5ndGgpIHtcclxuICAgICAgbGV0IG1pblRvcCA9IEluZmluaXR5LCBtYXhCb3R0b20gPSAtSW5maW5pdHk7XHJcbiAgICAgIGZvciAoY29uc3QgcyBvZiBzdHJpcHMpIHtcclxuICAgICAgICBtaW5Ub3AgPSBNYXRoLm1pbihtaW5Ub3AsIHMudG9wKTtcclxuICAgICAgICBtYXhCb3R0b20gPSBNYXRoLm1heChtYXhCb3R0b20sIHMuYm90dG9tKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobWluVG9wID4gcGFnZVJlY3QudG9wICsgbGluZUhlaWdodCAqIHRoaXMuc2V0dGluZ3MuYmFuZFRvcEJvdHRvbVRocmVzaG9sZE11bHRpcGxpZXIpIHtcclxuICAgICAgICBvdXQucHVzaCh7IHk6IHBhZ2VSZWN0LnRvcCwgaGVpZ2h0OiBtaW5Ub3AgLSBwYWdlUmVjdC50b3AsIGNvbmZpZGVuY2U6IHRoaXMuc2V0dGluZ3MuaW5mZXJyZWRCYW5kQ29uZmlkZW5jZSB9KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobWF4Qm90dG9tIDwgcGFnZVJlY3QuYm90dG9tIC0gbGluZUhlaWdodCAqIHRoaXMuc2V0dGluZ3MuYmFuZFRvcEJvdHRvbVRocmVzaG9sZE11bHRpcGxpZXIpIHtcclxuICAgICAgICBvdXQucHVzaCh7IHk6IG1heEJvdHRvbSwgaGVpZ2h0OiBwYWdlUmVjdC5ib3R0b20gLSBtYXhCb3R0b20sIGNvbmZpZGVuY2U6IHRoaXMuc2V0dGluZ3MuaW5mZXJyZWRCYW5kQ29uZmlkZW5jZSB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE1lcmdlIG92ZXJsYXBwaW5nL2FkamFjZW50IGJhbmRzXHJcbiAgICBvdXQuc29ydCgoYSwgYikgPT4gYS55IC0gYi55KTtcclxuICAgIGNvbnN0IG1lcmdlZDogSG9yaXpvbnRhbEJhbmRbXSA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBiIG9mIG91dCkge1xyXG4gICAgICBpZiAoIW1lcmdlZC5sZW5ndGgpIHsgbWVyZ2VkLnB1c2goeyAuLi5iIH0pOyBjb250aW51ZTsgfVxyXG4gICAgICBjb25zdCBsYXN0ID0gbWVyZ2VkW21lcmdlZC5sZW5ndGggLSAxXTtcclxuICAgICAgY29uc3QgbGFzdEJvdHRvbSA9IGxhc3QueSArIGxhc3QuaGVpZ2h0O1xyXG4gICAgICBpZiAoYi55IDw9IGxhc3RCb3R0b20gKyBNYXRoLm1heCh0aGlzLnNldHRpbmdzLmJhbmRNZXJnZUdhcFB4LCBsaW5lSGVpZ2h0ICogdGhpcy5zZXR0aW5ncy5iYW5kTWVyZ2VHYXBMaW5lSGVpZ2h0TXVsdGlwbGllcikpIHtcclxuICAgICAgICBjb25zdCBuZXdCb3R0b20gPSBNYXRoLm1heChsYXN0Qm90dG9tLCBiLnkgKyBiLmhlaWdodCk7XHJcbiAgICAgICAgbGFzdC5oZWlnaHQgPSBuZXdCb3R0b20gLSBsYXN0Lnk7XHJcbiAgICAgICAgbGFzdC5jb25maWRlbmNlID0gTWF0aC5tYXgobGFzdC5jb25maWRlbmNlLCBiLmNvbmZpZGVuY2UpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1lcmdlZC5wdXNoKHsgLi4uYiB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lcmdlZDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYnVpbGRQZXJCYW5kQ29sdW1uUmVnaW9ucyhcclxuICAgIHN0cmlwczogVmVydGljYWxTdHJpcFtdLFxyXG4gICAgcGFnZVJlY3Q6IERPTVJlY3QsXHJcbiAgICBiYW5kczogSG9yaXpvbnRhbEJhbmRbXVxyXG4gICk6IEFycmF5PHsgYmFuZDogeyB0b3A6IG51bWJlcjsgYm90dG9tOiBudW1iZXIgfSwgcmVnaW9uczogQXJyYXk8eyBsZWZ0OiBudW1iZXI7IHJpZ2h0OiBudW1iZXIgfT4gfT4ge1xyXG4gICAgY29uc3QgcmVzdWx0czogQXJyYXk8eyBiYW5kOiB7IHRvcDogbnVtYmVyOyBib3R0b206IG51bWJlciB9LCByZWdpb25zOiBBcnJheTx7IGxlZnQ6IG51bWJlcjsgcmlnaHQ6IG51bWJlciB9PiB9PiA9IFtdO1xyXG5cclxuICAgIGZvciAoY29uc3QgYmFuZCBvZiBiYW5kcykge1xyXG4gICAgICBjb25zdCB0b3AgPSBiYW5kLnk7XHJcbiAgICAgIGNvbnN0IGJvdHRvbSA9IGJhbmQueSArIGJhbmQuaGVpZ2h0O1xyXG4gICAgICBjb25zdCBiYW5kU3RyaXBzID0gc3RyaXBzLmZpbHRlcihzID0+IHtcclxuICAgICAgICBjb25zdCB5T3ZlcmxhcCA9IE1hdGgubWluKGJvdHRvbSwgcy5ib3R0b20pIC0gTWF0aC5tYXgodG9wLCBzLnRvcCk7XHJcbiAgICAgICAgY29uc3Qgc3RyaXBIID0gcy5ib3R0b20gLSBzLnRvcDtcclxuICAgICAgICBjb25zdCBvdmVybGFwRnJhYyA9IHlPdmVybGFwIC8gTWF0aC5tYXgoMSwgc3RyaXBILCBib3R0b20gLSB0b3ApO1xyXG4gICAgICAgIHJldHVybiB5T3ZlcmxhcCA+IDAgJiYgb3ZlcmxhcEZyYWMgPj0gdGhpcy5zZXR0aW5ncy5taW5PdmVybGFwRnJhY0ZvckJhbmQ7XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCByZWdpb25zID0gdGhpcy5idWlsZENvbHVtblJlZ2lvbnNGcm9tU3RyaXBzKGJhbmRTdHJpcHMsIHBhZ2VSZWN0KTtcclxuICAgICAgcmVzdWx0cy5wdXNoKHsgYmFuZDogeyB0b3AsIGJvdHRvbSB9LCByZWdpb25zIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghYmFuZHMubGVuZ3RoKSB7XHJcbiAgICAgIHJlc3VsdHMucHVzaCh7XHJcbiAgICAgICAgYmFuZDogeyB0b3A6IHBhZ2VSZWN0LnRvcCwgYm90dG9tOiBwYWdlUmVjdC5ib3R0b20gfSxcclxuICAgICAgICByZWdpb25zOiB0aGlzLmJ1aWxkQ29sdW1uUmVnaW9uc0Zyb21TdHJpcHMoc3RyaXBzLCBwYWdlUmVjdClcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYnVpbGRDb2x1bW5SZWdpb25zRnJvbVN0cmlwcyhcclxuICAgIHN0cmlwczogVmVydGljYWxTdHJpcFtdLFxyXG4gICAgcGFnZVJlY3Q6IERPTVJlY3RcclxuICApOiBBcnJheTx7IGxlZnQ6IG51bWJlcjsgcmlnaHQ6IG51bWJlciB9PiB7XHJcbiAgICBpZiAoIXN0cmlwcz8ubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBbeyBsZWZ0OiBwYWdlUmVjdC5sZWZ0LCByaWdodDogcGFnZVJlY3QucmlnaHQgfV07XHJcbiAgICB9XHJcbiAgICBjb25zdCBzID0gWy4uLnN0cmlwc10uc29ydCgoYSwgYikgPT4gKChhLmxlZnQgKyBhLnJpZ2h0KSAvIDIpIC0gKChiLmxlZnQgKyBiLnJpZ2h0KSAvIDIpKTtcclxuICAgIGNvbnN0IHhzOiBudW1iZXJbXSA9IFtwYWdlUmVjdC5sZWZ0XTtcclxuICAgIGZvciAoY29uc3Qgc3Qgb2Ygcykge1xyXG4gICAgICBjb25zdCBtaWQgPSAoc3QubGVmdCArIHN0LnJpZ2h0KSAvIDI7XHJcbiAgICAgIGlmIChtaWQgPiB4c1t4cy5sZW5ndGggLSAxXSkgeHMucHVzaChtaWQpO1xyXG4gICAgfVxyXG4gICAgeHMucHVzaChwYWdlUmVjdC5yaWdodCk7XHJcblxyXG4gICAgY29uc3QgcmVnaW9uczogQXJyYXk8eyBsZWZ0OiBudW1iZXI7IHJpZ2h0OiBudW1iZXIgfT4gPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGwgPSB4c1tpXSwgciA9IHhzW2kgKyAxXTtcclxuICAgICAgaWYgKHIgLSBsID4gdGhpcy5zZXR0aW5ncy5taW5SZWdpb25XaWR0aCkgcmVnaW9ucy5wdXNoKHsgbGVmdDogbCwgcmlnaHQ6IHIgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVnaW9ucztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgb3JkZXJQYXJhZ3JhcGhCeUJhbmRzQW5kQ29sdW1ucyhcclxuICAgIHBhcmFncmFwaDogSFRNTFNwYW5FbGVtZW50W10sXHJcbiAgICBpbmZvTWFwOiBNYXA8SFRNTFNwYW5FbGVtZW50LCBTcGFuSW5mbz4sXHJcbiAgICBiYW5kczogSG9yaXpvbnRhbEJhbmRbXSxcclxuICAgIHBlckJhbmRSZWdpb25zOiBBcnJheTx7IGJhbmQ6IHsgdG9wOiBudW1iZXI7IGJvdHRvbTogbnVtYmVyIH0sIHJlZ2lvbnM6IEFycmF5PHsgbGVmdDogbnVtYmVyOyByaWdodDogbnVtYmVyIH0+IH0+XHJcbiAgKTogSFRNTFNwYW5FbGVtZW50W10ge1xyXG4gICAgaWYgKCFwYXJhZ3JhcGgubGVuZ3RoKSByZXR1cm4gcGFyYWdyYXBoO1xyXG5cclxuICAgIHR5cGUgQnVja2V0ID0geyBzcGFuczogSFRNTFNwYW5FbGVtZW50W107IHJlZ2lvbnM6IEFycmF5PHsgbGVmdDogbnVtYmVyOyByaWdodDogbnVtYmVyIH0+IH07XHJcbiAgICBjb25zdCBiYW5kQnVja2V0czogQnVja2V0W10gPSBwZXJCYW5kUmVnaW9ucy5tYXAoZW50cnkgPT4gKHsgc3BhbnM6IFtdLCByZWdpb25zOiBlbnRyeS5yZWdpb25zIH0pKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHMgb2YgcGFyYWdyYXBoKSB7XHJcbiAgICAgIGNvbnN0IHIgPSBpbmZvTWFwLmdldChzKSEucmVjdDtcclxuICAgICAgY29uc3Qgc1RvcCA9IHIudG9wLCBzQm90ID0gci5ib3R0b207XHJcbiAgICAgIGxldCBiZXN0SWR4ID0gLTEsIGJlc3RPdmVybGFwID0gMDtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZXJCYW5kUmVnaW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGJhbmQgPSBwZXJCYW5kUmVnaW9uc1tpXS5iYW5kO1xyXG4gICAgICAgIGNvbnN0IHlPdmVybGFwID0gTWF0aC5taW4oc0JvdCwgYmFuZC5ib3R0b20pIC0gTWF0aC5tYXgoc1RvcCwgYmFuZC50b3ApO1xyXG4gICAgICAgIGlmICh5T3ZlcmxhcCA8PSAwKSBjb250aW51ZTtcclxuICAgICAgICBjb25zdCBvdmVybGFwID0geU92ZXJsYXAgLyBNYXRoLm1heCgxLCBzQm90IC0gc1RvcCwgYmFuZC5ib3R0b20gLSBiYW5kLnRvcCk7XHJcbiAgICAgICAgaWYgKG92ZXJsYXAgPiBiZXN0T3ZlcmxhcCkge1xyXG4gICAgICAgICAgYmVzdE92ZXJsYXAgPSBvdmVybGFwO1xyXG4gICAgICAgICAgYmVzdElkeCA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChiZXN0SWR4ID49IDApIHtcclxuICAgICAgICBiYW5kQnVja2V0c1tiZXN0SWR4XS5zcGFucy5wdXNoKHMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChwZXJCYW5kUmVnaW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgIGxldCBpZHggPSAwLCBiZXN0RGlzdCA9IEluZmluaXR5O1xyXG4gICAgICAgICAgY29uc3Qgc2MgPSAoc1RvcCArIHNCb3QpIC8gMjtcclxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVyQmFuZFJlZ2lvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgYmFuZCA9IHBlckJhbmRSZWdpb25zW2ldLmJhbmQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGJjID0gKGJhbmQudG9wICsgYmFuZC5ib3R0b20pIC8gMjtcclxuICAgICAgICAgICAgY29uc3QgZCA9IE1hdGguYWJzKHNjIC0gYmMpO1xyXG4gICAgICAgICAgICBpZiAoZCA8IGJlc3REaXN0KSB7IGJlc3REaXN0ID0gZDsgaWR4ID0gaTsgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYmFuZEJ1Y2tldHNbaWR4XS5zcGFucy5wdXNoKHMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoIWJhbmRCdWNrZXRzLmxlbmd0aCkgYmFuZEJ1Y2tldHMucHVzaCh7IHNwYW5zOiBbXSwgcmVnaW9uczogW3sgbGVmdDogLUluZmluaXR5LCByaWdodDogSW5maW5pdHkgfV0gfSk7XHJcbiAgICAgICAgICBiYW5kQnVja2V0c1swXS5zcGFucy5wdXNoKHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9yZGVyZWQ6IEhUTUxTcGFuRWxlbWVudFtdID0gW107XHJcbiAgICBmb3IgKGNvbnN0IGJ1Y2tldCBvZiBiYW5kQnVja2V0cykge1xyXG4gICAgICBpZiAoIWJ1Y2tldC5zcGFucy5sZW5ndGgpIGNvbnRpbnVlO1xyXG4gICAgICBjb25zdCByZWdpb25zID0gYnVja2V0LnJlZ2lvbnMubGVuZ3RoID8gYnVja2V0LnJlZ2lvbnMgOiBbeyBsZWZ0OiAtSW5maW5pdHksIHJpZ2h0OiBJbmZpbml0eSB9XTtcclxuICAgICAgY29uc3QgY29sQnVja2V0czogSFRNTFNwYW5FbGVtZW50W11bXSA9IHJlZ2lvbnMubWFwKCgpID0+IFtdKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgcyBvZiBidWNrZXQuc3BhbnMpIHtcclxuICAgICAgICBjb25zdCByID0gaW5mb01hcC5nZXQocykhLnJlY3Q7XHJcbiAgICAgICAgY29uc3QgY3ggPSAoci5sZWZ0ICsgci5yaWdodCkgLyAyO1xyXG4gICAgICAgIGxldCBpZHggPSByZWdpb25zLmZpbmRJbmRleChyZWcgPT4gY3ggPj0gcmVnLmxlZnQgJiYgY3ggPCByZWcucmlnaHQpO1xyXG4gICAgICAgIGlmIChpZHggPCAwKSB7XHJcbiAgICAgICAgICBpZHggPSAoY3ggPCByZWdpb25zWzBdLmxlZnQpID8gMCA6IHJlZ2lvbnMubGVuZ3RoIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29sQnVja2V0c1tpZHhdLnB1c2gocyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjb2xCdWNrZXRzLmZpbHRlcihiID0+IGIubGVuZ3RoID4gMCkubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICBjb25zdCBzb3J0ZWQgPSBidWNrZXQuc3BhbnMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCByYSA9IGluZm9NYXAuZ2V0KGEpIS5yZWN0O1xyXG4gICAgICAgICAgY29uc3QgcmIgPSBpbmZvTWFwLmdldChiKSEucmVjdDtcclxuICAgICAgICAgIHJldHVybiByYS50b3AgLSByYi50b3AgfHwgcmEubGVmdCAtIHJiLmxlZnQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgb3JkZXJlZC5wdXNoKC4uLnNvcnRlZCk7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoY29uc3QgYiBvZiBjb2xCdWNrZXRzKSB7XHJcbiAgICAgICAgYi5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCByYSA9IGluZm9NYXAuZ2V0KGEpIS5yZWN0O1xyXG4gICAgICAgICAgY29uc3QgcmIgPSBpbmZvTWFwLmdldChiKSEucmVjdDtcclxuICAgICAgICAgIHJldHVybiByYS50b3AgLSByYi50b3AgfHwgcmEubGVmdCAtIHJiLmxlZnQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgb3JkZXJlZC5wdXNoKC4uLmIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3JkZXJlZC5sZW5ndGggPyBvcmRlcmVkIDogcGFyYWdyYXBoO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjcmVhdGVFbXB0eVJlc3VsdCgpOiBMYXlvdXRSZXN1bHQge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGFyYWdyYXBoczogW10sXHJcbiAgICAgIGNvbHVtbkFuYWx5c2lzOiB7XHJcbiAgICAgICAgY29sdW1uczogW10sIGVkZ2VDb2xzOiBbXSwgZ2FwQ29sczogW10sIHZlcnRpY2FsR2FwczogW10sIGhvcml6b250YWxHYXBzOiBbXVxyXG4gICAgICB9LFxyXG4gICAgICBsYXlvdXRSZWdpb25zOiBbXVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgbG9nRGVidWcobWVzc2FnZTogc3RyaW5nLCBkZXRhaWxzPzogdW5rbm93bikge1xyXG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLmRlYnVnVmFsaWRhdGlvbikgcmV0dXJuO1xyXG4gICAgaWYgKGRldGFpbHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgICBjb25zb2xlLmxvZyhgW0xheW91dERldGVjdG9yXSAke21lc3NhZ2V9YCwgZGV0YWlscyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgICBjb25zb2xlLmxvZyhgW0xheW91dERldGVjdG9yXSAke21lc3NhZ2V9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwgIi8vIG1vZGFsLnRzXHJcbmltcG9ydCB7IE1vZGFsLCBTZXR0aW5nLCBOb3RpY2UsIEJ1dHRvbkNvbXBvbmVudCwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCBPcGVuUm91dGVyVHJhbnNsYXRvclBsdWdpbiBmcm9tICcuL21haW4nO1xyXG5cclxuLyoqXHJcbiAqIEEgbW9kYWwgZm9yIHRyYW5zbGF0aW5nIGEgcmFuZ2Ugb2YgcGFnZXMgd2l0aGluIGEgUERGIGZpbGUuXHJcbiAqXHJcbiAqIFRoaXMgbW9kYWwgaW1wbGVtZW50cyBhIHJvYnVzdCB0cmFuc2xhdGlvbiB3b3JrZmxvdyB3aXRoIHRoZSBmb2xsb3dpbmcgZmVhdHVyZXM6XHJcbiAqIC0gKipUcmFuc2xhdGlvbiBDYWNoaW5nOioqIFRlbXBvcmFyaWx5IHN0b3JlcyBzdWNjZXNzZnVsIHRyYW5zbGF0aW9ucyB0byBwcmV2ZW50IGRhdGEgbG9zcyBvbiBvdmVybGF5IGNyZWF0aW9uIGZhaWx1cmUuXHJcbiAqIC0gKipPdmVybGF5IFZlcmlmaWNhdGlvbjoqKiBFeHBsaWNpdGx5IGNoZWNrcyB0aGF0IHRoZSBjcmVhdGVkIG92ZXJsYXkgY29udGFpbnMgdGhlIHRyYW5zbGF0ZWQgdGV4dCwgdHJpZ2dlcmluZyBhIHJldHJ5IGlmIGl0IGRvZXNuJ3QuXHJcbiAqIC0gKipPcHRpb25hbCBQYWNlZCBEaXN0cmlidXRpb246KiogVXNlcnMgY2FuIG9wdGlvbmFsbHkgZGVmaW5lIGEgdGltZSB3aW5kb3cuIElmIHNldCxcclxuICogICB0aGUgdHJhbnNsYXRpb24gY2FsbHMgYXJlIGV2ZW5seSBkaXN0cmlidXRlZCBmcm9tIHRoZSBzdGFydCB0byBmaXQgd2l0aGluIHRoYXRcclxuICogICB0aW1lLCBwcmV2ZW50aW5nIEFQSSByYXRlLWxpbWl0aW5nLiBJZiBub3Qgc2V0LCBpdCBydW5zIGFzIGZhc3QgYXMgcG9zc2libGUuXHJcbiAqIC0gKipBZGFwdGl2ZSBSZXRyaWVzOioqIEhhbmRsZXMgdHJhbnNpZW50IG5ldHdvcmsgZXJyb3JzIHdpdGggYW4gZXhwb25lbnRpYWwgYmFja29mZiBzdHJhdGVneS5cclxuICogLSAqKkNsZWFyIFVJIEZlZWRiYWNrOioqIFByb3ZpZGVzIGRldGFpbGVkIHByb2dyZXNzIHVwZGF0ZXMgdG8gdGhlIHVzZXIuXHJcbiAqIC0gKipTaW5nbGV0b24gSm9iIE1hbmFnZW1lbnQ6KiogUHJldmVudHMgbXVsdGlwbGUgYnVsayB0cmFuc2xhdGlvbiBqb2JzIGZyb20gcnVubmluZyBzaW11bHRhbmVvdXNseSxcclxuICogICBhbmQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIHRvIG1hbmFnZSB0aGUgcnVubmluZyBqb2IuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRlTXVsdGlwbGVQYWdlc01vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG4gICAgLy8gUGx1Z2luIGFuZCBGaWxlIENvbnRleHRcclxuICAgIHBsdWdpbjogT3BlblJvdXRlclRyYW5zbGF0b3JQbHVnaW47XHJcbiAgICBmaWxlOiBURmlsZTtcclxuXHJcbiAgICAvLyBVc2VyLWNvbmZpZ3VyYWJsZSBzZXR0aW5ncyBmb3IgdGhlIGN1cnJlbnQgam9iXHJcbiAgICBzdGFydFBhZ2U6IG51bWJlciA9IDE7XHJcbiAgICBlbmRQYWdlOiBudW1iZXIgPSAxO1xyXG4gICAgdG90YWxQYWdlczogbnVtYmVyID0gMTtcclxuICAgIHVzZVRpbWVXaW5kb3c6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHRpbWVXaW5kb3dIb3VyczogbnVtYmVyID0gMjsgLy8gRGVmYXVsdCB0aW1lIHdpbmRvdyBvZiAyIGhvdXJzXHJcblxyXG4gICAgLy8gSW50ZXJuYWwgc3RhdGUgbWFuYWdlbWVudFxyXG4gICAgaXNQcm9jZXNzaW5nOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBpc0NhbmNlbGxlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgYWN0aXZlT3ZlcmxheXM6IEhUTUxFbGVtZW50W10gPSBbXTtcclxuICAgIHByaXZhdGUgcmV0cnlUaW1lb3V0OiBudW1iZXIgPSAwO1xyXG5cclxuICAgIC8vIE5FVzogQ2FjaGUgdG8gc3RvcmUgdHJhbnNsYXRlZCB0ZXh0LCBwcmV2ZW50aW5nIGRhdGEgbG9zcyBvbiBET00gZXJyb3JzLlxyXG4gICAgcHJpdmF0ZSB0cmFuc2xhdGlvbkNhY2hlOiBNYXA8bnVtYmVyLCBzdHJpbmc+ID0gbmV3IE1hcCgpO1xyXG5cclxuICAgIC8vIFN0YXRlIGZvciBwYWNpbmdcclxuICAgIHByaXZhdGUgcGFjaW5nRGVsYXk6IG51bWJlciA9IDIwMDsgLy8gRGVmYXVsdCBcInNwcmludFwiIGRlbGF5XHJcblxyXG4gICAgLy8gUHJvcGVydGllcyBmb3IgbGl2ZSBwcm9ncmVzcyB0cmFja2luZ1xyXG4gICAgcHJpdmF0ZSBwcm9ncmVzc01lc3NhZ2U6IHN0cmluZyA9ICdJbml0aWFsaXppbmcuLi4nO1xyXG4gICAgcHJpdmF0ZSBwcm9ncmVzc0VsOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgIC8vIFN0YXRpYyBwcm9wZXJ0aWVzIHRvIGVuc3VyZSBvbmx5IG9uZSBidWxrIHRyYW5zbGF0aW9uIHJ1bnMgYXQgYSB0aW1lXHJcbiAgICBzdGF0aWMgaXNCdWxrVHJhbnNsYXRpb25JblByb2dyZXNzOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBzdGF0aWMgY3VycmVudEluc3RhbmNlOiBUcmFuc2xhdGVNdWx0aXBsZVBhZ2VzTW9kYWwgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwbHVnaW46IE9wZW5Sb3V0ZXJUcmFuc2xhdG9yUGx1Z2luLCBmaWxlOiBURmlsZSkge1xyXG4gICAgICAgIHN1cGVyKHBsdWdpbi5hcHApO1xyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgbW9kYWwgaXMgb3BlbmVkLiBSZW5kZXJzIHRoZSBVSS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgb25PcGVuKCkge1xyXG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xyXG5cclxuICAgICAgICBpZiAoVHJhbnNsYXRlTXVsdGlwbGVQYWdlc01vZGFsLmlzQnVsa1RyYW5zbGF0aW9uSW5Qcm9ncmVzcyAmJiBUcmFuc2xhdGVNdWx0aXBsZVBhZ2VzTW9kYWwuY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheU1hbmFnZW1lbnRWaWV3KGNvbnRlbnRFbCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudGl0bGVFbC5zZXRUZXh0KCdUcmFuc2xhdGUgTXVsdGlwbGUgUGFnZXMnKTtcclxuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6IGBGaWxlOiAke3RoaXMuZmlsZS5iYXNlbmFtZX1gIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnRvdGFsUGFnZXMgPSBhd2FpdCB0aGlzLmVzdGltYXRlVG90YWxQYWdlcygpO1xyXG4gICAgICAgIHRoaXMuZW5kUGFnZSA9IHRoaXMudG90YWxQYWdlcztcclxuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6IGBFc3RpbWF0ZWQgdG90YWwgcGFnZXM6ICR7dGhpcy50b3RhbFBhZ2VzfWAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyU2V0dGluZ3MoY29udGVudEVsKTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NDb250YWluZXIgPSBjb250ZW50RWwuY3JlYXRlRGl2KHsgY2xzOiAndHJhbnNsYXRvci1wcm9ncmVzcy1jb250YWluZXInIH0pO1xyXG4gICAgICAgIHRoaXMucHJvZ3Jlc3NFbCA9IHByb2dyZXNzQ29udGFpbmVyO1xyXG5cclxuICAgICAgICBjb25zdCBidXR0b25Db250YWluZXIgPSBjb250ZW50RWwuY3JlYXRlRGl2KHsgY2xzOiAndHJhbnNsYXRvci1idXR0b24tY29udGFpbmVyJyB9KTtcclxuICAgICAgICB0aGlzLnJlbmRlckFjdGlvbkJ1dHRvbnMoYnV0dG9uQ29udGFpbmVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSB2aWV3IHRvIG1hbmFnZSBhbiBpbi1wcm9ncmVzcyB0cmFuc2xhdGlvbiBqb2IuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZGlzcGxheU1hbmFnZW1lbnRWaWV3KGNvbnRlbnRFbDogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLnRpdGxlRWwuc2V0VGV4dCgnVHJhbnNsYXRpb24gaW4gUHJvZ3Jlc3MnKTtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IFRyYW5zbGF0ZU11bHRpcGxlUGFnZXNNb2RhbC5jdXJyZW50SW5zdGFuY2U7XHJcblxyXG4gICAgICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgY29udGVudEVsLnNldFRleHQoJ0NvdWxkIG5vdCBmaW5kIHRoZSBhY3RpdmUgdHJhbnNsYXRpb24gcHJvY2Vzcy4nKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnQSBiYXRjaCB0cmFuc2xhdGlvbiBpcyBhbHJlYWR5IHJ1bm5pbmcuJyB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NEaXNwbGF5ID0gY29udGVudEVsLmNyZWF0ZUVsKCdwJywgeyBjbHM6ICd0cmFuc2xhdG9yLXByb2dyZXNzLWRpc3BsYXknIH0pO1xyXG4gICAgICAgIHByb2dyZXNzRGlzcGxheS5zZXRUZXh0KGluc3RhbmNlLnByb2dyZXNzTWVzc2FnZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGludGVydmFsSWQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoVHJhbnNsYXRlTXVsdGlwbGVQYWdlc01vZGFsLmlzQnVsa1RyYW5zbGF0aW9uSW5Qcm9ncmVzcyAmJiBpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NEaXNwbGF5LnNldFRleHQoaW5zdGFuY2UucHJvZ3Jlc3NNZXNzYWdlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKGludGVydmFsSWQpO1xyXG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnVHJhbnNsYXRpb24gam9iIGhhcyBmaW5pc2hlZC4nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDEwMDApO1xyXG5cclxuICAgICAgICBjb25zdCBidXR0b25Db250YWluZXIgPSBjb250ZW50RWwuY3JlYXRlRGl2KHsgY2xzOiAndHJhbnNsYXRvci1idXR0b24tY29udGFpbmVyJyB9KTtcclxuXHJcbiAgICAgICAgbmV3IEJ1dHRvbkNvbXBvbmVudChidXR0b25Db250YWluZXIpXHJcbiAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdDYW5jZWwgVHJhbnNsYXRpb24nKVxyXG4gICAgICAgICAgICAuc2V0V2FybmluZygpXHJcbiAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChUcmFuc2xhdGVNdWx0aXBsZVBhZ2VzTW9kYWwuY2FuY2VsQ3VycmVudFRyYW5zbGF0aW9uKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdUcmFuc2xhdGlvbiBhYm9ydGVkLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbmV3IEJ1dHRvbkNvbXBvbmVudChidXR0b25Db250YWluZXIpXHJcbiAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdDbG9zZScpXHJcbiAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHRoaXMuY2xvc2UoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIHRoZSBzZXR0aW5ncyBmb3IgcGFnZSByYW5nZSBhbmQgdGltZSB3aW5kb3cuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVuZGVyU2V0dGluZ3MoY29udGVudEVsOiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIGxldCBzdGFydElucHV0OiBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGxldCBlbmRJbnB1dDogSFRNTElucHV0RWxlbWVudDtcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGVudEVsKS5zZXROYW1lKCdTdGFydCBwYWdlJykuYWRkVGV4dCgoY2IpID0+IHtcclxuICAgICAgICAgICAgc3RhcnRJbnB1dCA9IGNiLmVsO1xyXG4gICAgICAgICAgICBjYi5zZXRWYWx1ZShTdHJpbmcodGhpcy5zdGFydFBhZ2UpKS5vbkNoYW5nZSgodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBwYXJzZUludCh2YWx1ZSwgMTApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihuKSAmJiBuID49IDEgJiYgbiA8PSB0aGlzLnRvdGFsUGFnZXMpIHRoaXMuc3RhcnRQYWdlID0gbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbCkuc2V0TmFtZSgnRW5kIHBhZ2UnKS5hZGRUZXh0KChjYikgPT4ge1xyXG4gICAgICAgICAgICBlbmRJbnB1dCA9IGNiLmVsO1xyXG4gICAgICAgICAgICBjYi5zZXRWYWx1ZShTdHJpbmcodGhpcy5lbmRQYWdlKSkub25DaGFuZ2UoKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4obikgJiYgbiA+PSB0aGlzLnN0YXJ0UGFnZSAmJiBuIDw9IHRoaXMudG90YWxQYWdlcykgdGhpcy5lbmRQYWdlID0gbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbCkuYWRkQnV0dG9uKChjYikgPT4ge1xyXG4gICAgICAgICAgICBjYi5zZXRCdXR0b25UZXh0KCdBbGwgUGFnZXMnKS5zZXRDdGEoKS5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRQYWdlID0gMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5kUGFnZSA9IHRoaXMudG90YWxQYWdlcztcclxuICAgICAgICAgICAgICAgIHN0YXJ0SW5wdXQudmFsdWUgPSAnMSc7XHJcbiAgICAgICAgICAgICAgICBlbmRJbnB1dC52YWx1ZSA9IFN0cmluZyh0aGlzLnRvdGFsUGFnZXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgdGltZVdpbmRvd1NldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50RWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdVc2UgVGltZSBXaW5kb3cnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnRGlzdHJpYnV0ZSB0cmFuc2xhdGlvbnMgb3ZlciBhIHNldCB0aW1lIHRvIGF2b2lkIHJhdGUgbGltaXRzLiBJZiBvZmYsIGl0IHdpbGwgcnVuIGFzIGZhc3QgYXMgcG9zc2libGUuJylcclxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy51c2VUaW1lV2luZG93KVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZVRpbWVXaW5kb3cgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lSW5wdXRTZXR0aW5nLnNldHRpbmdFbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyAnJyA6ICdub25lJztcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgY29uc3QgdGltZUlucHV0U2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ0pvYiBUaW1lIChIb3VycyknKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnVGhlIHRvdGFsIHRpbWUgdG8gc3ByZWFkIHRoZSB0cmFuc2xhdGlvbiBqb2Igb3Zlci4nKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShTdHJpbmcodGhpcy50aW1lV2luZG93SG91cnMpKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihuKSAmJiBuID4gMCkgdGhpcy50aW1lV2luZG93SG91cnMgPSBuO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICB0aW1lSW5wdXRTZXR0aW5nLnNldHRpbmdFbC5zdHlsZS5kaXNwbGF5ID0gdGhpcy51c2VUaW1lV2luZG93ID8gJycgOiAnbm9uZSc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIHRoZSBTdGFydCBhbmQgQWJvcnQgYnV0dG9ucy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZW5kZXJBY3Rpb25CdXR0b25zKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBjb25zdCBzdGFydEJ1dHRvbiA9IG5ldyBCdXR0b25Db21wb25lbnQoY29udGFpbmVyKVxyXG4gICAgICAgICAgICAuc2V0QnV0dG9uVGV4dCgnU3RhcnQgVHJhbnNsYXRpb24nKVxyXG4gICAgICAgICAgICAuc2V0Q3RhKClcclxuICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRQYWdlID4gdGhpcy5lbmRQYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnU3RhcnQgcGFnZSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBFbmQgcGFnZS4nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplSm9iU3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0QnV0dG9uLnNldERpc2FibGVkKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgYWJvcnRCdXR0b24uc2V0RGlzYWJsZWQoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3MoJ1N0YXJ0aW5nIHRyYW5zbGF0aW9uIGpvYi4uLicpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50cmFuc2xhdGVQYWdlUmFuZ2UodGhpcy5maWxlLCB0aGlzLnN0YXJ0UGFnZSwgdGhpcy5lbmRQYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNDYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnRXJyb3I6ICcgKyAoZXJyLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InKSwgNzAwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQnVsayB0cmFuc2xhdGlvbiBmYWlsZWQ6JywgZXJyKTtcclxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzQ2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QnV0dG9uLnNldERpc2FibGVkKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRCdXR0b24uc2V0RGlzYWJsZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBhYm9ydEJ1dHRvbiA9IG5ldyBCdXR0b25Db21wb25lbnQoY29udGFpbmVyKVxyXG4gICAgICAgICAgICAuc2V0QnV0dG9uVGV4dCgnQWJvcnQnKVxyXG4gICAgICAgICAgICAuc2V0RGlzYWJsZWQodHJ1ZSlcclxuICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNQcm9jZXNzaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnQWJvcnRpbmcgdHJhbnNsYXRpb24uLi4nKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhYm9ydEJ1dHRvbi5zZXRCdXR0b25UZXh0KCdBYm9ydGluZy4uLicpLnNldERpc2FibGVkKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGluaXRpYWwgc3RhdGUgZm9yIGEgbmV3IHRyYW5zbGF0aW9uIGpvYi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplSm9iU3RhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaXNDYW5jZWxsZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgVHJhbnNsYXRlTXVsdGlwbGVQYWdlc01vZGFsLmlzQnVsa1RyYW5zbGF0aW9uSW5Qcm9ncmVzcyA9IHRydWU7XHJcbiAgICAgICAgVHJhbnNsYXRlTXVsdGlwbGVQYWdlc01vZGFsLmN1cnJlbnRJbnN0YW5jZSA9IHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDZW50cmFsaXplZCBtZXRob2QgZm9yIHVwZGF0aW5nIHRoZSBwcm9ncmVzcyBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHVwZGF0ZVByb2dyZXNzKG1zZzogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5wcm9ncmVzc01lc3NhZ2UgPSBtc2c7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvZ3Jlc3NFbCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzRWwuc2V0VGV4dChtc2cpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYWluIGxvZ2ljIGxvb3AgZm9yIHByb2Nlc3NpbmcgYSByYW5nZSBvZiBwYWdlcy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyB0cmFuc2xhdGVQYWdlUmFuZ2UocGRmRmlsZTogVEZpbGUsIHN0YXJ0UGFnZTogbnVtYmVyLCBlbmRQYWdlOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBwZGZMZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZSgncGRmJylbMF0gfHwgdGhpcy5hcHAud29ya3NwYWNlLmdldE1vc3RSZWNlbnRMZWFmKCk7XHJcbiAgICAgICAgaWYgKCFwZGZMZWFmKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYXZhaWxhYmxlIHdvcmtzcGFjZSBsZWFmIHRvIG9wZW4gUERGLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgcGRmTGVhZi5vcGVuRmlsZShwZGZGaWxlKTtcclxuICAgICAgICAgICAgaWYgKCFhd2FpdCB0aGlzLndhaXRGb3JFbCgnLnBkZlZpZXdlcicsIDEwMDAwKSkgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBQREYgdmlld2VyLicpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBvcGVuIHRoZSBzcGVjaWZpZWQgUERGIGZpbGUuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBvcmlnaW5hbEF1dG9TYXZlID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuYXV0b1NhdmVPdmVybGF5O1xyXG4gICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmF1dG9TYXZlT3ZlcmxheSA9IHRydWU7XHJcblxyXG4gICAgICAgIGxldCBjb21wbGV0ZWQgPSAwLCBmYWlsZWQgPSAwO1xyXG4gICAgICAgIGNvbnN0IHRvdGFsUGFnZXNUb1Byb2Nlc3MgPSBlbmRQYWdlIC0gc3RhcnRQYWdlICsgMTtcclxuICAgICAgICBjb25zdCBwcm9jZXNzaW5nUXVldWUgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiB0b3RhbFBhZ2VzVG9Qcm9jZXNzIH0sIChfLCBpKSA9PiBzdGFydFBhZ2UgKyBpKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudXNlVGltZVdpbmRvdyAmJiB0aGlzLnRpbWVXaW5kb3dIb3VycyA+IDAgJiYgdG90YWxQYWdlc1RvUHJvY2VzcyA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgdG90YWxNaWxsaXNlY29uZHMgPSB0aGlzLnRpbWVXaW5kb3dIb3VycyAqIDM2MDAgKiAxMDAwO1xyXG4gICAgICAgICAgICB0aGlzLnBhY2luZ0RlbGF5ID0gdG90YWxNaWxsaXNlY29uZHMgLyB0b3RhbFBhZ2VzVG9Qcm9jZXNzO1xyXG4gICAgICAgICAgICBjb25zdCBwYWNlSW5TZWNvbmRzID0gTWF0aC5yb3VuZCh0aGlzLnBhY2luZ0RlbGF5IC8gMTAwMCk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3MoYFBhY2luZyBlbmFibGVkLiBFYWNoIHBhZ2Ugd2lsbCBiZSBwcm9jZXNzZWQgYXBwcm94LiBldmVyeSAke3BhY2VJblNlY29uZHN9IHNlY29uZHMuYCk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2xlZXAoMTAwMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wYWNpbmdEZWxheSA9IDIwMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChwcm9jZXNzaW5nUXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2dyZXNzKCdcdTIzRjlcdUZFMEYgVHJhbnNsYXRpb24gY2FuY2VsbGVkIGJ5IHVzZXIuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VOdW0gPSBwcm9jZXNzaW5nUXVldWUuc2hpZnQoKSE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9ncmVzc1ByZWZpeCA9IGBbJHtjb21wbGV0ZWQgKyAxfS8ke3RvdGFsUGFnZXNUb1Byb2Nlc3N9XWA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2dyZXNzKGAke3Byb2dyZXNzUHJlZml4fSBcdUQ4M0RcdUREMDQgUHJvY2Vzc2luZyBwYWdlICR7cGFnZU51bX0uLi5gKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1PRElGSUVEOiBSZXdvcmtlZCB0aGUgY29yZSBsb2dpYyB3aXRoIGNhY2hpbmcgYW5kIHZlcmlmaWNhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmV0cnlXaXRoQmFja29mZihhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hdlN1Y2Nlc3MgPSBhd2FpdCB0aGlzLm5hdmlnYXRlVG9QYWdlKHBkZkxlYWYsIHBhZ2VOdW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5hdlN1Y2Nlc3MpIHRocm93IG5ldyBFcnJvcignTmF2aWdhdGlvbiBmYWlsZWQuJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWdlRWwgPSBhd2FpdCB0aGlzLndhaXRGb3JQYWdlQW5kVGV4dExheWVyKHBhZ2VOdW0sIDMwMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYWdlRWwpIHRocm93IG5ldyBFcnJvcignUGFnZSBvciB0ZXh0IGxheWVyIGZhaWxlZCB0byByZW5kZXIuJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDE6IEdldCB0cmFuc2xhdGlvbiAoZnJvbSBjYWNoZSBvciBuZXcgQVBJIGNhbGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0cmFuc2xhdGVkVGV4dCA9IHRoaXMudHJhbnNsYXRpb25DYWNoZS5nZXQocGFnZU51bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHJhbnNsYXRlZFRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3MoYCR7cHJvZ3Jlc3NQcmVmaXh9IFx1MjcwRFx1RkUwRiBUcmFuc2xhdGluZyBwYWdlICR7cGFnZU51bX0uLi5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFTU1VNUFRJT046IFlvdSBuZWVkIGEgbWV0aG9kIHRoYXQgb25seSBkb2VzIHRoZSB0cmFuc2xhdGlvbiBhbmQgcmV0dXJucyBhIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRUZXh0ID0gYXdhaXQgdGhpcy5wbHVnaW4ucHJvY2Vzc29yLnRyYW5zbGF0ZVBhZ2VDb250ZW50KHBhZ2VFbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYW5zbGF0ZWRUZXh0IHx8IHRyYW5zbGF0ZWRUZXh0LnRyaW0oKSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zbGF0aW9uIHJldHVybmVkIGVtcHR5IGNvbnRlbnQuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0aW9uQ2FjaGUuc2V0KHBhZ2VOdW0sIHRyYW5zbGF0ZWRUZXh0KTsgLy8gQ2FjaGUgdGhlIHN1Y2Nlc3NmdWwgdHJhbnNsYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3MoYCR7cHJvZ3Jlc3NQcmVmaXh9IFx1RDgzRFx1RENDNCBVc2luZyBjYWNoZWQgdHJhbnNsYXRpb24gZm9yIHBhZ2UgJHtwYWdlTnVtfS5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCAyOiBDcmVhdGUgdGhlIG92ZXJsYXkgd2l0aCB0aGUgdHJhbnNsYXRlZCB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFTU1VNUFRJT046IFlvdSBuZWVkIGEgbWV0aG9kIHRoYXQgY3JlYXRlcyB0aGUgb3ZlcmxheSBmcm9tIGEgZ2l2ZW4gdGV4dCBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnByb2Nlc3Nvci5jcmVhdGVPdmVybGF5V2l0aFRleHQocGFnZUVsLCB0cmFuc2xhdGVkVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld092ZXJsYXkgPSBwYWdlRWwucXVlcnlTZWxlY3RvcjxIVE1MRWxlbWVudD4oJy5wZGYtdGV4dC1vdmVybGF5LWNvbnRhaW5lcicpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCAzOiBWRVJJRlkgdGhlIG92ZXJsYXkgd2FzIGNyZWF0ZWQgYW5kIGNvbnRhaW5zIHRoZSBjb3JyZWN0IHRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdPdmVybGF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJsYXkgZWxlbWVudCB3YXMgbm90IGZvdW5kIGFmdGVyIGNyZWF0aW9uLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdmVybGF5VGV4dCA9IG5ld092ZXJsYXkuaW5uZXJUZXh0LnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZ5IGEgc25pcHBldCBvZiB0aGUgdGV4dCB0byBhdm9pZCBpc3N1ZXMgd2l0aCBmb3JtYXR0aW5nIGRpZmZlcmVuY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcmlmaWNhdGlvblNuaXBwZXQgPSB0cmFuc2xhdGVkVGV4dC5zdWJzdHJpbmcoMCwgNTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW92ZXJsYXlUZXh0LmluY2x1ZGVzKHZlcmlmaWNhdGlvblNuaXBwZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBWZXJpZmljYXRpb24gRkFJTEVEIGZvciBwYWdlICR7cGFnZU51bX0uIE92ZXJsYXkgdGV4dCBkaWQgbm90IG1hdGNoIHRyYW5zbGF0ZWQgdGV4dC5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFeHBlY3RlZCBzbmlwcGV0OicsIHZlcmlmaWNhdGlvblNuaXBwZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FjdHVhbCBvdmVybGF5IHRleHQ6Jywgb3ZlcmxheVRleHQuc3Vic3RyaW5nKDAsIDEwMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdmVybGF5IGNvbnRlbnQgdmVyaWZpY2F0aW9uIGZhaWxlZC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdmVyaWZpY2F0aW9uIHBhc3NlcywgYWRkIHRvIGFjdGl2ZSBvdmVybGF5cyBmb3IgY2xlYW51cFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZU92ZXJsYXlzLnB1c2gobmV3T3ZlcmxheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcGFnZU51bSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3MoYCR7cHJvZ3Jlc3NQcmVmaXh9IFx1MjcwNSBQYWdlICR7cGFnZU51bX0gY29tcGxldGUuYCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hbmFnZSBtZW1vcnkgYnkgcmVtb3Zpbmcgb2xkIG92ZXJsYXlzIGZyb20gdGhlIERPTVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZU92ZXJsYXlzLmxlbmd0aCA+IDUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkT3ZlcmxheSA9IHRoaXMuYWN0aXZlT3ZlcmxheXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkT3ZlcmxheT8ucGFyZW50RWxlbWVudD8ucmVtb3ZlQ2hpbGQob2xkT3ZlcmxheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFBhZ2UgJHtwYWdlTnVtfSBmYWlsZWQgcGVybWFuZW50bHkgYWZ0ZXIgYWxsIHJldHJpZXM6YCwgZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2dyZXNzKGAke3Byb2dyZXNzUHJlZml4fSBcdTI3NEMgUGFnZSAke3BhZ2VOdW19IGZhaWxlZDogJHtlcnIubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFjaW5nRGVsYXkgPiAxMDAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzcyhgUGFjaW5nLi4uIE5leHQgcGFnZSBpbiAke01hdGgucm91bmQodGhpcy5wYWNpbmdEZWxheSAvIDEwMDApfXNgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2xlZXAodGhpcy5wYWNpbmdEZWxheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRvU2F2ZU92ZXJsYXkgPSBvcmlnaW5hbEF1dG9TYXZlO1xyXG4gICAgICAgICAgICBjb25zdCBzdW1tYXJ5ID0gYFx1RDgzQ1x1REZDMSBGaW5pc2hlZDogJHtjb21wbGV0ZWR9LyR7dG90YWxQYWdlc1RvUHJvY2Vzc30gc3VjY2VlZGVkJHtmYWlsZWQgPyBgLCAke2ZhaWxlZH0gZmFpbGVkYCA6ICcnfS5gO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2dyZXNzKHN1bW1hcnkpO1xyXG4gICAgICAgICAgICBuZXcgTm90aWNlKHN1bW1hcnksIDcwMDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgcm9idXN0IHJldHJ5IG1lY2hhbmlzbSB0aGF0IGhhbmRsZXMgdHJhbnNpZW50IGVycm9ycy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyByZXRyeVdpdGhCYWNrb2ZmPFQ+KFxyXG4gICAgICAgIG9wZXJhdGlvbjogKCkgPT4gUHJvbWlzZTxUPixcclxuICAgICAgICBwYWdlTnVtOiBudW1iZXJcclxuICAgICk6IFByb21pc2U8VD4ge1xyXG4gICAgICAgIGNvbnN0IG1heFJldHJpZXMgPSAzO1xyXG4gICAgICAgIGNvbnN0IGJhc2VEZWxheSA9IDE1MDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgbWF4UmV0cmllczsgYXR0ZW1wdCsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvbiBjYW5jZWxsZWQnKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBvcGVyYXRpb24oKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0IDwgbWF4UmV0cmllcyAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxheSA9IGJhc2VEZWxheSAqIE1hdGgucG93KDIsIGF0dGVtcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3MoYFBhZ2UgJHtwYWdlTnVtfSBmYWlsZWQgKGF0dGVtcHQgJHthdHRlbXB0ICsgMX0pLCByZXRyeWluZyBpbiAke2RlbGF5IC8gMTAwMH1zLi4uYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zbGVlcChkZWxheSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmV0cnkgbWVjaGFuaXNtIGZhaWxlZCB1bmV4cGVjdGVkbHkuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgb25DbG9zZSgpIHtcclxuICAgICAgICB0aGlzLmNvbnRlbnRFbC5lbXB0eSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzUHJvY2Vzc2luZykge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjbGVhbnVwKCkge1xyXG4gICAgICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIE1PRElGSUVEOiBDbGVhciB0aGUgY2FjaGUgb24gY2xlYW51cFxyXG4gICAgICAgIHRoaXMudHJhbnNsYXRpb25DYWNoZS5jbGVhcigpO1xyXG5cclxuICAgICAgICB0aGlzLmFjdGl2ZU92ZXJsYXlzLmZvckVhY2gob3ZlcmxheSA9PiBvdmVybGF5LnBhcmVudEVsZW1lbnQ/LnJlbW92ZUNoaWxkKG92ZXJsYXkpKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZU92ZXJsYXlzID0gW107XHJcblxyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCk7XHJcblxyXG4gICAgICAgIGlmIChUcmFuc2xhdGVNdWx0aXBsZVBhZ2VzTW9kYWwuY3VycmVudEluc3RhbmNlID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIFRyYW5zbGF0ZU11bHRpcGxlUGFnZXNNb2RhbC5pc0J1bGtUcmFuc2xhdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgVHJhbnNsYXRlTXVsdGlwbGVQYWdlc01vZGFsLmN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgZXN0aW1hdGVUb3RhbFBhZ2VzKCk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5zbGVlcCg1MDApO1xyXG4gICAgICAgIGNvbnN0IHZpZXdlciA9IGF3YWl0IHRoaXMud2FpdEZvckVsKCcucGRmVmlld2VyJywgODAwMCk7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdlcj8ucXVlcnlTZWxlY3RvckFsbCgnLnBhZ2VbZGF0YS1wYWdlLW51bWJlcl0nKS5sZW5ndGggfHwgMTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIG5hdmlnYXRlVG9QYWdlKHBkZkxlYWY6IGFueSwgcGFnZU51bTogbnVtYmVyKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgY29uc3QgcGRmVmlldyA9IHBkZkxlYWYudmlldztcclxuICAgICAgICBjb25zdCBwYWdlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yPEhUTUxFbGVtZW50PihgLnBhZ2VbZGF0YS1wYWdlLW51bWJlcj1cIiR7cGFnZU51bX1cIl1gKTtcclxuICAgICAgICBpZiAoIXBkZlZpZXcgfHwgIXBhZ2VFbCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBQREYgdmlldyBvciBwYWdlIGVsZW1lbnQgJHtwYWdlTnVtfSBub3QgZm91bmQuYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhZ2VFbC5zY3JvbGxJbnRvVmlldyh7IGJsb2NrOiAnbmVhcmVzdCcgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCB0aGlzLndhaXRGb3JDb25kaXRpb24oKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZWN0ID0gcGFnZUVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgIHJldHVybiByZWN0LmJvdHRvbSA+IDAgJiYgcmVjdC50b3AgPCB2aWV3SGVpZ2h0O1xyXG4gICAgICAgIH0sIDE1MDAwKTtcclxuXHJcbiAgICAgICAgaWYgKCFzdWNjZXNzKSBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBjb25maXJtIHBhZ2UgJHtwYWdlTnVtfSBpcyBpbiB2aWV3LmApO1xyXG4gICAgICAgIGF3YWl0IHRoaXMuc2xlZXAoNTAwKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIHdhaXRGb3JQYWdlQW5kVGV4dExheWVyKHBhZ2VOdW06IG51bWJlciwgdGltZW91dE1zOiBudW1iZXIpOiBQcm9taXNlPEhUTUxFbGVtZW50IHwgbnVsbD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYWdlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yPEhUTUxFbGVtZW50PihgLnBhZ2VbZGF0YS1wYWdlLW51bWJlcj1cIiR7cGFnZU51bX1cIl0gLnRleHRMYXllcmApO1xyXG4gICAgICAgICAgICBjb25zdCBoYXNUZXh0ID0gcGFnZUVsPy5xdWVyeVNlbGVjdG9yKCdzcGFuW3JvbGU9XCJwcmVzZW50YXRpb25cIl0nKT8udGV4dENvbnRlbnQ/LnRyaW0oKS5sZW5ndGggPz8gMCA+IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBoYXNUZXh0ID8gcGFnZUVsIS5wYXJlbnRFbGVtZW50IGFzIEhUTUxFbGVtZW50IDogbnVsbDtcclxuICAgICAgICB9LCB0aW1lb3V0TXMsIDI1MCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBzbGVlcChtczogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkgcmV0dXJuIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5yZXRyeVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChyZXNvbHZlLCBtcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyB3YWl0Rm9yRWwoc2VsZWN0b3I6IHN0cmluZywgdGltZW91dE1zOiBudW1iZXIpOiBQcm9taXNlPEhUTUxFbGVtZW50IHwgbnVsbD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndhaXRGb3JDb25kaXRpb24oKCkgPT4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcjxIVE1MRWxlbWVudD4oc2VsZWN0b3IpLCB0aW1lb3V0TXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgd2FpdEZvckNvbmRpdGlvbjxUPihcclxuICAgICAgICBjb25kaXRpb246ICgpID0+IFQgfCBudWxsIHwgZmFsc2UsXHJcbiAgICAgICAgdGltZW91dE1zOiBudW1iZXIsXHJcbiAgICAgICAgaW50ZXJ2YWxNczogbnVtYmVyID0gMTAwXHJcbiAgICApOiBQcm9taXNlPFQgfCBudWxsPiB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnQgPCB0aW1lb3V0TXMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb25kaXRpb24oKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zbGVlcChpbnRlcnZhbE1zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGlzVHJhbnNsYXRpb25JblByb2dyZXNzKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzQnVsa1RyYW5zbGF0aW9uSW5Qcm9ncmVzcztcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgY2FuY2VsQ3VycmVudFRyYW5zbGF0aW9uKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRJbnN0YW5jZT8uaXNQcm9jZXNzaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEluc3RhbmNlLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufSIsICIvLyByZXByb2Nlc3Nvci50c1xyXG5pbXBvcnQgeyBBcHAsIE5vdGljZSwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCBPcGVuUm91dGVyVHJhbnNsYXRvclBsdWdpbiBmcm9tICcuL21haW4nO1xyXG5pbXBvcnQgeyBPdmVybGF5UG9zaXRpb25EYXRhLCBTYXZlZE92ZXJsYXkgfSBmcm9tICcuL3R5cGVzJztcclxuaW1wb3J0IHsgTGF5b3V0UmVzdWx0IH0gZnJvbSAnLi9sYXlvdXQtZGV0ZWN0b3InO1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lvblJlcHJvY2Vzc29yXHJcbiAqXHJcbiAqIEVuYWJsZXMgU2hpZnQgKyBkcmFnIHRvIHNlbGVjdCBhIHJlZ2lvbiBvbiBhIFBERi5cclxuICogUkVGQUNUT1JFRDogTm93IHVzZXMgdGhlIG1haW4gVGV4dFByb2Nlc3NvciBmb3IgYWxsIGxheW91dCBhbmFseXNpcyBhbmRcclxuICogdHJhbnNsYXRpb24sIGVuc3VyaW5nIGNvbnNpc3RlbmN5IGFuZCByZWR1Y2luZyBjb2RlIGR1cGxpY2F0aW9uLiBJdHMgc29sZVxyXG4gKiByZXNwb25zaWJpbGl0aWVzIGFyZSB0byBjYXB0dXJlIHRoZSB1c2VyJ3Mgc2VsZWN0aW9uLCBkZWxlZ2F0ZSBwcm9jZXNzaW5nLFxyXG4gKiBhbmQgdGhlbiBtZXJnZSB0aGUgcmVzdWx0cyBiYWNrIGludG8gdGhlIHNhdmVkIG92ZXJsYXkgZGF0YS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSZWdpb25SZXByb2Nlc3NvciB7XHJcbiAgICBwcml2YXRlIGlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgZHJhZ1N0YXJ0OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCBudWxsID0gbnVsbDtcclxuICAgIHByaXZhdGUgYm94OiBIVE1MRGl2RWxlbWVudCB8IG51bGwgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBwbHVnaW46IE9wZW5Sb3V0ZXJUcmFuc2xhdG9yUGx1Z2luO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBkZWJ1ZzogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgY2xlYW51cCA9IG5ldyBTZXQ8KCkgPT4gdm9pZD4oKTtcclxuICAgIHByaXZhdGUgaXNBY3RpdmUgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgZnJhbWVJZDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XHJcbiAgICBwcml2YXRlIGRlYnVnR3VpZGVzID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwbHVnaW46IE9wZW5Sb3V0ZXJUcmFuc2xhdG9yUGx1Z2luKSB7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IHBsdWdpbi5zZXR0aW5ncy5kZWJ1Z01vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgYSBuZXcgcmVwcm9jZXNzaW5nIHNlc3Npb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGFydCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICBuZXcgTm90aWNlKCdBbm90aGVyIHJlcHJvY2Vzc2luZyBzZXNzaW9uIGlzIGFjdGl2ZS4gQ2FuY2VsaW5nIHByZXZpb3VzIG9uZS4nKTtcclxuICAgICAgICAgICAgdGhpcy5jbGVhbnVwQWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHZvaWQgdGhpcy5ydW4oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgZHJhZy10by1zZWxlY3QgZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSBjdXJyZW50IFBERiBwYWdlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIHJ1bigpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCB7IGFwcCwgc2V0dGluZ3MgfSA9IHRoaXMucGx1Z2luO1xyXG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbUmVnaW9uUmVwcm9jZXNzb3JdIFN0YXJ0aW5nIFx1MjAxMyB3YWl0aW5nIGZvciBTaGlmdCtkcmFnLi4uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc2V0dGluZ3MuZW5hYmxlVHJhbnNsYXRpb24pIHtcclxuICAgICAgICAgICAgbmV3IE5vdGljZSgnUERGIHRyYW5zbGF0aW9uIGlzIGRpc2FibGVkIGluIHNldHRpbmdzLicpO1xyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZpbGUgPSBhcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcclxuICAgICAgICBpZiAoIWZpbGUgfHwgZmlsZS5leHRlbnNpb24gIT09ICdwZGYnKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1BsZWFzZSBvcGVuIGEgUERGIGZpbGUgZmlyc3QuJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFnZU51bWJlciA9IHRoaXMucGx1Z2luLmdldEN1cnJlbnRQYWdlTnVtYmVyKCk7XHJcbiAgICAgICAgaWYgKCFwYWdlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ05vIHBhZ2UgY3VycmVudGx5IHZpc2libGUuJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFnZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcjxIVE1MRWxlbWVudD4oYC5wYWdlW2RhdGEtcGFnZS1udW1iZXI9XCIke3BhZ2VOdW1iZXJ9XCJdYCk7XHJcbiAgICAgICAgaWYgKCFwYWdlRWwpIHtcclxuICAgICAgICAgICAgbmV3IE5vdGljZSgnUGFnZSBpcyBub3QgcmVuZGVyZWQuIFBsZWFzZSBzY3JvbGwgaW50byB2aWV3LicpO1xyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRleHRMYXllciA9IHBhZ2VFbC5xdWVyeVNlbGVjdG9yPEhUTUxFbGVtZW50PignLnRleHRMYXllcicpO1xyXG4gICAgICAgIGlmICghdGV4dExheWVyKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1RleHQgbGF5ZXIgbm90IHJlYWR5LiBQbGVhc2Ugd2FpdCBmb3IgUERGIHRvIHJlbmRlci4nKTtcclxuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuZXcgTm90aWNlKCdcdUQ4M0RcdUREMjQgSG9sZCBTaGlmdCArIGRyYWcgdG8gcmVwcm9jZXNzIGEgcmVnaW9uJywgMzAwMCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyTGlzdGVuZXIgPSAodGFyZ2V0OiBFdmVudFRhcmdldCwgdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgdGhpcy5jbGVhbnVwLmFkZChjbGVhbnVwKTtcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgb25Nb3VzZURvd24gPSAoZTogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWUuc2hpZnRLZXkpIHJldHVybjtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSByZXR1cm47XHJcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0ID0geyB4OiBlLmNsaWVudFgsIHk6IGUuY2xpZW50WSB9O1xyXG4gICAgICAgICAgICB0aGlzLmJveD8ucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYm94ID0gY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAncGRmLXRyYW5zbGF0aW9uLXNlbGVjdGlvbi1ib3gnIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuYm94LnN0eWxlLCB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJywgbGVmdDogJzBweCcsIHRvcDogJzBweCcsIHdpZHRoOiAnMHB4JywgaGVpZ2h0OiAnMHB4JyxcclxuICAgICAgICAgICAgICAgIGJvcmRlcjogJzJweCBkYXNoZWQgcmdiYSgwLCAxMjAsIDI1NSwgMC44KScsIGJhY2tncm91bmQ6ICdyZ2JhKDAsIDEyMCwgMjU1LCAwLjEpJyxcclxuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJywgekluZGV4OiAnOTk5OTknLCBib3hTaXppbmc6ICdib3JkZXItYm94JywgYm9yZGVyUmFkaXVzOiAnMnB4JyxcclxuICAgICAgICAgICAgICAgIGJveFNoYWRvdzogJzAgMCA2cHggcmdiYSgwLCAwLCAwLCAwLjIpJywgdHJhbnNmb3JtOiAndHJhbnNsYXRlWigwKScsIHdpbGxDaGFuZ2U6ICd0cmFuc2Zvcm0nLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmJveCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgb25Nb3VzZU1vdmUgPSAoZTogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZyB8fCAhdGhpcy5kcmFnU3RhcnQgfHwgIXRoaXMuYm94KSByZXR1cm47XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZnJhbWVJZCAhPT0gbnVsbCkgcmV0dXJuO1xyXG4gICAgICAgICAgICB0aGlzLmZyYW1lSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHg6IHN0YXJ0WCwgeTogc3RhcnRZIH0gPSB0aGlzLmRyYWdTdGFydCE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0ID0gTWF0aC5taW4oc3RhcnRYLCBjbGllbnRYKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvcCA9IE1hdGgubWluKHN0YXJ0WSwgY2xpZW50WSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGguYWJzKGNsaWVudFggLSBzdGFydFgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnMoY2xpZW50WSAtIHN0YXJ0WSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJveCEuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2xlZnR9cHgsICR7dG9wfXB4KWA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJveCEuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJveCEuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgb25Nb3VzZVVwID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcpIHJldHVybjtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZnJhbWVJZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mcmFtZUlkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVjdCA9IG5ldyBET01SZWN0KFxyXG4gICAgICAgICAgICAgICAgTWF0aC5taW4odGhpcy5kcmFnU3RhcnQhLngsIGUuY2xpZW50WCksXHJcbiAgICAgICAgICAgICAgICBNYXRoLm1pbih0aGlzLmRyYWdTdGFydCEueSwgZS5jbGllbnRZKSxcclxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGUuY2xpZW50WCAtIHRoaXMuZHJhZ1N0YXJ0IS54KSxcclxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGUuY2xpZW50WSAtIHRoaXMuZHJhZ1N0YXJ0IS55KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFudXBBbGwoKTtcclxuICAgICAgICAgICAgaWYgKHJlY3Qud2lkdGggPiA1ICYmIHJlY3QuaGVpZ2h0ID4gNSkge1xyXG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLmhhbmRsZVJlZ2lvblJlcHJvY2Vzc2luZyhyZWN0LCBwYWdlTnVtYmVyLCBmaWxlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBvbktleURvd24gPSAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdFc2NhcGUnKSB7XHJcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdSZWdpb24gc2VsZWN0aW9uIGNhbmNlbGVkLicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwQWxsKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmVnaXN0ZXJMaXN0ZW5lcihwYWdlRWwsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XHJcbiAgICAgICAgcmVnaXN0ZXJMaXN0ZW5lcihkb2N1bWVudCwgJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcclxuICAgICAgICByZWdpc3Rlckxpc3RlbmVyKGRvY3VtZW50LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XHJcbiAgICAgICAgcmVnaXN0ZXJMaXN0ZW5lcihkb2N1bWVudCwgJ2tleWRvd24nLCBvbktleURvd24pO1xyXG5cclxuICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdSZWdpb24gc2VsZWN0aW9uIHRpbWVkIG91dC4nLCAyMDAwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cEFsbCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDE1MDAwKTtcclxuICAgICAgICB0aGlzLmNsZWFudXAuYWRkKCgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJFRkFDVE9SRUQ6IFByb2Nlc3NlcyB0aGUgc2VsZWN0ZWQgcmVnaW9uIGJ5IGRlbGVnYXRpbmcgcGFyYWdyYXBoIGRldGVjdGlvblxyXG4gICAgICogYW5kIHRyYW5zbGF0aW9uIHRvIHRoZSBtYWluIFRleHRQcm9jZXNzb3IsIHRoZW4gaGFuZGxlcyBzYXZpbmcgdGhlIHJlc3VsdHMuXHJcbiAgICAgKiBDYWxjdWxhdGVzIG9yaWdpbmFsIGZvbnQgc2l6ZXMgY29ycmVjdGx5IGJhc2VkIG9uIHRoZSBjdXJyZW50IHZpZXdlciBzY2FsZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBoYW5kbGVSZWdpb25SZXByb2Nlc3NpbmcoXHJcbiAgICAgICAgc2NyZWVuUmVjdDogRE9NUmVjdCxcclxuICAgICAgICBwYWdlTnVtYmVyOiBudW1iZXIsXHJcbiAgICAgICAgZmlsZTogVEZpbGVcclxuICAgICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHBhZ2VFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3I8SFRNTEVsZW1lbnQ+KGAucGFnZVtkYXRhLXBhZ2UtbnVtYmVyPVwiJHtwYWdlTnVtYmVyfVwiXWApO1xyXG4gICAgICAgIGNvbnN0IHRleHRMYXllciA9IHBhZ2VFbD8ucXVlcnlTZWxlY3RvcjxIVE1MRWxlbWVudD4oJy50ZXh0TGF5ZXInKTtcclxuICAgICAgICBpZiAoIXBhZ2VFbCB8fCAhdGV4dExheWVyKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1x1MjZBMFx1RkUwRiBQYWdlIG9yIHRleHQgbGF5ZXIgbm90IGF2YWlsYWJsZS4nKTtcclxuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RlcCAxOiBGaWx0ZXIgc3BhbnMgYmFzZWQgb24gc2VsZWN0aW9uIChSZXByb2Nlc3NvcidzIHVuaXF1ZSBqb2IpXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRTcGFucyA9IEFycmF5LmZyb20odGV4dExheWVyLnF1ZXJ5U2VsZWN0b3JBbGw8SFRNTFNwYW5FbGVtZW50Pignc3BhbicpKVxyXG4gICAgICAgICAgICAuZmlsdGVyKHNwYW4gPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHNwYW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdmVybGFwcyA9ICEoci5yaWdodCA8IHNjcmVlblJlY3QubGVmdCB8fCByLmxlZnQgPiBzY3JlZW5SZWN0LnJpZ2h0IHx8IHIuYm90dG9tIDwgc2NyZWVuUmVjdC50b3AgfHwgci50b3AgPiBzY3JlZW5SZWN0LmJvdHRvbSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmxhcHM7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5maWx0ZXIoc3BhbiA9PiB0aGlzLnBsdWdpbi5wcm9jZXNzb3IuaXNWYWxpZFNwYW4oc3BhbikpO1xyXG5cclxuICAgICAgICBpZiAoc2VsZWN0ZWRTcGFucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgbmV3IE5vdGljZSgnXHUyNkEwXHVGRTBGIE5vIHZhbGlkIHRleHQgZm91bmQgaW4gc2VsZWN0ZWQgcmVnaW9uLicpO1xyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdGVwIDI6IERlbGVnYXRlIHByb2Nlc3NpbmcgYW5kIHRyYW5zbGF0aW9uIHRvIHRoZSBtYWluIFRleHRQcm9jZXNzb3JcclxuICAgICAgICBjb25zdCB0cmFuc2xhdGlvblVuaXRzID0gdGhpcy5wbHVnaW4ucHJvY2Vzc29yLnByZXBhcmVUcmFuc2xhdGlvblVuaXRzKHNlbGVjdGVkU3BhbnMsIHBhZ2VFbCk7XHJcbiAgICAgICAgaWYgKCF0cmFuc2xhdGlvblVuaXRzIHx8IHRyYW5zbGF0aW9uVW5pdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ05vIHRyYW5zbGF0YWJsZSBzZWdtZW50cyBmb3VuZCBpbiB0aGUgc2VsZWN0ZWQgcmVnaW9uLicpO1xyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5ldyBOb3RpY2UoYFx1RDgzRFx1REQwMSBUcmFuc2xhdGluZyAke3RyYW5zbGF0aW9uVW5pdHMubGVuZ3RofSBzZWdtZW50KHMpLi4uYCwgMzAwMCk7XHJcblxyXG4gICAgICAgIGxldCB0cmFuc2xhdGVkVGV4dHM6IHN0cmluZ1tdO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZWRUZXh0cyA9IGF3YWl0IHRoaXMucGx1Z2luLnByb2Nlc3Nvci5leGVjdXRlVHJhbnNsYXRpb24odHJhbnNsYXRpb25Vbml0cyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW1JlZ2lvblJlcHJvY2Vzc29yXSBUcmFuc2xhdGlvbiBmYWlsZWQ6JywgZXJyKTtcclxuICAgICAgICAgICAgbmV3IE5vdGljZShgXHUyNzRDIFRyYW5zbGF0aW9uIGZhaWxlZDogJHtlcnIubWVzc2FnZX0uIFVzaW5nIG9yaWdpbmFsIHRleHQuYCk7XHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZWRUZXh0cyA9IHRyYW5zbGF0aW9uVW5pdHMubWFwKHUgPT4gdS50ZXh0KTsgLy8gRmFsbGJhY2sgdG8gb3JpZ2luYWwgdGV4dFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RlcCAzOiBHZW5lcmF0ZSBvdmVybGF5IGRhdGEgZm9yIHNhdmluZyAoUmVwcm9jZXNzb3IncyB1bmlxdWUgam9iKVxyXG4gICAgICAgIGNvbnN0IG5ld0l0ZW1zOiBPdmVybGF5UG9zaXRpb25EYXRhW10gPSBbXTtcclxuXHJcbiAgICAgICAgLy8gLS0tIENPUlJFQ1RFRCBGT05UIFNJWkUgQ0FMQ1VMQVRJT04gLS0tXHJcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHNjYWxlIGZhY3RvciBmcm9tIHRoZSBQREYgdmlld2VyIGNvbnRhaW5lciAqYXQgdGhlIHRpbWUgb2Ygc2VsZWN0aW9uKi5cclxuICAgICAgICBjb25zdCBwZGZWaWV3ZXIgPSBwYWdlRWwuY2xvc2VzdCgnLnBkZlZpZXdlciwgI3ZpZXdlcicpIGFzIEhUTUxFbGVtZW50IHwgbnVsbDtcclxuICAgICAgICBjb25zdCBjdXJyZW50U2NhbGVGcm9tVmlld2VyID0gcGFyc2VGbG9hdChwZGZWaWV3ZXI/LnN0eWxlLmdldFByb3BlcnR5VmFsdWUoJy0tc2NhbGUtZmFjdG9yJykgfHwgJzEnKTtcclxuICAgICAgICBpZiAoaXNOYU4oY3VycmVudFNjYWxlRnJvbVZpZXdlcikgfHwgY3VycmVudFNjYWxlRnJvbVZpZXdlciA8PSAwKSB7XHJcbiAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tSZWdpb25SZXByb2Nlc3Nvcl0gSW52YWxpZCBzY2FsZSBmYWN0b3IgZm91bmQsIGRlZmF1bHRpbmcgdG8gMS4wJyk7XHJcbiAgICAgICAgICAgICAvLyBGYWxsYmFjayBtaWdodCBiZSB0byBnZXRDb21wdXRlZFN0eWxlIHRyYW5zZm9ybSwgYnV0IC0tc2NhbGUtZmFjdG9yIGlzIHVzdWFsbHkgcmVsaWFibGVcclxuICAgICAgICAgICAgIC8vIEZvciBub3csIGp1c3Qgd2FybiBhbmQgcHJvY2VlZCwgcG90ZW50aWFsbHkgbGVhZGluZyB0byBpbmNvcnJlY3Qgc2l6ZSBpZiBpdCdzIHRydWx5IHdyb25nLlxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAtLS0gRU5EIENPUlJFQ1RFRCBGT05UIFNJWkUgQ0FMQ1VMQVRJT04gLS0tXHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNsYXRpb25Vbml0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsU3BhbnMsIHRleHQgfSA9IHRyYW5zbGF0aW9uVW5pdHNbaV07XHJcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbFNwYW5zLmxlbmd0aCA9PT0gMCkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAvLyBVc2UgcHJvY2Vzc29yLmdldFNwYW5zQmJveCB3aGljaCByZXR1cm5zIHNjYWxlZCB2YWx1ZXMgcmVsYXRpdmUgdG8gdGhlIHBhZ2UgZWxlbWVudFxyXG4gICAgICAgICAgICBjb25zdCBiYm94UmVzdWx0ID0gdGhpcy5wbHVnaW4ucHJvY2Vzc29yLmdldFNwYW5zQmJveChvcmlnaW5hbFNwYW5zLCBwYWdlRWwpO1xyXG4gICAgICAgICAgICBpZiAoIWJib3hSZXN1bHQgfHwgIWJib3hSZXN1bHQucmVjdCkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBjb25zdCByYXdCYm94ID0gYmJveFJlc3VsdC5yZWN0OyAvLyBUaGlzIGlzIGFscmVhZHkgc2NhbGVkIHJlbGF0aXZlIHRvIHBhZ2VFbCdzIGN1cnJlbnQgdHJhbnNmb3JtXHJcblxyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcmVsYXRpdmUgcmVjdCBiYXNlZCBvbiB0aGUgKmN1cnJlbnQqIHBhZ2UgZGltZW5zaW9ucyAoYWZmZWN0ZWQgYnkgc2NhbGUpXHJcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VSZWN0ID0gcGFnZUVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBUaGlzIGlzIHRoZSAqc2NhbGVkKiBwYWdlIHJlY3RcclxuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVSZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogcmF3QmJveC5sZWZ0IC8gcGFnZVJlY3Qud2lkdGgsIC8vIHJhd0Jib3gubGVmdCBpcyByZWxhdGl2ZSB0byBwYWdlRWwncyBjb250ZW50IChzY2FsZWQpXHJcbiAgICAgICAgICAgICAgICB0b3A6IHJhd0Jib3gudG9wIC8gcGFnZVJlY3QuaGVpZ2h0LCAgLy8gcmF3QmJveC50b3AgaXMgcmVsYXRpdmUgdG8gcGFnZUVsJ3MgY29udGVudCAoc2NhbGVkKVxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJhd0Jib3gud2lkdGggLyBwYWdlUmVjdC53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogcmF3QmJveC5oZWlnaHQgLyBwYWdlUmVjdC5oZWlnaHQsXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhyZWxhdGl2ZVJlY3QpLnNvbWUodiA9PiAhaXNGaW5pdGUodikpIHx8IHJlbGF0aXZlUmVjdC53aWR0aCA8PSAwIHx8IHJlbGF0aXZlUmVjdC5oZWlnaHQgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnW1JlZ2lvblJlcHJvY2Vzc29yXSBTa2lwcGluZyBpdGVtIHdpdGggaW52YWxpZCByZWxhdGl2ZSByZWN0OicsIHJlbGF0aXZlUmVjdCk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gLS0tIENPUlJFQ1RFRCBGT05UIFNJWkUgQ0FMQ1VMQVRJT04gLS0tXHJcbiAgICAgICAgICAgIC8vIGJib3hSZXN1bHQuZm9udFNpemVzIGFuZCBhdmdGb250U2l6ZSBhcmUgc2NhbGVkICh0aGV5IGNvbWUgZnJvbSBnZXRTcGFuc0Jib3ggb24gc2NhbGVkIHNwYW5zKS5cclxuICAgICAgICAgICAgLy8gVG8gc3RvcmUgdGhlICdvcmlnaW5hbCcgc2l6ZSBmb3IgbGF0ZXIgcmVuZGVyaW5nLCB3ZSBuZWVkIHRvIGRpdmlkZSBieSB0aGUgY3VycmVudCBzY2FsZS5cclxuICAgICAgICAgICAgLy8gSG93ZXZlciwgdGhlIE92ZXJsYXlVSVJlbmRlcmVyIGV4cGVjdHMgJ29yaWdpbmFsRm9udFNpemVzJyB0byBiZSB0aGUgYmFzZSBzaXplICpiZWZvcmUqIGFwcGx5aW5nIHNjYWxlIGFuZCBvdXRwdXRGb250U2l6ZVNjYWxlLlxyXG4gICAgICAgICAgICAvLyBUaGVyZWZvcmUsIHN0b3JpbmcgdGhlIHNpemVzIGFzIHRoZXkgd2VyZSAqb2JzZXJ2ZWQqIChzY2FsZWQpIGFuZCBsZXR0aW5nIE92ZXJsYXlVSVJlbmRlcmVyIGhhbmRsZSB0aGUgc2NhbGluZyBjb3JyZWN0bHkgaXMga2V5LlxyXG4gICAgICAgICAgICAvLyBMZXQncyBzdG9yZSB0aGUgc2l6ZXMgYXMgdGhleSB3ZXJlICpvYnNlcnZlZCogKHNjYWxlZCkgYW5kIGxldCB0aGUgcmVuZGVyZXIgZGVyaXZlIHRoZSBiYXNlIHNpemUgY29ycmVjdGx5LlxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGF2ZXJhZ2UgZm9udCBzaXplIG9ic2VydmVkICphdCB0aGUgY3VycmVudCBzY2FsZSouXHJcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVkQXZnRm9udFNpemUgPSBiYm94UmVzdWx0LmF2Z0ZvbnRTaXplOyAvLyBUaGlzIGlzIHRoZSBzY2FsZWQgc2l6ZVxyXG4gICAgICAgICAgICAvLyBUaGUgb3JpZ2luYWwgZm9udCBzaXplcyBvYnNlcnZlZCAqYXQgdGhlIGN1cnJlbnQgc2NhbGUqLlxyXG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlZE9yaWdpbmFsRm9udFNpemVzID0gYmJveFJlc3VsdC5mb250U2l6ZXM7IC8vIFRoZXNlIGFyZSB0aGUgc2NhbGVkIHNpemVzXHJcblxyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlICpiYXNlKiBmb250IHNpemUgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgb3JpZ2luYWwgUERGIHRleHQgc2l6ZS5cclxuICAgICAgICAgICAgLy8gVGhpcyBpcyB3aGF0IHRoZSBPdmVybGF5VUlSZW5kZXJlciB3aWxsIHVzZSBiZWZvcmUgYXBwbHlpbmcgc2NhbGUgYW5kIG91dHB1dEZvbnRTaXplU2NhbGUuXHJcbiAgICAgICAgICAgIGNvbnN0IGJhc2VBdmdGb250U2l6ZSA9IG9ic2VydmVkQXZnRm9udFNpemUgLyBjdXJyZW50U2NhbGVGcm9tVmlld2VyO1xyXG4gICAgICAgICAgICBjb25zdCBiYXNlT3JpZ2luYWxGb250U2l6ZXMgPSBvYnNlcnZlZE9yaWdpbmFsRm9udFNpemVzLm1hcChmcyA9PiBmcyAvIGN1cnJlbnRTY2FsZUZyb21WaWV3ZXIpO1xyXG4gICAgICAgICAgICAvLyAtLS0gRU5EIENPUlJFQ1RFRCBGT05UIFNJWkUgQ0FMQ1VMQVRJT04gLS0tXHJcblxyXG4gICAgICAgICAgICBuZXdJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnJywgLy8gTm90IHVzZWQgZm9yIHNhdmVkIG92ZXJsYXlzIHR5cGljYWxseVxyXG4gICAgICAgICAgICAgICAgdGV4dENvbnRlbnQ6IHRleHQsIC8vIE9yaWdpbmFsIEhUTUwgdGV4dCBjb250ZW50XHJcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVkVGV4dDogdHJhbnNsYXRlZFRleHRzW2ldIHx8IHRleHQsIC8vIFRyYW5zbGF0ZWQgdGV4dFxyXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVSZWN0LCAvLyBSZWxhdGl2ZSBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgcGFnZTogcGFnZU51bWJlciwgLy8gUGFnZSBudW1iZXJcclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSAqYmFzZSogKHVuc2NhbGVkKSBmb250IHNpemVzLCBhcyBleHBlY3RlZCBieSBPdmVybGF5VUlSZW5kZXJlclxyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxGb250U2l6ZXM6IGJhc2VPcmlnaW5hbEZvbnRTaXplcyxcclxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IGJib3hSZXN1bHQuZm9udEZhbWlseSxcclxuICAgICAgICAgICAgICAgIC8vIGZvbnRTaXplIGlzIG9mdGVuIGRlcml2ZWQgZnJvbSBvcmlnaW5hbEZvbnRTaXplcyBvciBub3Qgc3RyaWN0bHkgbmVlZGVkIGlmIG9yaWdpbmFsRm9udFNpemVzIGlzIHByZXNlbnRcclxuICAgICAgICAgICAgICAgIC8vIElmIHlvdSBzdGlsbCB3YW50IHRvIHN0b3JlIGl0LCBzdG9yZSB0aGUgYmFzZSBzaXplOlxyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IGJhc2VBdmdGb250U2l6ZSxcclxuICAgICAgICAgICAgICAgIGlkOiBgcmVwcm9jLSR7RGF0ZS5ub3coKX0tJHtpfWAsIC8vIFVuaXF1ZSBJRCBmb3IgdGhlIGl0ZW1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobmV3SXRlbXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1x1MjZBMFx1RkUwRiBObyB2YWxpZCBsYXlvdXQgcmVnaW9ucyBjb3VsZCBiZSBnZW5lcmF0ZWQgZnJvbSB0aGUgc2VsZWN0aW9uLicpO1xyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdGVwIDQ6IE1lcmdlIG5ldyBpdGVtcywgc2F2ZSwgYW5kIHJlZnJlc2ggdGhlIHZpZXcgKFJlcHJvY2Vzc29yJ3MgdW5pcXVlIGpvYilcclxuICAgICAgICBjb25zdCBzYXZlZE92ZXJsYXkgPSBhd2FpdCB0aGlzLmxvYWRTYXZlZE92ZXJsYXkoZmlsZSk7XHJcbiAgICAgICAgY29uc3QgcGFnZUtleSA9IFN0cmluZyhwYWdlTnVtYmVyKTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ0l0ZW1zID0gc2F2ZWRPdmVybGF5LnBhZ2VPdmVybGF5c1twYWdlS2V5XSB8fCBbXTtcclxuICAgICAgICBjb25zdCBub25PdmVybGFwcGluZ09sZEl0ZW1zID0gZXhpc3RpbmdJdGVtcy5maWx0ZXIob2xkSXRlbSA9PlxyXG4gICAgICAgICAgICAhbmV3SXRlbXMuc29tZShuZXdJdGVtID0+IHRoaXMuaXNPdmVybGFwcGluZyhvbGRJdGVtLnJlbGF0aXZlUmVjdCwgbmV3SXRlbS5yZWxhdGl2ZVJlY3QpKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHNhdmVkT3ZlcmxheS5wYWdlT3ZlcmxheXNbcGFnZUtleV0gPSBbLi4ubm9uT3ZlcmxhcHBpbmdPbGRJdGVtcywgLi4ubmV3SXRlbXNdO1xyXG4gICAgICAgIHNhdmVkT3ZlcmxheS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgICAgICBhd2FpdCB0aGlzLnNhdmVPdmVybGF5KHNhdmVkT3ZlcmxheSwgZmlsZSk7XHJcblxyXG4gICAgICAgIHRoaXMucGx1Z2luLmNsZWFyQWxsT3ZlcmxheXMoKTtcclxuICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zdG9yYWdlLmxvYWRTYXZlZE92ZXJsYXlGb3JDdXJyZW50UGFnZShmaWxlLCB0cnVlKTsgLy8gRm9yY2UgcmVsb2FkXHJcblxyXG4gICAgICAgIG5ldyBOb3RpY2UoYFx1MjcwNSBSZXByb2Nlc3NlZCBhbmQgc2F2ZWQgJHtuZXdJdGVtcy5sZW5ndGh9IHNlZ21lbnQocylgKTtcclxuICAgICAgICB0aGlzLmZpbmlzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgbG9hZFNhdmVkT3ZlcmxheShmaWxlOiBURmlsZSk6IFByb21pc2U8U2F2ZWRPdmVybGF5PiB7XHJcbiAgICAgICAgY29uc3QgeyBzdG9yYWdlIH0gPSB0aGlzLnBsdWdpbjtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdG9yYWdlLnJlYWRTYXZlZE92ZXJsYXlGb3JGaWxlKGZpbGUpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ/Lm92ZXJsYXkgfHwge1xyXG4gICAgICAgICAgICBmaWxlTmFtZTogZmlsZS5iYXNlbmFtZS5yZXBsYWNlKC9cXC5wZGYkL2ksICcnKSxcclxuICAgICAgICAgICAgZmlsZVBhdGg6IGZpbGUucGF0aCxcclxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICBwYWdlT3ZlcmxheXM6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBzYXZlT3ZlcmxheShzYXZlZE92ZXJsYXk6IFNhdmVkT3ZlcmxheSwgZmlsZTogVEZpbGUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zdG9yYWdlLndyaXRlU2F2ZWRPdmVybGF5Rm9yRmlsZShmaWxlLCBzYXZlZE92ZXJsYXkpO1xyXG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUmVnaW9uUmVwcm9jZXNzb3JdIFNhdmVkIHVwZGF0ZXMgZm9yICR7ZmlsZS5wYXRofWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGlzT3ZlcmxhcHBpbmcoXHJcbiAgICAgICAgYTogeyBsZWZ0OiBudW1iZXI7IHRvcDogbnVtYmVyOyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9LFxyXG4gICAgICAgIGI6IHsgbGVmdDogbnVtYmVyOyB0b3A6IG51bWJlcjsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfVxyXG4gICAgKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgZXBzID0gMWUtNTtcclxuICAgICAgICByZXR1cm4gIShcclxuICAgICAgICAgICAgYS5sZWZ0ICsgYS53aWR0aCA8IGIubGVmdCAtIGVwcyB8fFxyXG4gICAgICAgICAgICBiLmxlZnQgKyBiLndpZHRoIDwgYS5sZWZ0IC0gZXBzIHx8XHJcbiAgICAgICAgICAgIGEudG9wICsgYS5oZWlnaHQgPCBiLnRvcCAtIGVwcyB8fFxyXG4gICAgICAgICAgICBiLnRvcCArIGIuaGVpZ2h0IDwgYS50b3AgLSBlcHNcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY2xlYW51cEFsbCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmNsZWFudXAuZm9yRWFjaChmbiA9PiBmbigpKTtcclxuICAgICAgICB0aGlzLmNsZWFudXAuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmJveD8ucmVtb3ZlKCk7XHJcbiAgICAgICAgdGhpcy5ib3ggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5mcmFtZUlkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZnJhbWVJZCk7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGVidWdHdWlkZXMuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmUoKSk7XHJcbiAgICAgICAgdGhpcy5kZWJ1Z0d1aWRlcy5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZmluaXNoKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY2xlYW51cEFsbCgpO1xyXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcclxuICAgIH1cclxufSJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBLElBQUFBLG9CQUE2Rjs7O0FDQTdGLHNCQWNPOzs7QUNnSEEsSUFBTSxzQkFBc0I7QUFBQSxFQUMvQixFQUFFLE1BQU0sUUFBUSxNQUFNLGNBQWM7QUFBQSxFQUNwQyxFQUFFLE1BQU0sTUFBTSxNQUFNLFVBQVU7QUFBQSxFQUM5QixFQUFFLE1BQU0sTUFBTSxNQUFNLFVBQVU7QUFBQSxFQUM5QixFQUFFLE1BQU0sTUFBTSxNQUFNLFNBQVM7QUFBQSxFQUM3QixFQUFFLE1BQU0sTUFBTSxNQUFNLFNBQVM7QUFBQSxFQUM3QixFQUFFLE1BQU0sTUFBTSxNQUFNLFVBQVU7QUFBQSxFQUM5QixFQUFFLE1BQU0sTUFBTSxNQUFNLGFBQWE7QUFBQSxFQUNqQyxFQUFFLE1BQU0sTUFBTSxNQUFNLFVBQVU7QUFBQSxFQUM5QixFQUFFLE1BQU0sTUFBTSxNQUFNLFdBQVc7QUFBQSxFQUMvQixFQUFFLE1BQU0sTUFBTSxNQUFNLFNBQVM7QUFBQSxFQUM3QixFQUFFLE1BQU0sTUFBTSxNQUFNLFVBQVU7QUFBQSxFQUM5QixFQUFFLE1BQU0sTUFBTSxNQUFNLFNBQVM7QUFBQSxFQUM3QixFQUFFLE1BQU0sTUFBTSxNQUFNLFFBQVE7QUFBQSxFQUM1QixFQUFFLE1BQU0sTUFBTSxNQUFNLFFBQVE7QUFBQSxFQUM1QixFQUFFLE1BQU0sTUFBTSxNQUFNLFNBQVM7QUFBQSxFQUM3QixFQUFFLE1BQU0sTUFBTSxNQUFNLFVBQVU7QUFBQSxFQUM5QixFQUFFLE1BQU0sTUFBTSxNQUFNLFVBQVU7QUFBQSxFQUM5QixFQUFFLE1BQU0sTUFBTSxNQUFNLFlBQVk7QUFBQSxFQUNoQyxFQUFFLE1BQU0sTUFBTSxNQUFNLFlBQVk7QUFBQSxFQUNoQyxFQUFFLE1BQU0sTUFBTSxNQUFNLFNBQVM7QUFBQSxFQUM3QixFQUFFLE1BQU0sTUFBTSxNQUFNLFVBQVU7QUFBQSxFQUM5QixFQUFFLE1BQU0sTUFBTSxNQUFNLFFBQVE7QUFBQSxFQUM1QixFQUFFLE1BQU0sTUFBTSxNQUFNLFlBQVk7QUFBQSxFQUNoQyxFQUFFLE1BQU0sTUFBTSxNQUFNLFdBQVc7QUFBQSxFQUMvQixFQUFFLE1BQU0sTUFBTSxNQUFNLFlBQVk7QUFBQSxFQUNoQyxFQUFFLE1BQU0sTUFBTSxNQUFNLFdBQVc7QUFBQSxFQUMvQixFQUFFLE1BQU0sTUFBTSxNQUFNLFNBQVM7QUFBQSxFQUM3QixFQUFFLE1BQU0sTUFBTSxNQUFNLFlBQVk7QUFBQSxFQUNoQyxFQUFFLE1B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RUFDMUI7QUFBQSxFQUVBLG1CQUFtQjtBQUNmLGFBQVMsaUJBQWlCLDZCQUE2QixFQUFFLFFBQVEsUUFBTSxHQUFHLE9BQU8sQ0FBQztBQUFBLEVBQ3RGO0FBQUEsRUFFQSx3QkFBNEM7QUFDeEMsV0FBTyxLQUFLLFFBQVEsc0JBQXNCO0FBQUEsRUFDOUM7QUFBQSxFQUVBLFNBQVMsWUFBb0IsTUFBbUI7QUFDNUMsUUFBSSxLQUFLLFNBQVMsV0FBVztBQUN6QixjQUFRLElBQUksb0JBQW9CLFdBQVcsR0FBRyxJQUFJO0FBQUEsSUFDdEQ7QUFBQSxFQUNKO0FBQ0o7QUFFTyxJQUFNLG1CQUFOLGNBQStCLG9DQUEwQjtBQUFBLEVBRzVELFlBQVksS0FBVSxRQUFvQztBQUN0RCxVQUFNLEdBQUc7QUFDVCxTQUFLLFNBQVM7QUFDZCxTQUFLLGVBQWUsNEJBQTRCO0FBQUEsRUFDcEQ7QUFBQSxFQUVBLFdBQXFCO0FBQ2pCLFdBQU8sY0FBYyxjQUFjO0FBQUEsRUFDdkM7QUFBQSxFQUVBLFlBQVksUUFBd0I7QUFDaEMsV0FBTyxPQUFPO0FBQUEsRUFDbEI7QUFBQSxFQUVBLGFBQWEsUUFBZ0IsS0FBdUM7QUFDaEUsU0FBSyxPQUFPLHVCQUF1QixPQUFPLFVBQVUsT0FBTyxJQUFJO0FBQUEsRUFDbkU7QUFDSjsiLAogICJuYW1lcyI6IFsiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJleGlzdGluZ092ZXJsYXkiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiX2EiLCAiX2EiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJob3Jpem9udGFsT3ZlcmxhcCIsICJfYSIsICJfYiIsICJtZWRpYW4iLCAiYiIsICJyZWN0IiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iXQp9Cg==
